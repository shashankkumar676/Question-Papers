)]}'
{"version":3,"sources":["u2622:persistent-session/lib/persistent_session.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,8E;AACA,mG;AACA,E;AACA,wG;AACA,kC;AACA,0B;AACA,uB;AACA,gC;AACA,E;AACA,mC;AACA,6D;AACA,qB;AACA,iC;AACA,E;;AAEA,4B;AACA,mB;AACA,E;;;AAGA,yC;AACA,6B;AACA,8B;;AAEA,4C;AACA,gC;AACA,+D;AACA,sG;;AAEA,qC;AACA,Y;AACA,8C;AACA,K;;AAEA,U;AACA,iD;AACA,G;;;AAGA,I;AACA,oE;AACA,8D;AACA,K;AACA,2B;;AAEA,oC;AACA,uB;AACA,uB;AACA,uB;AACA,uB;;AAEA,sC;AACA,iG;AACA,wB;AACA,+B;AACA,kD;AACA,mF;AACA,G;;;AAGA,kB;;AAEA,yB;AACA,I;AACA,qE;AACA,K;AACA,6B;AACA,kF;AACA,a;AACA,K;;AAEA,iE;AACA,mE;;AAEA,oD;AACA,kC;AACA,gE;AACA,S;AACA,O;;AAEA,0E;AACA,I;;AAEA,wB;;AAEA,wE;AACA,8B;AACA,c;;AAEA,uB;;AAEA,wB;AACA,gE;AACA,qE;AACA,6C;AACA,mD;AACA,sC;AACA,kD;AACA,W;AACA,S;AACA,O;;AAEA,2B;AACA,kE;AACA,uE;AACA,8C;AACA,oD;AACA,uC;AACA,sD;AACA,W;AACA,S;AACA,O;;AAEA,O;;AAEA,I;;AAEA,+B;AACA,mC;AACA,wB;AACA,kC;AACA,mB;AACA,qD;AACA,c;AACA,gD;AACA,wB;AACA,O;AACA,K;AACA,K;;AAEA,c;AACA,E;;AAEA,oC;AACA,yE;AACA,iC;AACA,uE;AACA,uE;;AAEA,sB;AACA,+C;AACA,U;;AAEA,qD;AACA,sD;AACA,4B;AACA,6B;;AAEA,iE;AACA,mB;;AAEA,oC;AACA,kD;AACA,sD;;AAEA,uC;AACA,mD;AACA,wD;AACA,K;;AAEA,gD;AACA,kD;AACA,kE;AACA,G;AACA,E;;;AAGA,c;AACA,yD;AACA,iE;AACA,qD;AACA,E;AACA,wD;AACA,8B;AACA,Y;AACA,6C;AACA,oC;AACA,wD;AACA,G;;AAEA,I;AACA,2E;AACA,2E;AACA,K;AACA,8C;AACA,e;AACA,G;AACA,e;AACA,E;;;AAGA,c;AACA,iE;AACA,yD;AACA,qD;AACA,E;AACA,sF;;AAEA,qG;AACA,mE;AACA,gD;AACA,W;AACA,G;;AAEA,wB;AACA,yB;AACA,wH;AACA,oG;AACA,6B;AACA,Y;AACA,0B;AACA,K;AACA,G;AACA,+B;AACA,2B;AACA,E;;;AAGA,6G;AACA,oB;AACA,qD;AACA,2B;AACA,gC;AACA,G;AACA,e;AACA,gD;AACA,4B;AACA,K;AACA,a;AACA,C;;AAEA,uF;AACA,kB;;AAEA,uC;AACA,wC;AACA,K;AACA,E;;AAEA,qE;AACA,wB;AACA,+B;AACA,+C;AACA,gC;AACA,G;AACA,C;;AAEA,iB;AACA,4G;AACA,qE;;AAEA,6C;AACA,sB;AACA,sB;AACA,4C;AACA,G;;AAEA,sE;AACA,oE;AACA,0E;AACA,wE;AACA,6E;AACA,kD;AACA,I;AACA,yE;AACA,mB;AACA,kC;AACA,kC;AACA,mC;AACA,qC;AACA,iC;AACA,iD;AACA,uB;AACA,iE;AACA,G;AACA,yC;;AAEA,uB;AACA,yB;;AAEA,+D;AACA,6E;;AAEA,uE;AACA,gB;AACA,sB;AACA,wC;AACA,yE;AACA,mD;AACA,4E;AACA,+D;AACA,S;AACA,K;AACA,G;;AAEA,+B;;AAEA,uC;AACA,E;;AAEA,wB;AACA,kD;AACA,oF;AACA,6C;AACA,E;AACA,+E;AACA,6C;AACA,E;;AAEA,yB;AACA,8C;AACA,2F;AACA,4C;AACA,E;;AAEA,4B;AACA,6E;AACA,+E;AACA,2C;AACA,E;;;AAGA,wC;AACA,iC;AACA,kE;AACA,+B;AACA,E;AACA,8E;AACA,0B;AACA,qC;AACA,E;AACA,kE;AACA,0B;AACA,wC;AACA,E;;;;AAIA,gB;AACA,mE;AACA,uD;AACA,E;AACA,kE;AACA,kB;AACA,gC;;AAEA,oD;AACA,mB;AACA,oC;AACA,gB;AACA,U;AACA,kB;AACA,G;;AAEA,gE;AACA,uB;AACA,uB;AACA,iB;AACA,oC;AACA,+B;AACA,O;AACA,G;;AAEA,sC;AACA,4C;AACA,K;AACA,E;;;AAGA,4G;AACA,+G;AACA,kE;AACA,kB;AACA,gC;;AAEA,oD;AACA,mB;AACA,oC;AACA,gB;AACA,U;AACA,kB;AACA,G;;AAEA,+E;AACA,uB;AACA,uB;AACA,iB;AACA,oC;AACA,+B;AACA,O;AACA,G;;AAEA,sC;AACA,4C;;AAEA,sC;AACA,kD;AACA,wD;;AAEA,mD;AACA,K;;AAEA,yB;AACA,2B;AACA,iC;AACA,G;AACA,E;;;AAGA,qB;AACA,gC;AACA,iE;AACA,oF;AACA,E;;AAEA,2B;AACA,6B;AACA,6E;AACA,qC;AACA,E;;AAEA,qB;AACA,gC;AACA,iE;AACA,sC;AACA,E;;;;;AAKA,iB;AACA,+D;AACA,qE;AACA,oB;AACA,8D;AACA,wE;AACA,sC;AACA,E;;AAEA,sB;AACA,wE;AACA,4D;AACA,E;AACA,oG;AACA,kB;;AAEA,gC;AACA,8C;AACA,uD;AACA,O;AACA,W;AACA,G;;AAEA,yB;AACA,6C;AACA,gD;AACA,G;AACA,E;;AAEA,2B;AACA,6F;;AAEA,gC;AACA,uB;AACA,G;;AAEA,oD;AACA,E;;AAEA,iC;AACA,yG;;AAEA,gC;AACA,uB;AACA,G;;AAEA,mD;AACA,E;;AAEA,2B;AACA,6F;;AAEA,gC;AACA,uB;AACA,G;;AAEA,kD;AACA,E;;AAEA,mD;AACA,kC;AACA,mD","file":"/packages/u2622_persistent-session.js","sourcesContent":["// This file uses code direct from Meteor's reactive-dict package, mostly from\n// this file: https://github.com/meteor/meteor/blob/0ef65cc/packages/reactive-dict/reactive-dict.js\n//\n// helpers: https://github.com/meteor/meteor/blob/0ef65cc/packages/reactive-dict/reactive-dict.js#L1-L16\nvar stringify = function (value) {\n  if (value === undefined)\n    return 'undefined';\n  return EJSON.stringify(value);\n};\nvar parse = function (serialized) {\n  if (serialized === undefined || serialized === 'undefined')\n    return undefined;\n  return EJSON.parse(serialized);\n};\n\nvar changed = function (v) {\n  v && v.changed();\n};\n\n\nPersistentSession = function (dictName) {\n  if (_.isString(dictName)) {\n    this._dictName = dictName;\n\n    // when \"session\", use the existing dict\n    if (dictName == \"session\") {\n      this._dictName = \"\"   // we don't need a name for session\n      this._dict = oldSession; // we also want to use the global (incase something was set previously)\n\n    // not session? create a new dict\n    } else {\n      this._dict = new ReactiveDict(dictName);\n    }\n\n  } else {\n    throw new Error(\"dictName must be a string\");\n  }\n\n\n  /*\n   * Used to determine if we need to migrate how the data is stored.\n   * Each time the data format changes, increment this number.\n   */\n  var PSA_DATA_VERSION = 1;\n\n  // === INITIALIZE KEY TRACKING ===\n  this.psKeys     = {};\n  this.psKeyList  = [];\n  this.psaKeys    = {};\n  this.psaKeyList = [];\n\n  // initialize default method setting\n  this.default_method = 'temporary'; // valid options: 'temporary', 'persistent', 'authenticated'\n  if (Meteor.settings &&\n      Meteor.settings.public &&\n      Meteor.settings.public.persistent_session) {\n    this.default_method = Meteor.settings.public.persistent_session.default_method;\n  }\n\n\n  var self = this;\n\n  // === HOUSEKEEPING ===\n  /*\n   * Converts previously stored values into EJSON compatible formats.\n   */\n  function migrateToEJSON() {\n    if (amplify.store('__PSDATAVERSION__' + self._dictName) >= PSA_DATA_VERSION) {\n      return;\n    }\n\n    var psKeyList = amplify.store('__PSKEYS__' + self._dictName);\n    var psaKeyList = amplify.store('__PSAKEYS__' + self._dictName);\n\n    _.each([psKeyList, psaKeyList], function(list) {\n      _.each(list, function(key) {\n        amplify.store(key, EJSON.stringify(amplify.store(key)));\n      });\n    });\n\n    amplify.store('__PSDATAVERSION__' + self._dictName, PSA_DATA_VERSION);\n  };\n\n  if (Meteor.isClient) {\n\n    // --- on startup, load persistent data back into meteor session ---\n    Meteor.startup(function(){\n      var val;\n\n      migrateToEJSON();\n\n      // persistent data\n      var psList = amplify.store('__PSKEYS__' + self._dictName);\n      if ( typeof psList == \"object\" && psList.length!==undefined ) {\n        for (var i=0; i<psList.length; i++) {\n          if (!_.has(self._dict.keys, psList[i])) {\n            val = self.get(psList[i]);\n            self.set(psList[i], val, true, false);\n          }\n        }\n      }\n\n      // authenticated data\n      var psaList = amplify.store('__PSAKEYS__' + self._dictName);\n      if ( typeof psaList == \"object\" && psaList.length!==undefined ) {\n        for (var i=0; i<psaList.length; i++) {\n          if (!_.has(self._dict.keys, psaList[i])) {\n            val = self.get(psaList[i]);\n            self.setAuth(psaList[i], val, true, true);\n          }\n        }\n      }\n\n    });\n\n  };\n\n  Tracker.autorun(function () {\n    // lazy check for accounts-base\n    if (Meteor.userId) {\n      var userId = Meteor.userId()\n      if (userId) {\n        // user is logged in, leave session in tacted\n      } else {\n        // user is unset, clear authencated keys\n        self.clearAuth()\n      }\n    }\n  });\n\n  return this;\n};\n\n// === LOCAL STORAGE INTERACTION ===\nPersistentSession.prototype.store = function _psStore(type, key, value) {\n  // use dict name for uniqueness\n  this.psKeyList  = amplify.store('__PSKEYS__' + this._dictName) || [];\n  this.psaKeyList = amplify.store('__PSAKEYS__' + this._dictName)|| [];\n\n  if (type == 'get') {\n    return amplify.store(this._dictName + key);\n  } else {\n\n    this.psKeyList  = _.without(this.psKeyList, key);\n    this.psaKeyList = _.without(this.psaKeyList, key);\n    delete this.psKeys[key];\n    delete this.psaKeys[key];\n\n    if (value===undefined || value===null || type=='temporary') {\n      value = null;\n\n    } else if (type=='persistent') {\n      this.psKeys[key] = EJSON.toJSONValue(value);\n      this.psKeyList = _.union(this.psKeyList, [key]);\n\n    } else if (type=='authenticated') {\n      this.psaKeys[key] = EJSON.toJSONValue(value);\n      this.psaKeyList = _.union(this.psaKeyList, [key]);\n    }\n\n    amplify.store('__PSKEYS__', this.psKeyList);\n    amplify.store('__PSAKEYS__', this.psaKeyList);\n    amplify.store(this._dictName + key, EJSON.toJSONValue(value));\n  }\n};\n\n\n// === GET ===\n// keep for backwards compability, redirect to this._dict\nPersistentSession.prototype.old_get = function (/* arguments */){\n  return this._dict.get.apply(this._dict, arguments);\n};\nPersistentSession.prototype.get = function _psGet(key) {\n  var val = this.old_get(key);\n  var psVal;\n  var unparsedPsVal = this.store('get', key);\n  if (unparsedPsVal !== undefined) {\n    psVal = EJSON.fromJSONValue(this.store('get', key));\n  }\n\n  /*\n   * We can't do `return psVal || val;` here, as when psVal = undefined and\n   * val = 0, it will return undefined, even though 0 is the correct value.\n   */\n  if (psVal === undefined || psVal === null) {\n    return val;\n  }\n  return psVal;\n};\n\n\n// === SET ===\nPersistentSession.prototype.old_set = function (/* arguments */){\n  // defaults to a persistent, non-authenticated variable\n  return this._dict.set.apply(this._dict, arguments);\n};\nPersistentSession.prototype.set = function _psSet(keyOrObject, value, persist, auth) {\n\n  // Taken from https://github.com/meteor/meteor/blob/107d858/packages/reactive-dict/reactive-dict.js\n  if ((typeof keyOrObject === 'object') && (value === undefined)) {\n    this._setObject(keyOrObject, persist, auth);\n    return;\n  }\n\n  var key = keyOrObject;\n  var type = 'temporary';\n  if (persist || (persist===undefined && (this.default_method=='persistent' || this.default_method=='authenticated'))) {\n    if (auth || (persist===undefined && auth===undefined && this.default_method=='authenticated')) {\n      type = 'authenticated';\n    } else {\n      type = 'persistent';\n    }\n  }\n  this.store(type, key, value);\n  this.old_set(key, value);\n};\n\n\n// Taken from https://github.com/meteor/meteor/blob/0ef65cc/packages/reactive-dict/reactive-dict.js#L144-L151\n// Backwords compat:\nPersistentSession.prototype.all = function _psAll() {\n  if (this._dict.allDeps) {\n    this._dict.allDeps.depend();\n  }\n  var ret = {};\n  _.each(this._dict.keys, function(value, key) {\n    ret[key] = parse(value);\n  });\n  return ret;\n}\n\nPersistentSession.prototype._setObject = function _psSetObject(object, persist, auth) {\n  var self = this;\n\n  _.each(object, function (value, key){\n    self.set(key, value, persist, auth);\n  });\n};\n\nPersistentSession.prototype._ensureKey = function _psEnsureKey(key) {\n  var self = this._dict;\n  if (!(key in self.keyDeps)) {\n    self.keyDeps[key] = new Tracker.Dependency;\n    self.keyValueDeps[key] = {};\n  }\n}\n\n// === EQUALS ===\n// Taken from https://github.com/meteor/meteor/blob/0ef65cc/packages/reactive-dict/reactive-dict.js#L93-L137\nPersistentSession.prototype.equals = function _psEquals(key, value) {\n\n  // Mongo.ObjectID is in the 'mongo' package\n  var ObjectID = null;\n  if (Package.mongo) {\n    ObjectID = Package.mongo.Mongo.ObjectID;\n  }\n\n  // We don't allow objects (or arrays that might include objects) for\n  // .equals, because JSON.stringify doesn't canonicalize object key\n  // order. (We can make equals have the right return value by parsing the\n  // current value and using EJSON.equals, but we won't have a canonical\n  // element of keyValueDeps[key] to store the dependency.) You can still use\n  // \"EJSON.equals(reactiveDict.get(key), value)\".\n  //\n  // XXX we could allow arrays as long as we recursively check that there\n  // are no objects\n  if (typeof value !== 'string' &&\n      typeof value !== 'number' &&\n      typeof value !== 'boolean' &&\n      typeof value !== 'undefined' &&\n      !(value instanceof Date) &&\n      !(ObjectID && value instanceof ObjectID) &&\n      value !== null) {\n    throw new Error(\"ReactiveDict.equals: value must be scalar\");\n  }\n  var serializedValue = stringify(value);\n\n  if (Tracker.active) {\n    this._ensureKey(key);\n\n    if (! _.has(this._dict.keyValueDeps[key], serializedValue))\n      this._dict.keyValueDeps[key][serializedValue] = new Tracker.Dependency;\n\n    var isNew = this._dict.keyValueDeps[key][serializedValue].depend();\n    if (isNew) {\n      var that = this;\n      Tracker.onInvalidate(function () {\n        // clean up [key][serializedValue] if it's now empty, so we don't\n        // use O(n) memory for n = values seen ever\n        if (! that._dict.keyValueDeps[key][serializedValue].hasDependents())\n          delete that._dict.keyValueDeps[key][serializedValue];\n      });\n    }\n  }\n\n  var oldValue = this.get(key);\n\n  return EJSON.equals(oldValue, value);\n};\n\n// === SET TEMPORARY ===\n// alias to .set(); sets a non-persistent variable\nPersistentSession.prototype.setTemporary = function _psSetTemp(keyOrObject, value) {\n  this.set(keyOrObject, value, false, false);\n};\nPersistentSession.prototype.setTemp = function _psSetTemp(keyOrObject, value) {\n  this.set(keyOrObject, value, false, false);\n};\n\n// === SET PERSISTENT ===\n// alias to .set(); sets a persistent variable\nPersistentSession.prototype.setPersistent = function _psSetPersistent(keyOrObject, value) {\n  this.set(keyOrObject, value, true, false);\n};\n\n// === SET AUTHENTICATED ===\n// alias to .set(); sets a persistent variable that will be removed on logout\nPersistentSession.prototype.setAuth = function _psSetAuth(keyOrObject, value) {\n  this.set(keyOrObject, value, true, true);\n};\n\n\n// === MAKE TEMP / PERSISTENT / AUTH ===\n// change the type of session var\nPersistentSession.prototype.makeTemp = function _psMakeTemp(key) {\n  this.store('temporary', key);\n};\nPersistentSession.prototype.makePersistent = function _psMakePersistent(key) {\n  var val = this.get(key);\n  this.store('persistent', key, val);\n};\nPersistentSession.prototype.makeAuth = function _psMakeAuth(key) {\n  var val = this.get(key);\n  this.store('authenticated', key, val);\n};\n\n\n\n// === CLEAR ===\nPersistentSession.prototype.old_clear = function (/* arguments */){\n  return this._dict.clear.apply(this._dict, arguments);\n};\nPersistentSession.prototype.clear = function _psClear(key, list) {\n  var self = this;\n  var oldKeys = self._dict.keys;\n\n  if ((key === undefined) && (list === undefined)) {\n    list = oldKeys;\n  } else if (!(key === undefined)) {\n    list = [key]\n  } else {\n    // list = list\n  }\n\n  // okay, if it was an array of keys, find the old key pairings\n  if (_.isArray(list)){\n    var oldList = list;\n    var list = {}\n    _.each(oldList, function (key) {\n      list[key] = oldKeys[key];\n    });\n  }\n\n  _.each(list, function(value, akey) {\n    self.set(akey, undefined, false, false);\n  });\n};\n\n\n// more or less how it's implemented in reactive dict, but add support for removing single or arrays of keys\n// Derived from https://github.com/meteor/meteor/blob/0ef65cc/packages/reactive-dict/reactive-dict.js#L153-L167\nPersistentSession.prototype.clear = function _psClear(key, list) {\n  var self = this;\n  var oldKeys = self._dict.keys;\n\n  if ((key === undefined) && (list === undefined)) {\n    list = oldKeys;\n  } else if (!(key === undefined)) {\n    list = [key]\n  } else {\n    // list = list\n  }\n\n  // okay, if it was an array of keys, find the old key pairings for reactivity\n  if (_.isArray(list)){\n    var oldList = list;\n    var list = {}\n    _.each(oldList, function (key) {\n      list[key] = oldKeys[key];\n    });\n  }\n\n  _.each(list, function(value, akey) {\n    self.set(akey, undefined, false, false);\n\n    changed(self._dict.keyDeps[akey]);\n    changed(self._dict.keyValueDeps[akey][value]);\n    changed(self._dict.keyValueDeps[akey]['undefined']);\n\n    delete self._dict.keys[akey]; // remove the key\n  });\n\n  // reactive-dict 1.1.0+\n  if (self._dict.allDeps) {\n    self._dict.allDeps.changed();\n  }\n};\n\n\n// === CLEAR TEMP ===\n// clears all the temporary keys\nPersistentSession.prototype.clearTemp = function _psClearTemp() {\n  this.clear(undefined, _.keys(_.omit(this._dict.keys, this.psKeys, this.psaKeys)));\n};\n\n// === CLEAR PERSISTENT ===\n// clears all persistent keys\nPersistentSession.prototype.clearPersistent = function _psClearPersistent() {\n  this.clear(undefined, this.psKeys);\n};\n\n// === CLEAR AUTH ===\n// clears all authenticated keys\nPersistentSession.prototype.clearAuth = function _psClearAuth() {\n  this.clear(undefined, this.psaKeys);\n};\n\n\n\n\n// === UPDATE ===\n// updates the value of a session var without changing its type\nPersistentSession.prototype.update = function _psUpdate(key, value) {\n  var persist, auth;\n  if ( _.indexOf(this.psaKeyList, key) >= 0 ) { auth = true; }\n  if ( auth || _.indexOf(this.psKeyList, key) >= 0 ) { persist = true; }\n  this.set(key, value, persist, auth);\n};\n\n// === SET DEFAULT ===\nPersistentSession.prototype.old_setDefault = function (/* arguments */){\n  return this._dict.setDefault.apply(this._dict, arguments);\n};\nPersistentSession.prototype.setDefault = function _psSetDefault(keyOrObject, value, persist, auth) {\n  var self = this;\n\n  if (_.isObject(keyOrObject)) {\n    _.each(keyOrObject, function(value, key) {\n      self._dict.setDefault(key, value, persist, auth);\n    });\n    return;\n  }\n\n  // TODO: Handle objects\n  if ( this.get(keyOrObject) === undefined) {\n    this.set(keyOrObject, value, persist, auth);\n  }\n};\n\n// === SET DEFAULT TEMP ===\nPersistentSession.prototype.setDefaultTemp = function _psSetDefaultTemp(keyOrObject, value) {\n\n  if (_.isObject(keyOrObject)) {\n    value = undefined; \n  }\n\n  this.setDefault(keyOrObject, value, false, false);\n};\n\n// === SET DEFAULT PERSISTENT ===\nPersistentSession.prototype.setDefaultPersistent = function _psSetDefaultPersistent(keyOrObject, value) {\n\n  if (_.isObject(keyOrObject)) {\n    value = undefined; \n  }\n\n  this.setDefault(keyOrObject, value, true, false);\n};\n\n// === SET DEFAULT AUTH ===\nPersistentSession.prototype.setDefaultAuth = function _psSetDefaultAuth(keyOrObject, value) {\n\n  if (_.isObject(keyOrObject)) {\n    value = undefined; \n  }\n\n  this.setDefault(keyOrObject, value, true, true);\n};\n\n// automatically apply PersistentSession to Session\nvar oldSession = _.clone(Session);\n_.extend(Session, new PersistentSession(\"session\"))\n"]}