)]}'
{"version":3,"sources":["pascoual:pdfjs/build/pdf.js","pascoual:pdfjs/web/compatibility.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,gF;AACA,mE;AACA,oC;AACA,E;AACA,kE;AACA,mE;AACA,0C;AACA,E;AACA,iD;AACA,E;AACA,sE;AACA,oE;AACA,2E;AACA,sE;AACA,iC;AACA,G;AACA,+B;AACA,mB;;AAEA,wD;AACA,mC;AACA,6D;AACA,C;AACA,2B;AACA,W;AACA,a;;AAEA,0B;AACA,wB;;AAEA,0B;AACA,6D;AACA,e;;AAEA,gF;AACA,mE;AACA,oC;AACA,E;AACA,kE;AACA,mE;AACA,0C;AACA,E;AACA,iD;AACA,E;AACA,sE;AACA,oE;AACA,2E;AACA,sE;AACA,iC;AACA,G;AACA,wE;AACA,qB;;AAEA,a;;AAEA,kE;;AAEA,+C;;AAEA,sD;;AAEA,yB;AACA,U;AACA,Y;AACA,iB;AACA,e;AACA,sB;AACA,wB;AACA,6B;AACA,iB;AACA,sB;AACA,qB;AACA,E;;AAEA,iB;AACA,oB;AACA,e;AACA,e;AACA,E;;AAEA,sB;AACA,Y;AACA,U;AACA,S;AACA,E;;AAEA,kB;AACA,a;AACA,W;AACA,S;AACA,S;AACA,S;AACA,U;AACA,S;AACA,S;AACA,S;AACA,O;AACA,E;;AAEA,gB;AACA,a;AACA,W;AACA,Y;AACA,kB;AACA,mB;AACA,c;AACA,kB;AACA,W;AACA,c;AACA,W;AACA,a;AACA,E;;AAEA,0C;AACA,8D;AACA,2C;AACA,yB;AACA,yB;AACA,C;;AAEA,iC;;AAEA,0B;AACA,Y;AACA,c;AACA,U;AACA,E;;AAEA,oD;AACA,uB;AACA,gF;AACA,S;AACA,gB;AACA,kB;AACA,gB;AACA,iB;AACA,mB;AACA,a;AACA,wB;AACA,iB;AACA,e;AACA,W;AACA,c;AACA,gB;AACA,a;AACA,a;AACA,c;AACA,e;AACA,e;AACA,gB;AACA,gB;AACA,a;AACA,kB;AACA,W;AACA,a;AACA,iB;AACA,mB;AACA,sB;AACA,wB;AACA,c;AACA,W;AACA,a;AACA,gB;AACA,c;AACA,qB;AACA,qB;AACA,gB;AACA,iB;AACA,c;AACA,2B;AACA,kB;AACA,e;AACA,yB;AACA,oB;AACA,e;AACA,e;AACA,qB;AACA,uB;AACA,iC;AACA,mB;AACA,4B;AACA,0B;AACA,wB;AACA,qB;AACA,sB;AACA,mB;AACA,oB;AACA,oB;AACA,kB;AACA,wB;AACA,sB;AACA,yB;AACA,uB;AACA,kB;AACA,uB;AACA,qB;AACA,qB;AACA,mB;AACA,gB;AACA,qB;AACA,yB;AACA,8B;AACA,uB;AACA,kB;AACA,gB;AACA,4B;AACA,0B;AACA,iB;AACA,e;AACA,uB;AACA,qB;AACA,sB;AACA,oB;AACA,uB;AACA,4B;AACA,iC;AACA,wB;AACA,8B;AACA,mC;AACA,8B;AACA,kC;AACA,+B;AACA,mB;AACA,E;;AAEA,8E;AACA,4E;AACA,a;AACA,oB;AACA,wD;AACA,gC;AACA,G;AACA,C;;AAEA,sB;AACA,oB;AACA,2D;AACA,mC;AACA,G;AACA,C;;AAEA,yE;AACA,yB;AACA,qB;AACA,yD;AACA,iC;AACA,6B;AACA,G;AACA,0D;AACA,uB;AACA,C;;AAEA,sB;AACA,O;AACA,sB;AACA,e;AACA,kE;AACA,G;AACA,C;;AAEA,4B;AACA,c;AACA,e;AACA,G;AACA,C;;AAEA,yD;AACA,qB;AACA,iB;AACA,2B;AACA,iB;AACA,mC;AACA,c;AACA,E;;AAEA,mD;AACA,yC;AACA,qB;AACA,U;AACA,2B;AACA,yB;AACA,M;AACA,kC;AACA,sD;AACA,2D;AACA,gC;AACA,O;AACA,K;AACA,I;AACA,K;;AAEA,yE;AACA,2C;AACA,mC;AACA,a;AACA,mB;AACA,G;AACA,0C;AACA,e;AACA,G;AACA,Q;AACA,8B;AACA,oB;AACA,+B;AACA,gC;AACA,U;AACA,Y;AACA,sC;AACA,K;AACA,yC;AACA,U;AACA,oB;AACA,oC;AACA,iC;AACA,yC;AACA,6C;AACA,yC;AACA,4D;AACA,wD;AACA,G;AACA,C;;AAEA,2D;AACA,yC;AACA,a;AACA,iB;AACA,G;AACA,8D;AACA,wD;AACA,uD;AACA,kB;AACA,yB;AACA,G;AACA,uC;AACA,qB;AACA,gB;AACA,iB;AACA,e;AACA,kB;AACA,e;AACA,kB;AACA,Y;AACA,mB;AACA,G;AACA,C;AACA,8B;;AAEA,mC;AACA,kD;AACA,sD;AACA,wD;AACA,wD;AACA,e;AACA,C;AACA,sB;;AAEA,mD;AACA,mB;AACA,uB;AACA,E;;AAEA,8D;AACA,yC;AACA,oC;AACA,uB;AACA,qB;AACA,G;;AAEA,4C;AACA,oD;;AAEA,2B;AACA,K;AACA,4C;;AAEA,sE;AACA,gD;AACA,wC;AACA,uB;AACA,2B;AACA,G;;AAEA,gD;AACA,4D;;AAEA,+B;AACA,K;AACA,oD;;AAEA,kE;AACA,qC;AACA,sC;AACA,uB;AACA,G;;AAEA,8C;AACA,wD;;AAEA,6B;AACA,K;AACA,gD;;AAEA,kE;AACA,qC;AACA,sC;AACA,uB;AACA,G;;AAEA,8C;AACA,wD;;AAEA,6B;AACA,K;AACA,gD;;AAEA,iC;AACA,oD;AACA,qD;AACA,8C;AACA,uB;AACA,yB;AACA,G;;AAEA,sD;AACA,wE;;AAEA,qC;AACA,K;AACA,gE;;AAEA,0E;AACA,yC;AACA,uB;AACA,G;;AAEA,kD;AACA,qE;AACA,gE;;AAEA,iC;AACA,K;;AAEA,oE;AACA,6C;AACA,uB;AACA,mB;AACA,+D;AACA,G;;AAEA,+C;AACA,+D;AACA,0D;;AAEA,8B;AACA,K;;AAEA,gE;AACA,oC;AACA,uB;AACA,G;;AAEA,6C;AACA,2D;AACA,sD;;AAEA,4B;AACA,K;;;AAGA,+B;AACA,uD;AACA,2E;AACA,4B;AACA,gC;AACA,oC;AACA,kD;AACA,G;AACA,kB;AACA,wD;AACA,4D;AACA,4C;AACA,wD;AACA,G;AACA,yB;AACA,C;;AAEA,6B;AACA,wE;AACA,0B;AACA,qC;AACA,oC;AACA,wC;AACA,G;AACA,e;AACA,C;;AAEA,0B;AACA,wE;AACA,gE;AACA,C;;AAEA,kB;AACA,mB;AACA,iB;AACA,Y;AACA,Q;AACA,G;AACA,W;AACA,C;;AAEA,gC;AACA,mC;AACA,C;;AAEA,mC;AACA,gD;AACA,C;;AAEA,mC;AACA,2D;AACA,2D;AACA,C;;AAEA,2C;AACA,sD;AACA,2B;AACA,kC;AACA,iB;AACA,iD;AACA,6B;AACA,C;;AAEA,gD;AACA,qB;AACA,wC;AACA,6D;AACA,G;AACA,G;;AAEA,yD;AACA,iC;AACA,gD;AACA,mC;AACA,oC;AACA,4C;AACA,wD;AACA,C;;AAEA,sD;AACA,qB;AACA,8C;AACA,yE;AACA,G;AACA,G;;AAEA,0D;;AAEA,4C;AACA,yB;AACA,oC;AACA,yE;AACA,4C;AACA,G;AACA,kD;;AAEA,iC;AACA,yC;AACA,Y;AACA,wB;AACA,sD;AACA,4D;AACA,yE;AACA,Q;AACA,6B;AACA,sD;AACA,qC;AACA,gD;AACA,iD;AACA,kD;AACA,O;AACA,M;AACA,G;;AAEA,+C;AACA,6C;AACA,sD;AACA,+B;AACA,uD;AACA,+B;AACA,K;AACA,G;;AAEA,yB;AACA,K;;AAEA,yC;;AAEA,iD;AACA,oB;;AAEA,gD;;AAEA,yE;AACA,wC;AACA,uD;AACA,kB;AACA,kB;AACA,kB;AACA,2B;AACA,I;;AAEA,8E;AACA,oD;AACA,Y;AACA,oC;AACA,oC;AACA,oC;AACA,oC;AACA,4C;AACA,2C;AACA,M;AACA,I;;AAEA,6B;AACA,4D;AACA,8C;AACA,8C;AACA,oB;AACA,I;;AAEA,0E;AACA,sC;AACA,yE;AACA,0E;AACA,oB;AACA,I;;AAEA,yE;AACA,0B;AACA,mC;AACA,oD;;AAEA,uC;AACA,mD;AACA,kD;AACA,kD;AACA,Y;AACA,2C;AACA,2C;AACA,2C;AACA,0C;AACA,M;AACA,I;;AAEA,6D;AACA,sC;AACA,qD;AACA,wE;AACA,I;;AAEA,iD;AACA,wB;AACA,wB;AACA,wB;AACA,0D;AACA,sB;AACA,gE;AACA,Y;AACA,8C;AACA,8C;AACA,6C;AACA,M;AACA,I;;AAEA,wD;AACA,8E;AACA,0D;AACA,sC;AACA,oD;;AAEA,6C;;AAEA,4C;AACA,sD;AACA,sD;AACA,sD;AACA,sD;;AAEA,uD;AACA,4B;AACA,wE;AACA,iC;AACA,iC;;AAEA,4D;AACA,0C;AACA,I;;AAEA,wE;AACA,sE;AACA,4E;AACA,2C;AACA,0D;AACA,wC;AACA,4B;AACA,qB;AACA,qB;AACA,K;AACA,4B;AACA,qB;AACA,qB;AACA,K;AACA,a;AACA,I;;AAEA,8D;AACA,yE;AACA,yE;AACA,0D;AACA,4B;AACA,mB;AACA,K;;AAEA,kC;AACA,0E;AACA,0E;AACA,oB;;AAEA,sC;AACA,sC;;AAEA,iE;AACA,iE;AACA,iE;AACA,6D;AACA,8B;AACA,8B;AACA,Y;AACA,mB;AACA,K;;AAEA,iE;AACA,iE;AACA,iE;AACA,6D;AACA,8B;AACA,8B;AACA,Y;AACA,mB;AACA,K;;AAEA,kB;AACA,I;;AAEA,uC;AACA,4B;AACA,I;;AAEA,gE;AACA,2C;AACA,I;;AAEA,kE;AACA,8C;AACA,I;;AAEA,mD;AACA,2B;AACA,4B;AACA,K;AACA,I;;AAEA,0E;AACA,4E;AACA,qC;AACA,gC;AACA,K;AACA,gB;AACA,kB;AACA,K;AACA,0B;AACA,I;;AAEA,8D;AACA,kD;AACA,oC;AACA,iC;AACA,4C;AACA,K;AACA,I;;AAEA,6D;AACA,kD;AACA,uB;AACA,oC;AACA,mB;AACA,kC;AACA,sB;AACA,qB;AACA,S;AACA,sB;AACA,Q;AACA,K;AACA,iE;AACA,I;;AAEA,c;AACA,K;;AAEA,G;AACA,iE;AACA,S;AACA,4B;AACA,G;AACA,yE;AACA,K;AACA,iB;AACA,a;AACA,kE;AACA,iD;AACA,mE;AACA,qC;AACA,qC;AACA,mE;AACA,K;AACA,+E;AACA,2B;AACA,uB;AACA,6B;AACA,2B;AACA,2B;;AAEA,wE;AACA,mE;AACA,gD;AACA,gD;AACA,2C;AACA,8B;AACA,wD;AACA,uB;AACA,e;AACA,4D;AACA,c;AACA,c;AACA,2D;AACA,c;AACA,e;AACA,6D;AACA,c;AACA,e;AACA,c;AACA,4D;AACA,c;AACA,K;;AAEA,mB;AACA,6C;AACA,K;;AAEA,qC;AACA,sB;AACA,wB;AACA,uE;AACA,uE;AACA,wD;AACA,yD;AACA,Y;AACA,uE;AACA,uE;AACA,wD;AACA,yD;AACA,K;AACA,uD;AACA,iE;AACA,yD;AACA,sB;AACA,sB;AACA,sB;AACA,sB;AACA,sB;AACA,4E;AACA,2E;AACA,M;;AAEA,uB;AACA,yB;AACA,2B;AACA,G;AACA,uE;AACA,O;AACA,kD;AACA,+E;AACA,wE;AACA,2B;AACA,qD;AACA,O;AACA,8C;AACA,wB;AACA,4D;AACA,wE;AACA,oE;AACA,yE;AACA,M;AACA,O;AACA,+E;AACA,6D;AACA,sC;AACA,sC;AACA,2E;AACA,8C;AACA,qC;AACA,8C;AACA,O;AACA,gF;AACA,yD;AACA,M;AACA,O;AACA,0D;AACA,iE;AACA,2E;AACA,wC;AACA,0C;AACA,O;AACA,+B;AACA,8D;AACA,uE;AACA,uE;AACA,0C;AACA,M;AACA,O;AACA,8E;AACA,yD;AACA,sC;AACA,sC;AACA,2E;AACA,yC;AACA,0C;AACA,O;AACA,sE;AACA,gE;AACA,K;AACA,I;AACA,sB;AACA,K;;AAEA,+B;AACA,yE;AACA,8E;AACA,+E;AACA,+E;AACA,+E;AACA,0E;AACA,wE;AACA,8E;AACA,4D;AACA,E;;AAEA,iC;AACA,qC;AACA,+C;AACA,kB;AACA,gC;AACA,sC;AACA,2D;AACA,K;AACA,U;AACA,6B;AACA,4D;AACA,oE;AACA,K;AACA,G;AACA,yB;AACA,C;;AAEA,kC;AACA,yC;AACA,C;;AAEA,0B;AACA,wB;AACA,iB;AACA,G;AACA,c;AACA,C;;AAEA,oB;AACA,gC;AACA,C;;AAEA,mB;AACA,kD;AACA,C;;AAEA,mB;AACA,+B;AACA,C;;AAEA,sB;AACA,+B;AACA,C;;AAEA,oB;AACA,2B;AACA,C;;AAEA,wB;AACA,kE;AACA,C;;AAEA,0B;AACA,6B;AACA,iB;AACA,G;AACA,c;AACA,gB;AACA,G;AACA,+B;AACA,oD;AACA,C;;AAEA,qB;AACA,4B;AACA,C;;AAEA,sB;AACA,yE;AACA,C;;AAEA,2B;AACA,2E;AACA,C;;AAEA,mB;AACA,0B;AACA,C;;AAEA,G;AACA,6B;AACA,E;AACA,sC;AACA,kD;AACA,wD;AACA,qD;AACA,G;;AAEA,G;AACA,uC;AACA,uC;AACA,E;AACA,4D;AACA,2C;AACA,G;AACA,oC;AACA,sB;AACA,+D;AACA,iC;AACA,+B;AACA,K;AACA,oB;AACA,C;;AAEA,wD;;AAEA,G;AACA,yB;AACA,wE;AACA,6E;AACA,kE;AACA,0E;AACA,E;AACA,4B;AACA,sD;AACA,G;AACA,4B;AACA,4B;AACA,4E;AACA,wD;AACA,qD;AACA,qD;AACA,4E;AACA,6B;AACA,2B;AACA,W;AACA,0C;AACA,kB;AACA,oC;AACA,gC;AACA,oB;AACA,8B;AACA,+B;AACA,a;AACA,qB;AACA,W;AACA,0B;AACA,2B;AACA,S;AACA,uB;AACA,Q;AACA,K;AACA,4D;AACA,sD;AACA,+E;AACA,Q;AACA,K;AACA,2D;AACA,sD;AACA,mE;AACA,yB;AACA,W;AACA,Q;AACA,K;AACA,oE;AACA,iE;AACA,uE;AACA,Q;AACA,K;AACA,W;AACA,G;AACA,yB;AACA,0B;AACA,0B;;AAEA,uE;AACA,sE;AACA,qB;AACA,8B;;AAEA,wB;AACA,iB;AACA,mB;AACA,4B;AACA,iC;;AAEA,0D;AACA,+C;AACA,e;AACA,O;;AAEA,8D;AACA,6B;;AAEA,yB;AACA,e;AACA,O;AACA,0B;;AAEA,iD;AACA,M;;AAEA,yC;AACA,gC;AACA,+C;AACA,wC;AACA,4C;;AAEA,qD;AACA,mD;;AAEA,a;AACA,+C;AACA,0D;AACA,uD;AACA,a;AACA,8D;AACA,sD;AACA,2C;;AAEA,4D;AACA,oE;AACA,e;AACA,W;AACA,sB;AACA,uC;AACA,yB;AACA,S;;AAEA,iE;AACA,sC;AACA,gB;AACA,S;AACA,O;;AAEA,qC;AACA,mD;AACA,e;AACA,O;;AAEA,2B;AACA,M;;AAEA,oE;AACA,qC;AACA,yB;AACA,wB;AACA,S;AACA,oC;AACA,M;;AAEA,4E;AACA,0C;AACA,iE;AACA,8D;AACA,6C;AACA,c;AACA,S;AACA,O;AACA,M;;AAEA,+D;AACA,uC;AACA,e;AACA,O;AACA,wC;AACA,4C;AACA,2C;AACA,6B;AACA,mE;AACA,2E;AACA,uE;AACA,0D;AACA,kC;AACA,4C;AACA,a;AACA,sB;AACA,+C;AACA,gB;AACA,W;AACA,S;AACA,8C;AACA,wC;AACA,S;AACA,uC;AACA,K;AACA,I;;AAEA,8B;AACA,kC;AACA,wB;AACA,S;AACA,6E;AACA,iB;AACA,sB;AACA,K;AACA,G;AACA,K;AACA,0E;AACA,c;AACA,8D;AACA,6C;AACA,K;AACA,gD;AACA,8B;AACA,2D;AACA,2B;AACA,yB;AACA,O;AACA,qC;AACA,qB;AACA,2B;AACA,0B;AACA,sB;AACA,K;AACA,6B;AACA,iD;AACA,e;AACA,O;AACA,mB;AACA,wB;AACA,K;AACA,wD;AACA,gC;AACA,kC;AACA,gC;AACA,qD;AACA,mB;AACA,W;AACA,6B;AACA,uB;AACA,iC;AACA,gC;AACA,W;AACA,U;AACA,Y;AACA,uC;AACA,sC;AACA,c;AACA,yB;AACA,O;AACA,K;AACA,oB;AACA,I;;AAEA,K;AACA,qE;AACA,gD;AACA,K;AACA,yD;AACA,qD;AACA,I;;AAEA,K;AACA,6B;AACA,+B;AACA,uB;AACA,K;AACA,qD;AACA,+D;AACA,I;;AAEA,K;AACA,6B;AACA,kC;AACA,uB;AACA,K;AACA,oD;AACA,uE;AACA,I;;AAEA,uB;AACA,kB;AACA,iB;AACA,oB;AACA,8B;;AAEA,kE;AACA,6C;AACA,6C;AACA,e;AACA,O;;AAEA,uC;AACA,qC;AACA,kE;AACA,mE;AACA,e;AACA,O;;AAEA,4B;AACA,0B;;AAEA,sE;AACA,wC;AACA,mD;AACA,O;;AAEA,4C;AACA,M;;AAEA,+C;AACA,iD;AACA,M;;AAEA,8C;AACA,kD;AACA,M;;AAEA,sD;AACA,gE;AACA,+B;AACA,6B;AACA,S;AACA,2B;AACA,0B;AACA,6B;AACA,2B;AACA,gC;AACA,S;AACA,4C;AACA,yB;AACA,M;;AAEA,6C;AACA,4C;AACA,K;AACA,I;;AAEA,gC;AACA,K;;AAEA,8C;AACA,mC;AACA,iC;AACA,iB;AACA,K;AACA,e;AACA,G;AACA,wB;AACA,sB;AACA,oB;AACA,wB;AACA,G;AACA,yB;AACA,yC;AACA,0B;AACA,e;AACA,O;AACA,iC;AACA,qD;AACA,O;AACA,sC;AACA,M;AACA,+C;AACA,0B;AACA,e;AACA,O;AACA,oC;AACA,uD;AACA,O;AACA,uB;AACA,qB;AACA,oC;AACA,yB;AACA,S;AACA,6D;AACA,gC;AACA,M;AACA,6C;AACA,gB;AACA,6B;AACA,mB;AACA,oD;AACA,sB;AACA,mD;AACA,oC;AACA,oC;AACA,gC;AACA,S;AACA,O;AACA,mD;AACA,4B;AACA,6C;AACA,0E;AACA,O;AACA,iB;AACA,K;AACA,I;AACA,mB;AACA,K;;AAEA,2D;AACA,oC;AACA,mD;AACA,G;AACA,4D;AACA,gC;AACA,kB;AACA,iC;AACA,E;;AAEA,4D;AACA,wE;AACA,c;AACA,wE;;AAEA,sD;AACA,wC;AACA,4D;AACA,qD;AACA,uC;AACA,K;;AAEA,oD;AACA,uD;AACA,8B;AACA,kC;AACA,kC;AACA,yD;AACA,+D;AACA,6C;AACA,kE;AACA,K;AACA,kB;AACA,I;AACA,K;;AAEA,uC;AACA,mB;AACA,uB;AACA,yB;AACA,mC;AACA,8D;AACA,mC;;AAEA,oD;AACA,qC;AACA,K;AACA,wD;AACA,uC;AACA,K;AACA,sE;AACA,oC;AACA,K;;AAEA,oE;AACA,0B;AACA,uB;AACA,uC;AACA,qD;AACA,yD;AACA,iD;AACA,8B;AACA,sC;AACA,gB;AACA,sC;AACA,S;AACA,c;AACA,uD;AACA,O;AACA,mC;AACA,mC;AACA,4B;AACA,4C;AACA,sD;AACA,mC;AACA,8B;AACA,0B;AACA,wC;AACA,wB;AACA,a;AACA,8B;AACA,8B;AACA,0B;AACA,wC;AACA,yB;AACA,a;AACA,W;AACA,c;AACA,6C;AACA,O;AACA,Y;AACA,0D;AACA,K;AACA,I;AACA,C;;AAEA,4B;AACA,6D;AACA,gC;AACA,yB;AACA,0E;AACA,K;AACA,sC;AACA,I;AACA,K;AACA,+E;AACA,+C;AACA,0C;AACA,uE;AACA,K;AACA,kE;AACA,mB;AACA,yB;AACA,gB;AACA,M;AACA,yC;AACA,I;AACA,K;AACA,+E;AACA,6D;AACA,+C;AACA,0C;AACA,wE;AACA,kE;AACA,K;AACA,kB;AACA,yE;AACA,0C;AACA,mB;AACA,yB;AACA,iB;AACA,4B;AACA,M;AACA,+C;AACA,wD;AACA,S;AACA,2C;AACA,iB;AACA,2B;AACA,K;AACA,8B;AACA,I;AACA,K;AACA,qC;AACA,a;AACA,yC;AACA,mE;AACA,K;AACA,8C;AACA,iD;AACA,kD;AACA,Y;AACA,uC;AACA,K;AACA,G;AACA,E;;AAEA,6C;AACA,wB;AACA,yD;AACA,0B;AACA,K;AACA,2D;AACA,2B;AACA,4C;AACA,K;AACA,qB;AACA,C;;;AAGA,G;AACA,6E;AACA,2D;AACA,gB;AACA,G;AACA,wD;AACA,+C;;AAEA,G;AACA,4E;AACA,S;AACA,gB;AACA,G;AACA,qE;;AAEA,G;AACA,wC;AACA,iB;AACA,G;AACA,6E;;AAEA,G;AACA,4E;AACA,+E;AACA,2D;AACA,iB;AACA,G;AACA,8D;AACA,wD;;AAEA,G;AACA,0E;AACA,S;AACA,gB;AACA,G;AACA,oE;AACA,2D;;AAEA,G;AACA,+E;AACA,+E;AACA,c;AACA,iB;AACA,G;AACA,0D;AACA,oD;;AAEA,G;AACA,+E;AACA,+E;AACA,mD;AACA,gB;AACA,G;AACA,2E;;AAEA,G;AACA,6E;AACA,4E;AACA,8B;AACA,iB;AACA,G;AACA,wD;AACA,kD;;AAEA,G;AACA,6E;AACA,oD;AACA,iB;AACA,G;AACA,0D;AACA,oD;;AAEA,G;AACA,gF;AACA,gF;AACA,2D;AACA,E;AACA,8D;AACA,kE;AACA,iB;AACA,G;AACA,gE;AACA,0D;;AAEA,G;AACA,8C;AACA,iB;AACA,G;AACA,mE;;AAEA,G;AACA,0D;AACA,iB;AACA,G;AACA,wE;AACA,iE;;AAEA,G;AACA,sC;AACA,iB;AACA,G;AACA,4E;AACA,sE;;AAEA,G;AACA,wB;AACA,iB;AACA,G;AACA,wD;AACA,iD;;AAEA,G;AACA,mE;AACA,gD;AACA,iB;AACA,G;AACA,kE;AACA,4D;;AAEA,G;AACA,4B;AACA,iB;AACA,G;AACA,4D;AACA,sD;;AAEA,G;AACA,8B;AACA,4D;AACA,W;AACA,uB;AACA,U;AACA,gB;AACA,G;AACA,kD;AACA,sE;;AAEA,G;AACA,yE;AACA,yD;AACA,gB;AACA,G;AACA,8D;AACA,2D;;AAEA,G;AACA,8E;AACA,uC;AACA,iB;AACA,G;AACA,sC;AACA,oD;AACA,gD;;AAEA,G;AACA,uD;AACA,E;AACA,2C;AACA,qD;AACA,+E;AACA,6E;AACA,uD;AACA,qE;AACA,+E;AACA,6E;AACA,oD;AACA,4E;AACA,+E;AACA,0E;AACA,gD;AACA,8E;AACA,2C;AACA,0C;AACA,G;;AAEA,G;AACA,qC;AACA,6E;AACA,oE;AACA,+E;AACA,2D;AACA,G;;AAEA,G;AACA,0E;AACA,8E;AACA,8E;AACA,8C;AACA,E;AACA,8E;AACA,qE;AACA,mD;AACA,E;AACA,+E;AACA,oE;AACA,E;AACA,0E;AACA,2E;AACA,4E;AACA,6B;AACA,E;AACA,2E;AACA,4E;AACA,yE;AACA,sC;AACA,E;AACA,mC;AACA,G;AACA,6C;AACA,+D;AACA,0D;AACA,4D;AACA,0C;;AAEA,wE;AACA,8B;AACA,oE;AACA,gF;AACA,mE;AACA,gD;AACA,0D;AACA,K;AACA,6B;AACA,sC;AACA,G;AACA,6C;AACA,6C;;AAEA,6C;AACA,a;AACA,gC;AACA,0B;AACA,kC;AACA,2B;AACA,oD;AACA,4B;AACA,U;AACA,kC;AACA,0E;AACA,wC;AACA,K;AACA,8C;AACA,2E;AACA,K;;AAEA,iB;AACA,G;;AAEA,kB;AACA,2B;AACA,yD;AACA,sD;AACA,kE;AACA,e;AACA,iC;AACA,e;AACA,wE;AACA,4D;AACA,iC;AACA,yC;AACA,8C;AACA,qE;AACA,2C;AACA,+C;AACA,c;AACA,yE;AACA,qE;AACA,O;AACA,e;AACA,K;AACA,8B;AACA,G;;AAEA,0D;AACA,6E;AACA,4E;AACA,0C;AACA,K;;AAEA,c;AACA,E;;AAEA,G;AACA,kC;AACA,S;AACA,G;AACA,wE;AACA,2C;AACA,qC;AACA,iD;;AAEA,O;AACA,2E;AACA,6E;AACA,8D;AACA,O;AACA,2B;;AAEA,O;AACA,0E;AACA,yE;AACA,2E;AACA,O;AACA,2B;AACA,G;;AAEA,oC;AACA,sD;AACA,O;AACA,wB;AACA,O;AACA,mB;AACA,sC;AACA,M;;AAEA,sC;;AAEA,O;AACA,uE;AACA,M;AACA,6E;AACA,yE;AACA,4E;AACA,6C;AACA,O;AACA,yE;AACA,8D;AACA,K;AACA,I;;AAEA,gC;AACA,K;;AAEA,G;AACA,yD;AACA,S;AACA,G;AACA,sE;AACA,K;AACA,sC;AACA,2B;AACA,oC;AACA,K;AACA,uD;AACA,yB;AACA,mC;;AAEA,8B;AACA,iC;AACA,wC;AACA,sD;AACA,G;AACA,mC;AACA,qD;AACA,qB;AACA,mE;AACA,0C;AACA,M;;AAEA,wB;AACA,sE;AACA,6C;AACA,M;;AAEA,+B;AACA,6E;AACA,oD;AACA,M;;AAEA,2E;AACA,2C;AACA,yD;AACA,mC;AACA,O;AACA,M;;AAEA,2E;AACA,sD;AACA,gD;AACA,2D;AACA,+B;AACA,S;AACA,oB;AACA,M;;AAEA,0B;AACA,8D;AACA,sD;AACA,uD;AACA,2D;AACA,8B;AACA,S;AACA,oB;AACA,M;;AAEA,qE;AACA,sC;AACA,M;;AAEA,qB;AACA,qE;AACA,gF;AACA,K;AACA,I;AACA,+B;AACA,K;;AAEA,oD;;AAEA,G;AACA,4E;AACA,6C;AACA,S;AACA,G;AACA,4D;AACA,iD;AACA,2B;AACA,+B;AACA,G;AACA,yE;AACA,O;AACA,+D;AACA,O;AACA,oB;AACA,mC;AACA,M;AACA,O;AACA,2E;AACA,c;AACA,O;AACA,uB;AACA,sC;AACA,M;AACA,O;AACA,8E;AACA,+E;AACA,c;AACA,O;AACA,4D;AACA,gD;AACA,M;AACA,O;AACA,4E;AACA,wC;AACA,+E;AACA,qC;AACA,O;AACA,+D;AACA,8C;AACA,M;AACA,O;AACA,2E;AACA,uD;AACA,M;AACA,uE;AACA,O;AACA,kE;AACA,8C;AACA,M;AACA,O;AACA,uD;AACA,wE;AACA,sC;AACA,O;AACA,kE;AACA,+C;AACA,M;AACA,O;AACA,2E;AACA,kD;AACA,O;AACA,gE;AACA,6C;AACA,M;AACA,O;AACA,4E;AACA,2C;AACA,O;AACA,8D;AACA,4C;AACA,M;AACA,O;AACA,6E;AACA,6E;AACA,Q;AACA,S;AACA,uB;AACA,uB;AACA,yB;AACA,0B;AACA,wB;AACA,6C;AACA,U;AACA,W;AACA,S;AACA,O;AACA,wD;AACA,yC;AACA,M;AACA,O;AACA,6E;AACA,8E;AACA,0E;AACA,+E;AACA,O;AACA,0D;AACA,0C;AACA,M;AACA,O;AACA,8E;AACA,iC;AACA,O;AACA,kD;AACA,sC;AACA,M;AACA,O;AACA,4E;AACA,0E;AACA,6D;AACA,O;AACA,kE;AACA,2D;AACA,M;AACA,O;AACA,4E;AACA,0D;AACA,O;AACA,oD;AACA,uC;AACA,M;AACA,O;AACA,8E;AACA,O;AACA,kD;AACA,oC;AACA,M;AACA,O;AACA,gE;AACA,O;AACA,kD;AACA,+B;AACA,K;AACA,I;AACA,0B;AACA,K;;AAEA,G;AACA,qB;AACA,E;AACA,gC;AACA,sD;AACA,0E;AACA,2B;AACA,G;;AAEA,G;AACA,0B;AACA,E;AACA,6B;AACA,yC;AACA,kE;AACA,uD;AACA,oD;AACA,sD;AACA,6E;AACA,G;;AAEA,G;AACA,c;AACA,E;AACA,8B;AACA,2C;AACA,6C;AACA,2D;AACA,uD;AACA,G;;AAEA,G;AACA,0B;AACA,E;AACA,qC;AACA,0E;AACA,2E;AACA,wE;AACA,4E;AACA,mD;AACA,6E;AACA,0D;AACA,+E;AACA,8E;AACA,8E;AACA,wC;AACA,G;;AAEA,G;AACA,0B;AACA,E;AACA,oC;AACA,uE;AACA,sE;AACA,2C;AACA,G;;AAEA,G;AACA,2C;AACA,S;AACA,G;AACA,oD;AACA,yD;AACA,+B;AACA,6B;AACA,+B;AACA,iC;AACA,yD;AACA,2C;AACA,iC;AACA,oC;AACA,gC;AACA,2B;AACA,G;AACA,iE;AACA,O;AACA,iE;AACA,O;AACA,sB;AACA,gC;AACA,M;AACA,O;AACA,4E;AACA,O;AACA,kB;AACA,kC;AACA,M;AACA,O;AACA,gF;AACA,wB;AACA,O;AACA,e;AACA,+B;AACA,M;AACA,O;AACA,6E;AACA,2C;AACA,O;AACA,gB;AACA,gC;AACA,M;AACA,O;AACA,+D;AACA,6E;AACA,qC;AACA,4E;AACA,oD;AACA,O;AACA,mE;AACA,iC;AACA,6B;AACA,O;AACA,oE;AACA,M;AACA,O;AACA,0E;AACA,0B;AACA,O;AACA,4D;AACA,oC;AACA,uC;AACA,O;;AAEA,kE;AACA,wC;AACA,qB;AACA,M;AACA,O;AACA,qE;AACA,+D;AACA,sE;AACA,yE;AACA,O;AACA,kD;AACA,6B;AACA,4B;;AAEA,8E;AACA,6B;AACA,kC;;AAEA,8E;;AAEA,gD;AACA,gD;AACA,O;AACA,2D;;AAEA,wE;AACA,6E;AACA,gD;AACA,iD;AACA,uE;AACA,oC;AACA,sB;AACA,wB;AACA,0B;AACA,U;;AAEA,wC;AACA,iE;AACA,yC;AACA,iC;AACA,W;AACA,O;;AAEA,uE;AACA,gE;AACA,sE;AACA,+E;AACA,uE;AACA,qC;AACA,qC;AACA,O;AACA,uD;AACA,+C;;AAEA,mC;AACA,oC;AACA,wD;AACA,O;;AAEA,sB;AACA,sD;AACA,wD;AACA,oC;AACA,uB;AACA,mB;AACA,W;AACA,kC;AACA,6D;AACA,mD;AACA,U;AACA,sD;AACA,2B;AACA,S;AACA,Q;;AAEA,gC;AACA,oE;AACA,qB;AACA,+C;AACA,S;;AAEA,sC;AACA,qC;AACA,S;AACA,2B;;AAEA,oB;AACA,sD;AACA,gB;AACA,kD;AACA,S;AACA,mC;AACA,iC;AACA,O;;AAEA,wB;AACA,M;;AAEA,O;AACA,2E;AACA,mD;AACA,O;AACA,8D;AACA,sC;AACA,iD;AACA,6E;AACA,S;AACA,O;;AAEA,qC;AACA,gD;AACA,gD;AACA,O;AACA,2D;;AAEA,8C;AACA,4B;AACA,6D;AACA,iD;AACA,qE;AACA,qC;AACA,iD;AACA,oC;AACA,sB;AACA,wB;AACA,0B;AACA,U;;AAEA,iE;AACA,oC;AACA,iC;AACA,W;AACA,O;AACA,sD;AACA,M;;AAEA,O;AACA,+D;AACA,mD;AACA,O;AACA,4D;AACA,8E;AACA,sC;AACA,S;AACA,M;AACA,O;AACA,gD;AACA,O;AACA,8C;AACA,iC;AACA,yB;AACA,M;AACA,O;AACA,6E;AACA,6B;AACA,c;AACA,O;AACA,mD;AACA,iC;AACA,gE;AACA,wD;AACA,2D;AACA,uD;AACA,qB;AACA,e;AACA,O;;AAEA,+D;AACA,yC;AACA,e;AACA,wB;AACA,qC;AACA,kC;AACA,M;AACA,O;AACA,6B;AACA,c;AACA,O;AACA,yE;AACA,qE;AACA,kD;AACA,8D;AACA,gC;AACA,+C;AACA,iE;AACA,O;AACA,M;AACA,O;AACA,6B;AACA,c;AACA,O;AACA,8E;AACA,qE;AACA,kD;AACA,gB;AACA,wD;AACA,+D;AACA,4E;AACA,gD;AACA,0C;AACA,O;AACA,uE;;AAEA,gF;AACA,4D;AACA,yD;AACA,O;;AAEA,wC;AACA,kD;AACA,2B;AACA,O;AACA,K;AACA,I;AACA,sB;AACA,K;;AAEA,G;AACA,yB;AACA,U;AACA,G;AACA,0D;AACA,gF;AACA,uD;AACA,mE;AACA,uC;;AAEA,4B;;AAEA,wB;AACA,2B;AACA,4D;;AAEA,2E;AACA,4E;AACA,+D;AACA,+E;AACA,sE;AACA,4E;AACA,sC;AACA,uB;AACA,8C;AACA,O;;AAEA,W;AACA,uE;AACA,8D;AACA,2C;AACA,gE;AACA,6C;;AAEA,gE;AACA,iE;AACA,kC;AACA,iC;AACA,yC;AACA,iD;AACA,a;AACA,qD;AACA,kD;AACA,kB;AACA,mC;AACA,W;AACA,sB;;AAEA,6E;AACA,2E;AACA,+D;AACA,a;AACA,iE;AACA,sB;AACA,mD;AACA,yB;AACA,+C;AACA,S;AACA,e;AACA,mB;AACA,8C;AACA,O;AACA,K;AACA,8E;AACA,2C;AACA,2B;AACA,G;AACA,+B;AACA,iD;AACA,0B;AACA,6B;AACA,sB;AACA,+E;AACA,2B;AACA,0B;AACA,kC;AACA,S;AACA,S;AACA,M;;AAEA,iE;AACA,6C;;AAEA,mD;AACA,0E;AACA,gF;AACA,uE;AACA,wC;AACA,qD;AACA,0D;AACA,W;AACA,O;AACA,sE;AACA,wC;AACA,8E;AACA,0B;AACA,kE;AACA,8C;AACA,Y;AACA,4D;AACA,U;;AAEA,oE;AACA,iD;;AAEA,gF;AACA,4C;AACA,yD;;AAEA,mD;AACA,oB;AACA,M;;AAEA,wB;AACA,oE;AACA,2C;;AAEA,yC;AACA,wD;AACA,O;;AAEA,6D;AACA,kC;AACA,uE;AACA,8C;AACA,yB;AACA,wB;AACA,a;AACA,W;;AAEA,oE;AACA,iD;AACA,0B;AACA,a;AACA,W;;AAEA,0E;AACA,8C;AACA,wB;AACA,a;AACA,W;;AAEA,6C;AACA,6C;AACA,yE;AACA,mB;AACA,O;;AAEA,+D;AACA,mC;AACA,8C;AACA,8D;AACA,uC;AACA,0D;AACA,e;;AAEA,uC;AACA,mE;AACA,2C;AACA,qC;AACA,uD;AACA,yE;AACA,S;AACA,uC;AACA,oE;AACA,e;;AAEA,4C;AACA,wE;AACA,2C;AACA,qC;AACA,uD;AACA,8E;AACA,S;AACA,uC;AACA,oE;AACA,e;;AAEA,+E;AACA,4C;AACA,sD;AACA,e;;AAEA,+E;AACA,4C;AACA,sD;AACA,e;;AAEA,6C;AACA,yE;AACA,4C;AACA,gF;AACA,e;;AAEA,uC;AACA,mE;AACA,4C;AACA,2E;AACA,e;;AAEA,oE;AACA,kD;AACA,e;;AAEA,yE;AACA,yC;AACA,sD;AACA,S;AACA,e;;AAEA,2E;AACA,kD;;AAEA,2C;AACA,8D;AACA,e;;AAEA,2E;AACA,kD;;AAEA,8D;AACA,e;;AAEA,kE;AACA,yB;AACA,2B;AACA,0C;AACA,iB;AACA,S;;AAEA,uB;AACA,sB;AACA,uC;;AAEA,qB;AACA,0C;AACA,6C;AACA,0D;AACA,iD;AACA,oB;AACA,oB;AACA,sD;AACA,a;;AAEA,4B;AACA,qB;AACA,4C;AACA,kD;AACA,0B;AACA,c;AACA,kB;AACA,0B;AACA,iD;AACA,kB;AACA,kB;AACA,4D;AACA,S;AACA,e;;AAEA,4D;AACA,yB;AACA,gC;AACA,2B;AACA,kD;AACA,sB;AACA,yC;AACA,iB;AACA,S;;AAEA,uB;AACA,4B;AACA,gC;AACA,0D;AACA,kB;AACA,uB;AACA,gC;AACA,kD;;AAEA,iE;AACA,kD;AACA,mD;AACA,kE;AACA,kD;AACA,a;AACA,kB;AACA,kB;AACA,qD;AACA,S;AACA,e;;AAEA,4E;AACA,2C;AACA,qC;AACA,kC;AACA,gC;AACA,6B;AACA,a;AACA,S;AACA,e;;AAEA,oE;AACA,oD;AACA,yD;AACA,iD;AACA,gE;AACA,gB;AACA,4B;AACA,S;AACA,e;;AAEA,sD;AACA,+B;AACA,iC;AACA,mD;AACA,gC;AACA,2E;AACA,S;;AAEA,uD;AACA,gC;AACA,oC;AACA,kC;AACA,oC;AACA,sC;AACA,sC;AACA,wD;AACA,+D;AACA,oD;AACA,wC;AACA,qE;AACA,qB;;AAEA,mC;AACA,kE;AACA,iC;AACA,yC;AACA,yC;AACA,e;AACA,0C;AACA,+D;AACA,iC;AACA,e;AACA,a;AACA,gE;AACA,Y;AACA,qC;AACA,iE;AACA,Y;AACA,6B;AACA,W;AACA,S;AACA,M;;AAEA,gF;AACA,qC;;AAEA,uD;AACA,iD;AACA,iE;AACA,uC;AACA,0D;AACA,oE;AACA,O;AACA,iD;AACA,uB;AACA,yC;AACA,yC;AACA,+B;AACA,qC;AACA,+C;AACA,6D;AACA,kC;AACA,S;AACA,M;;AAEA,iD;AACA,kE;AACA,M;;AAEA,uE;AACA,0D;AACA,0C;AACA,iE;AACA,O;;AAEA,qC;AACA,2C;AACA,4C;AACA,O;AACA,oE;AACA,4B;AACA,mC;AACA,+D;AACA,yC;AACA,oB;AACA,oB;AACA,6C;AACA,qB;AACA,M;;AAEA,mE;AACA,+E;AACA,M;;AAEA,wE;AACA,kE;AACA,kC;AACA,M;;AAEA,iE;AACA,0E;AACA,M;;AAEA,iE;AACA,gF;AACA,M;;AAEA,+D;AACA,yE;AACA,M;;AAEA,6D;AACA,wE;AACA,M;;AAEA,uD;AACA,qE;AACA,M;;AAEA,yD;AACA,sE;AACA,kD;AACA,gB;AACA,2B;AACA,wE;AACA,U;AACA,S;AACA,M;;AAEA,mD;AACA,mE;AACA,M;;AAEA,2D;AACA,2D;AACA,oC;AACA,kE;AACA,uC;AACA,qB;AACA,2B;AACA,W;AACA,S;AACA,gC;AACA,2B;AACA,oB;AACA,K;AACA,I;AACA,yB;;AAEA,K;;AAEA,G;AACA,2E;AACA,gF;AACA,0E;AACA,wB;AACA,U;AACA,G;AACA,gD;AACA,yB;AACA,mB;AACA,G;;AAEA,0B;AACA,O;AACA,yB;AACA,sD;AACA,O;AACA,qD;AACA,6B;AACA,gC;AACA,O;;AAEA,iB;AACA,8C;AACA,mB;AACA,uB;AACA,Q;AACA,6B;;AAEA,iB;AACA,M;;AAEA,O;AACA,6E;AACA,sE;AACA,M;AACA,+E;AACA,uE;AACA,4E;AACA,kB;AACA,O;AACA,mD;AACA,4E;AACA,8C;AACA,qB;AACA,gE;AACA,oB;AACA,O;;AAEA,6E;AACA,kB;AACA,iC;;AAEA,4E;AACA,8B;AACA,kC;AACA,qE;AACA,O;;AAEA,sB;AACA,M;;AAEA,O;AACA,wD;AACA,O;AACA,uD;AACA,sC;;AAEA,0B;AACA,sB;AACA,mC;AACA,M;;AAEA,uD;AACA,2B;;AAEA,yB;AACA,qB;AACA,c;AACA,oC;AACA,O;AACA,M;;AAEA,iD;AACA,oC;AACA,M;;AAEA,O;AACA,oE;AACA,O;AACA,iD;AACA,2B;AACA,kD;AACA,oB;AACA,c;AACA,gC;AACA,O;AACA,M;;AAEA,wC;AACA,qB;AACA,K;AACA,I;AACA,oB;AACA,K;;AAEA,G;AACA,6C;AACA,S;AACA,G;AACA,gD;AACA,2C;AACA,kD;;AAEA,O;AACA,2E;AACA,yE;AACA,2D;AACA,uB;AACA,O;AACA,2B;AACA,G;;AAEA,6D;AACA,O;AACA,6C;AACA,wB;AACA,O;AACA,mB;AACA,yD;AACA,M;;AAEA,O;AACA,6E;AACA,8E;AACA,wD;AACA,O;AACA,0C;AACA,wC;AACA,M;;AAEA,O;AACA,qE;AACA,M;AACA,+E;AACA,2E;AACA,4E;AACA,6C;AACA,O;AACA,6D;AACA,8D;AACA,K;AACA,I;;AAEA,oB;AACA,K;;AAEA,G;AACA,yB;AACA,U;AACA,G;AACA,gE;;AAEA,+E;AACA,2C;AACA,6B;AACA,yB;AACA,qB;AACA,iC;AACA,gC;AACA,qC;AACA,iC;AACA,yB;AACA,sC;AACA,+B;AACA,2B;AACA,gD;AACA,qC;AACA,iC;AACA,oD;AACA,4D;AACA,4C;AACA,G;;AAEA,kC;;AAEA,sB;AACA,qE;;AAEA,2B;AACA,e;AACA,O;AACA,4D;AACA,+C;AACA,8E;AACA,6C;AACA,uE;AACA,O;;AAEA,+B;AACA,0E;AACA,kE;;AAEA,2D;AACA,+B;AACA,gC;AACA,uC;AACA,qC;AACA,O;AACA,M;;AAEA,kD;AACA,2B;AACA,4B;AACA,iC;AACA,M;;AAEA,4E;AACA,gC;AACA,0C;AACA,2D;AACA,S;AACA,e;AACA,O;;AAEA,yB;AACA,2D;AACA,O;;AAEA,yB;AACA,e;AACA,O;AACA,uB;AACA,M;;AAEA,wD;AACA,0B;AACA,2B;AACA,e;AACA,O;AACA,iC;AACA,sE;AACA,c;AACA,6B;AACA,O;AACA,M;;AAEA,gE;AACA,oD;AACA,M;;AAEA,gD;AACA,2B;AACA,e;AACA,O;AACA,4E;AACA,6D;AACA,4D;AACA,sD;AACA,wE;AACA,6B;AACA,0C;AACA,gC;AACA,0B;AACA,S;AACA,O;AACA,K;;AAEA,I;;AAEA,4B;AACA,K;;;AAGA,6D;AACA,8B;AACA,qE;AACA,2D;AACA,4D;AACA,8D;AACA,S;AACA,qB;AACA,iD;AACA,uE;AACA,0E;AACA,4D;AACA,mE;AACA,O;AACA,yB;AACA,O;AACA,G;;AAEA,2B;AACA,mC;AACA,8C;AACA,+B;;AAEA,mC;AACA,6D;AACA,6C;AACA,iD;AACA,K;;AAEA,6B;AACA,uB;AACA,iB;AACA,G;;AAEA,wB;AACA,sC;AACA,kC;AACA,oC;;AAEA,6E;AACA,6B;AACA,iE;AACA,gC;AACA,S;AACA,O;;AAEA,+D;AACA,mE;AACA,e;AACA,O;;AAEA,+E;AACA,8D;AACA,2B;AACA,gE;AACA,mB;AACA,S;;AAEA,4E;AACA,uE;AACA,wC;AACA,gD;AACA,2D;AACA,W;AACA,S;AACA,O;AACA,M;;AAEA,sC;AACA,yC;AACA,M;;AAEA,sC;AACA,wD;AACA,K;AACA,I;;AAEA,kB;AACA,K;;;AAGA,8D;AACA,4D;;AAEA,0E;AACA,uB;AACA,0E;AACA,wB;AACA,0B;;AAEA,2D;AACA,4B;;AAEA,gC;AACA,+B;;AAEA,2B;;AAEA,6C;AACA,gD;AACA,uB;AACA,yB;AACA,gB;AACA,C;;AAEA,0C;AACA,+E;AACA,iC;AACA,iC;AACA,uC;AACA,qC;AACA,mC;AACA,2C;AACA,2C;AACA,iD;;AAEA,sE;AACA,6B;;AAEA,uD;AACA,2C;AACA,qC;AACA,O;AACA,O;;AAEA,8D;AACA,kD;AACA,+C;AACA,8C;AACA,wE;;AAEA,sC;AACA,uE;;AAEA,kC;AACA,kC;;AAEA,gB;AACA,oB;AACA,oB;AACA,oB;AACA,oB;AACA,kC;AACA,iC;AACA,U;AACA,O;AACA,O;;AAEA,mC;AACA,sC;AACA,qC;AACA,8C;;AAEA,2B;AACA,M;;AAEA,yC;AACA,4C;AACA,iB;AACA,qC;AACA,gC;AACA,O;AACA,M;;AAEA,iD;AACA,oC;AACA,wC;AACA,wC;;AAEA,oC;AACA,M;;AAEA,yC;AACA,oC;AACA,sB;AACA,sB;AACA,sB;AACA,sB;;AAEA,gC;AACA,M;;AAEA,6D;AACA,oC;AACA,+B;AACA,4B;AACA,4B;AACA,4B;AACA,4B;AACA,mC;AACA,kC;AACA,Q;;AAEA,+C;AACA,M;;AAEA,mE;AACA,iD;;AAEA,kD;AACA,M;;AAEA,4C;AACA,qC;AACA,qC;;AAEA,oC;AACA,+B;AACA,0C;AACA,0C;AACA,6C;AACA,6C;AACA,a;AACA,Y;AACA,Q;;AAEA,kC;AACA,M;AACA,G;AACA,C;;AAEA,wD;AACA,iB;AACA,U;AACA,mE;AACA,kE;AACA,sB;AACA,oC;AACA,gC;AACA,yC;AACA,2C;AACA,6E;AACA,2D;AACA,c;AACA,wD;AACA,0C;AACA,6B;AACA,0C;AACA,S;AACA,iE;AACA,O;AACA,yB;AACA,M;AACA,wB;AACA,6B;AACA,oC;AACA,0E;AACA,8E;AACA,qC;AACA,sC;AACA,yB;AACA,O;AACA,K;AACA,I;AACA,K;;AAEA,qC;AACA,oC;;AAEA,qD;AACA,mC;AACA,qD;AACA,mB;AACA,wE;;AAEA,iC;AACA,wD;AACA,4D;AACA,+C;AACA,oC;AACA,sB;AACA,4C;AACA,iB;AACA,K;AACA,G;;AAEA,2E;AACA,8E;AACA,+D;AACA,Y;AACA,Y;AACA,Y;AACA,qD;AACA,qC;AACA,uC;AACA,mC;AACA,gB;AACA,U;AACA,wB;AACA,kB;AACA,Y;AACA,G;AACA,+B;AACA,sC;AACA,oC;AACA,c;AACA,K;AACA,U;AACA,G;AACA,wB;AACA,kB;AACA,Y;AACA,G;AACA,gC;AACA,uB;AACA,oB;AACA,6C;AACA,qC;AACA,c;AACA,K;AACA,8E;AACA,yE;AACA,mE;AACA,iC;AACA,kD;AACA,+C;AACA,6B;AACA,0C;AACA,gB;AACA,O;AACA,Y;AACA,K;AACA,6C;AACA,yC;AACA,c;AACA,K;;AAEA,yC;AACA,kB;AACA,K;AACA,G;;AAEA,gC;AACA,kB;AACA,wB;AACA,mB;AACA,Y;AACA,G;AACA,+B;AACA,sC;AACA,yC;AACA,c;AACA,K;AACA,U;AACA,G;AACA,wB;AACA,uB;AACA,Y;AACA,G;AACA,uC;AACA,gB;AACA,G;;AAEA,sB;AACA,sE;AACA,oB;AACA,0C;AACA,uB;AACA,wB;AACA,mC;AACA,U;AACA,K;AACA,oB;AACA,e;AACA,K;AACA,iC;;AAEA,qC;AACA,Q;AACA,6B;AACA,U;AACA,kB;AACA,2B;;AAEA,qB;AACA,kC;AACA,4B;AACA,kB;AACA,sB;AACA,sB;AACA,iD;AACA,4B;AACA,yC;AACA,wC;AACA,6C;AACA,O;;AAEA,8B;AACA,oC;AACA,c;AACA,uB;AACA,0B;AACA,Q;AACA,G;;AAEA,iC;AACA,a;AACA,uD;AACA,oC;AACA,4B;AACA,kB;AACA,wD;AACA,0B;AACA,2B;AACA,sD;AACA,+B;AACA,O;AACA,K;AACA,a;AACA,kB;AACA,gB;AACA,I;;AAEA,qB;AACA,C;;AAEA,4D;AACA,kC;AACA,2D;AACA,8B;AACA,sB;AACA,2B;AACA,sC;AACA,6B;AACA,2C;AACA,qB;AACA,0C;AACA,e;AACA,e;AACA,+C;AACA,mB;AACA,mB;AACA,iC;AACA,yB;AACA,yB;AACA,wB;AACA,oD;AACA,sB;AACA,yC;AACA,+B;AACA,iC;AACA,6B;AACA,8D;AACA,uB;AACA,yB;AACA,uB;AACA,6E;;AAEA,mB;AACA,G;;AAEA,gC;AACA,8C;AACA,iC;AACA,M;AACA,sE;AACA,iB;AACA,iB;AACA,K;AACA,I;AACA,0B;AACA,K;;AAEA,wD;AACA,sE;AACA,0D;AACA,0B;AACA,mE;AACA,2B;;AAEA,oE;AACA,yB;AACA,0C;AACA,yB;AACA,4B;AACA,+B;AACA,oB;AACA,sB;AACA,iC;AACA,qB;AACA,iC;AACA,yB;AACA,gC;AACA,gF;AACA,yB;AACA,8B;AACA,iC;AACA,wB;AACA,yB;AACA,0B;AACA,0B;AACA,oB;AACA,8E;AACA,8E;AACA,4C;AACA,K;AACA,0C;AACA,G;;AAEA,6C;AACA,2E;AACA,sC;AACA,a;AACA,K;;AAEA,0E;AACA,+E;AACA,8E;AACA,4E;AACA,+E;AACA,mE;AACA,M;AACA,8E;AACA,yE;AACA,8C;;AAEA,uD;AACA,wD;AACA,uE;AACA,6E;;AAEA,qE;AACA,4B;AACA,2B;AACA,iC;AACA,gD;;AAEA,0E;AACA,+C;AACA,oD;AACA,2D;AACA,qC;AACA,8E;AACA,kC;AACA,2C;AACA,yC;AACA,6B;AACA,yE;AACA,gC;AACA,yC;AACA,yB;AACA,oE;AACA,oB;AACA,+C;AACA,2C;AACA,oB;AACA,uE;AACA,uC;AACA,uB;AACA,0B;AACA,4C;AACA,oC;AACA,gE;AACA,+D;AACA,+D;AACA,+D;AACA,8D;AACA,8D;AACA,8D;AACA,8D;AACA,W;AACA,iC;AACA,8B;AACA,uC;AACA,0B;AACA,c;;AAEA,iE;AACA,uB;AACA,W;AACA,S;AACA,sE;AACA,4C;AACA,gC;AACA,S;;AAEA,iE;AACA,O;AACA,uD;AACA,iC;;AAEA,Y;AACA,uD;AACA,wC;AACA,kE;AACA,mC;;AAEA,6C;AACA,+B;AACA,O;AACA,4B;AACA,0D;AACA,kE;AACA,6C;AACA,O;;AAEA,sD;AACA,gC;AACA,0C;AACA,iD;AACA,yC;AACA,8B;AACA,+C;AACA,qD;AACA,S;;AAEA,oB;AACA,0C;AACA,0C;AACA,0C;AACA,0C;AACA,gC;AACA,S;AACA,iE;AACA,O;AACA,Y;AACA,+C;AACA,K;AACA,G;;AAEA,6C;AACA,uD;AACA,wD;AACA,uE;AACA,6E;;AAEA,qE;AACA,mB;AACA,2B;AACA,iC;;AAEA,2C;AACA,2B;AACA,kE;;AAEA,uE;AACA,4C;AACA,gD;AACA,iD;AACA,qB;AACA,yC;AACA,sB;AACA,qC;AACA,uB;AACA,W;AACA,kD;AACA,uB;AACA,qB;AACA,S;AACA,O;AACA,+D;AACA,K;AACA,G;;AAEA,6C;AACA,4E;AACA,uE;AACA,0D;AACA,0D;AACA,mC;AACA,8C;AACA,gD;AACA,O;AACA,K;AACA,8C;AACA,mD;AACA,yD;AACA,uD;AACA,0C;AACA,sD;AACA,K;AACA,G;;AAEA,oD;AACA,8B;AACA,yC;AACA,2B;AACA,wB;AACA,0B;AACA,0B;AACA,0B;AACA,+B;AACA,iC;AACA,iE;AACA,iE;AACA,iE;AACA,O;AACA,K;AACA,G;;AAEA,mD;AACA,iC;AACA,wB;AACA,yC;AACA,8B;AACA,wD;AACA,K;AACA,G;;AAEA,wD;AACA,iC;AACA,yC;AACA,gE;AACA,sD;AACA,sD;AACA,8C;AACA,K;AACA,G;;AAEA,gE;AACA,mD;AACA,iC;AACA,2C;AACA,2C;AACA,2C;;AAEA,kB;AACA,mC;AACA,yC;AACA,Y;AACA,oC;AACA,K;;AAEA,gD;AACA,oC;AACA,2E;AACA,uD;AACA,0D;AACA,sE;AACA,wE;;AAEA,wB;AACA,wD;AACA,O;AACA,+C;;AAEA,8C;AACA,K;AACA,G;;AAEA,+C;AACA,4B;AACA,gC;;AAEA,sD;AACA,mD;;AAEA,0C;AACA,+B;AACA,mE;AACA,sD;AACA,yC;AACA,4D;AACA,a;AACA,K;AACA,mE;AACA,iD;AACA,8B;AACA,G;;AAEA,oD;AACA,qD;AACA,uB;AACA,mB;;AAEA,8B;;AAEA,gF;AACA,+E;AACA,uE;AACA,4E;AACA,4E;AACA,gB;AACA,wC;AACA,0C;AACA,yB;AACA,gD;AACA,c;AACA,kC;AACA,wB;AACA,kD;AACA,+C;AACA,2B;AACA,O;;AAEA,yC;;AAEA,sB;AACA,oD;;AAEA,gE;;AAEA,4B;AACA,sC;AACA,O;AACA,M;;AAEA,qE;AACA,iD;AACA,wE;AACA,8C;AACA,6C;AACA,yC;AACA,qC;AACA,0C;;AAEA,wD;AACA,+B;AACA,iB;AACA,O;;AAEA,kE;AACA,qE;AACA,sE;AACA,oB;;AAEA,uC;AACA,2B;AACA,e;;AAEA,oB;AACA,oE;AACA,+C;AACA,mB;AACA,S;;AAEA,0B;;AAEA,sC;AACA,+C;AACA,gB;AACA,kC;AACA,0D;AACA,mC;AACA,oE;AACA,sD;;AAEA,0E;AACA,2C;AACA,iD;AACA,uD;AACA,uB;AACA,a;AACA,W;AACA,S;;AAEA,Y;;AAEA,sE;AACA,iC;AACA,mB;AACA,S;;AAEA,yE;AACA,oE;AACA,2D;AACA,qC;AACA,+B;AACA,qB;AACA,W;AACA,oB;AACA,S;;AAEA,6E;AACA,6D;AACA,O;AACA,M;;AAEA,sD;AACA,yB;AACA,6B;AACA,yB;;AAEA,4B;AACA,oC;AACA,O;AACA,M;;AAEA,qB;AACA,+D;AACA,qC;AACA,iC;AACA,M;AACA,2D;AACA,gD;AACA,M;AACA,6D;AACA,kD;AACA,M;AACA,iE;AACA,kC;AACA,M;AACA,oE;AACA,yB;AACA,0C;AACA,mC;AACA,uC;AACA,c;AACA,gC;AACA,sC;AACA,O;AACA,M;AACA,4E;AACA,8E;AACA,+B;AACA,mC;AACA,M;AACA,gE;AACA,8E;AACA,2B;AACA,M;AACA,0D;AACA,wD;AACA,8B;AACA,2B;AACA,6B;;AAEA,sB;AACA,oB;AACA,qC;AACA,kB;AACA,oB;AACA,mC;AACA,kB;AACA,oB;AACA,oC;AACA,kB;AACA,oB;AACA,sC;AACA,kB;AACA,mB;AACA,6C;AACA,kB;AACA,oB;AACA,2C;AACA,kB;AACA,oB;AACA,oC;AACA,kB;AACA,sB;AACA,6C;AACA,kB;AACA,oB;AACA,gD;AACA,kB;AACA,oB;AACA,8C;AACA,4C;AACA,kB;AACA,oB;AACA,mE;AACA,uD;AACA,6B;AACA,+C;AACA,iB;AACA,6B;AACA,uD;AACA,+D;AACA,0D;AACA,2C;AACA,e;AACA,oB;AACA,gE;AACA,a;AACA,kB;AACA,uB;AACA,2C;AACA,mC;AACA,a;AACA,qE;AACA,2C;AACA,qC;AACA,a;AACA,kC;AACA,kB;AACA,S;AACA,O;AACA,M;AACA,gE;;AAEA,iD;AACA,gD;AACA,kD;AACA,qD;AACA,mD;AACA,gD;;AAEA,gC;AACA,4D;AACA,sB;;AAEA,2C;AACA,qE;AACA,qE;AACA,2D;;AAEA,yC;AACA,0B;AACA,sB;AACA,yB;AACA,kB;AACA,iB;AACA,S;AACA,uC;AACA,wB;AACA,M;AACA,4D;AACA,8B;AACA,wB;AACA,uC;;AAEA,iE;AACA,yB;AACA,M;AACA,0C;AACA,sB;AACA,6B;AACA,gC;AACA,iC;AACA,sC;AACA,M;AACA,gD;AACA,yC;AACA,gD;AACA,+B;AACA,S;;AAEA,6C;AACA,2B;;AAEA,8C;AACA,O;AACA,M;AACA,oE;AACA,2C;;AAEA,4C;AACA,M;;AAEA,W;AACA,qE;AACA,yB;AACA,iC;AACA,uC;AACA,4D;AACA,6B;AACA,6B;AACA,0B;AACA,0B;AACA,kC;AACA,mC;AACA,8B;AACA,iD;AACA,a;AACA,+B;AACA,kD;AACA,a;AACA,+B;AACA,gC;AACA,kC;AACA,mC;AACA,oC;AACA,mC;AACA,kC;AACA,iC;AACA,kB;AACA,0B;AACA,0B;AACA,0B;AACA,6B;AACA,kB;AACA,0B;AACA,0B;AACA,0B;AACA,6B;AACA,kB;AACA,2B;AACA,4B;AACA,4B;AACA,6E;AACA,oC;AACA,mB;AACA,kB;AACA,4B;AACA,yD;AACA,wD;AACA,4B;AACA,4B;AACA,mB;AACA,kB;AACA,4B;AACA,4B;AACA,4B;AACA,gE;AACA,mB;AACA,kB;AACA,6B;AACA,4B;AACA,kB;AACA,S;AACA,O;AACA,oC;AACA,M;AACA,oD;AACA,2B;AACA,M;AACA,yD;AACA,4E;AACA,yB;AACA,iD;AACA,0E;AACA,6E;AACA,uD;AACA,yE;AACA,wB;AACA,iD;AACA,8D;AACA,2C;AACA,iE;AACA,8D;AACA,mB;AACA,4D;AACA,qB;AACA,sB;AACA,c;AACA,qB;AACA,O;AACA,wB;AACA,2B;AACA,O;AACA,mD;AACA,+C;AACA,M;AACA,wD;AACA,uB;AACA,oB;AACA,M;AACA,qD;AACA,4E;AACA,yB;AACA,6C;AACA,mD;AACA,8B;;AAEA,0B;AACA,mB;AACA,wD;AACA,2B;AACA,O;;AAEA,+B;AACA,4C;AACA,sC;AACA,qB;AACA,sC;AACA,gB;AACA,e;AACA,gC;AACA,wB;AACA,4E;AACA,uB;AACA,W;AACA,S;AACA,mC;AACA,c;AACA,mB;AACA,O;;AAEA,wB;AACA,sB;AACA,O;AACA,wB;AACA,2B;AACA,O;AACA,M;AACA,8C;AACA,gC;AACA,kB;AACA,M;AACA,sD;AACA,uB;AACA,yB;;AAEA,yB;AACA,M;AACA,0D;AACA,gC;AACA,wB;AACA,M;AACA,gE;AACA,uB;AACA,wB;AACA,M;AACA,oE;AACA,gC;AACA,uB;AACA,wB;AACA,M;AACA,gD;AACA,yB;AACA,M;;AAEA,e;AACA,0C;AACA,qC;AACA,M;AACA,8C;AACA,iC;AACA,M;;AAEA,W;AACA,oD;AACA,gD;AACA,uC;AACA,8C;AACA,8C;AACA,M;AACA,gD;AACA,wC;AACA,yB;AACA,gC;AACA,wB;AACA,e;AACA,O;;AAEA,iB;AACA,sB;AACA,8C;AACA,4B;AACA,oD;AACA,sC;AACA,2C;AACA,O;AACA,oB;AACA,iB;AACA,sB;AACA,mC;AACA,M;AACA,qE;AACA,yC;AACA,M;AACA,qE;AACA,yC;AACA,M;AACA,yD;AACA,4C;AACA,M;AACA,6D;AACA,sC;AACA,M;AACA,iE;AACA,qD;AACA,iC;;AAEA,qB;AACA,qD;AACA,O;;AAEA,gD;AACA,uE;;AAEA,uE;AACA,6D;AACA,wC;AACA,wC;AACA,4D;AACA,O;;AAEA,+E;AACA,mE;AACA,qB;AACA,qB;AACA,mC;AACA,c;AACA,kC;AACA,O;;AAEA,kC;AACA,mC;;AAEA,gC;AACA,yD;AACA,O;;AAEA,oD;AACA,qE;AACA,oE;;AAEA,wD;AACA,+D;;AAEA,mE;AACA,+E;AACA,0E;AACA,gE;AACA,kE;AACA,wE;AACA,0D;;AAEA,gF;AACA,2B;AACA,M;AACA,8E;AACA,4C;AACA,M;AACA,4D;AACA,mC;AACA,M;AACA,sD;AACA,+C;AACA,+C;AACA,M;AACA,0E;AACA,0B;AACA,0B;AACA,M;AACA,4E;AACA,mD;AACA,8D;;AAEA,8C;AACA,8C;AACA,M;AACA,kD;AACA,6C;AACA,M;;AAEA,mE;AACA,yB;AACA,iC;AACA,8B;AACA,wD;AACA,8D;AACA,8C;AACA,2C;AACA,iD;AACA,4C;;AAEA,oB;AACA,mD;AACA,sE;AACA,O;;AAEA,iC;AACA,mB;AACA,4B;AACA,wB;AACA,iC;AACA,wD;AACA,+D;AACA,qB;AACA,S;AACA,0D;AACA,+D;AACA,uB;AACA,S;AACA,sB;AACA,c;AACA,wD;AACA,+D;AACA,wC;AACA,S;AACA,0D;AACA,+D;AACA,0C;AACA,S;AACA,O;;AAEA,2B;AACA,0E;AACA,oB;AACA,6C;AACA,e;AACA,e;AACA,6B;AACA,8B;AACA,W;AACA,O;AACA,M;;AAEA,mC;AACA,wE;AACA,+C;AACA,kE;AACA,wB;AACA,+B;AACA,qD;AACA,0B;AACA,gD;AACA,2C;AACA,yB;AACA,gB;AACA,S;AACA,O;AACA,8D;AACA,M;;AAEA,wD;AACA,iC;AACA,8B;AACA,6B;AACA,0C;AACA,O;;AAEA,sC;AACA,2B;AACA,e;AACA,O;;AAEA,yB;AACA,gD;AACA,4C;AACA,4C;AACA,gD;AACA,0D;AACA,uC;AACA,mC;AACA,iD;AACA,+D;;AAEA,0B;AACA,+D;AACA,8B;;AAEA,iB;AACA,mD;AACA,6D;;AAEA,8B;AACA,kC;AACA,c;AACA,iC;AACA,O;;AAEA,wC;AACA,0C;AACA,2C;AACA,wD;AACA,6C;AACA,0D;AACA,+D;AACA,gD;AACA,oE;AACA,S;AACA,c;AACA,2B;AACA,O;;AAEA,kC;AACA,gD;AACA,mC;AACA,O;;AAEA,gC;;AAEA,mB;AACA,0C;AACA,8B;AACA,6B;AACA,uB;AACA,2C;AACA,mB;AACA,kC;AACA,yC;AACA,mB;AACA,S;;AAEA,kC;AACA,uC;AACA,kC;AACA,2D;AACA,gC;AACA,uB;AACA,8B;AACA,qD;AACA,wD;AACA,uC;AACA,8C;;AAEA,gD;AACA,uC;AACA,6C;AACA,gB;AACA,sC;AACA,sB;AACA,S;;AAEA,0E;AACA,wE;AACA,kC;AACA,uE;AACA,qC;AACA,sD;AACA,+B;AACA,qB;AACA,wC;AACA,qC;AACA,S;;AAEA,wC;AACA,wB;AACA,oD;AACA,gB;AACA,sD;AACA,uB;AACA,sE;AACA,sE;AACA,0E;AACA,W;AACA,S;;AAEA,gF;AACA,uB;;AAEA,4B;AACA,wB;AACA,S;AACA,O;AACA,qB;AACA,oC;AACA,c;AACA,oC;AACA,O;AACA,oB;AACA,M;;AAEA,kE;AACA,iD;AACA,yB;AACA,iC;AACA,8B;AACA,sC;AACA,gD;AACA,4C;AACA,4C;AACA,0D;AACA,kE;AACA,uC;AACA,2B;AACA,kE;AACA,0B;;AAEA,8C;AACA,e;AACA,O;;AAEA,iB;AACA,mD;AACA,0C;;AAEA,2C;;AAEA,0C;AACA,0B;AACA,6B;AACA,uB;AACA,6C;AACA,gD;AACA,mB;AACA,kC;AACA,wD;AACA,+C;AACA,kD;AACA,mB;AACA,S;;AAEA,2E;AACA,4B;AACA,4D;AACA,sC;AACA,mB;AACA,S;AACA,qC;AACA,oB;AACA,sC;AACA,6C;AACA,+C;AACA,uB;;AAEA,4E;AACA,wD;;AAEA,gC;AACA,wC;AACA,O;AACA,oB;AACA,kC;AACA,M;;AAEA,kB;AACA,wE;AACA,qE;AACA,0C;AACA,M;AACA,gF;AACA,+E;AACA,4E;AACA,4E;AACA,4E;AACA,8E;AACA,8E;AACA,2E;AACA,oD;AACA,kB;AACA,qB;AACA,M;;AAEA,Y;AACA,sE;AACA,kB;AACA,sC;AACA,0B;AACA,mE;AACA,yE;AACA,c;AACA,8C;AACA,O;AACA,qB;AACA,M;AACA,uE;AACA,mE;AACA,M;AACA,mE;AACA,iE;AACA,sC;AACA,M;AACA,2E;AACA,2C;AACA,mC;AACA,uC;AACA,M;AACA,uE;AACA,2C;AACA,iC;AACA,qC;AACA,uC;AACA,M;;AAEA,iE;AACA,yB;;AAEA,kB;AACA,uD;AACA,0D;;AAEA,+C;AACA,gB;AACA,gC;AACA,iC;AACA,mC;;AAEA,kD;AACA,uD;AACA,sD;AACA,2D;;AAEA,sD;AACA,sD;AACA,sD;AACA,sD;;AAEA,oD;AACA,c;AACA,gE;AACA,gE;AACA,kE;AACA,4D;AACA,8D;;AAEA,oD;AACA,O;;AAEA,qB;AACA,M;;AAEA,a;AACA,kE;AACA,gD;AACA,M;AACA,8D;AACA,8C;AACA,M;;AAEA,gF;AACA,+E;AACA,kB;AACA,uD;;AAEA,mD;AACA,2C;AACA,O;;AAEA,wD;;AAEA,+C;AACA,sC;AACA,uC;AACA,uD;AACA,oB;AACA,uB;AACA,O;AACA,M;;AAEA,wE;AACA,qB;AACA,yD;AACA,M;;AAEA,2D;AACA,kB;AACA,gC;AACA,0E;AACA,6E;AACA,iE;AACA,6E;AACA,mC;AACA,sE;AACA,wB;AACA,qC;AACA,8E;AACA,8E;AACA,iB;AACA,mC;AACA,mE;AACA,4B;AACA,mD;AACA,O;;AAEA,+E;AACA,e;AACA,2B;AACA,+C;AACA,O;;AAEA,4D;AACA,yB;AACA,6D;AACA,O;AACA,sD;;AAEA,2E;AACA,0B;AACA,mD;AACA,+B;AACA,oD;AACA,qD;AACA,4B;AACA,4B;AACA,kD;AACA,oD;AACA,oE;AACA,+E;AACA,2D;AACA,0C;AACA,0C;AACA,mE;AACA,oE;AACA,iC;AACA,wC;AACA,6C;AACA,oC;AACA,O;AACA,yC;AACA,8C;AACA,qC;AACA,O;;AAEA,gD;AACA,wB;AACA,+E;AACA,4D;AACA,O;AACA,mD;AACA,gD;AACA,2C;;AAEA,gF;AACA,4C;AACA,6C;AACA,6C;AACA,2D;;AAEA,wB;AACA,gE;AACA,8B;AACA,uC;AACA,4B;AACA,2B;AACA,2B;AACA,yB;AACA,yB;AACA,uC;AACA,wC;AACA,W;AACA,c;AACA,8E;AACA,0B;AACA,kD;AACA,+C;AACA,yC;AACA,O;AACA,2E;AACA,+D;AACA,yC;AACA,0B;AACA,sB;AACA,yB;AACA,kB;AACA,iB;AACA,S;AACA,uC;AACA,wB;AACA,M;;AAEA,uD;AACA,wB;AACA,8B;AACA,uC;AACA,4E;AACA,2C;AACA,yD;AACA,+C;AACA,c;AACA,kD;AACA,O;AACA,wB;AACA,+C;AACA,c;AACA,kD;AACA,O;AACA,qB;AACA,M;;AAEA,kE;AACA,kB;AACA,4C;AACA,M;;AAEA,8D;AACA,qB;AACA,M;;AAEA,6E;AACA,sE;AACA,kB;;AAEA,+C;AACA,sC;AACA,uC;AACA,uD;AACA,oB;AACA,uB;AACA,O;;AAEA,4C;AACA,yC;AACA,M;;AAEA,4D;AACA,qB;AACA,M;;AAEA,6E;AACA,0C;AACA,sB;AACA,iD;AACA,e;AACA,O;;AAEA,kB;;AAEA,yB;AACA,2C;AACA,+B;;AAEA,oE;AACA,iC;AACA,4B;AACA,8D;AACA,oD;AACA,qC;AACA,uB;AACA,4B;AACA,2B;AACA,yC;AACA,yC;AACA,W;AACA,O;AACA,qB;AACA,M;;AAEA,+E;AACA,yB;AACA,iD;AACA,6C;AACA,mD;;AAEA,uC;;AAEA,0E;AACA,4E;AACA,0B;AACA,8E;AACA,gB;AACA,gC;AACA,S;AACA,O;;AAEA,oC;AACA,4B;AACA,e;AACA,O;;AAEA,6E;AACA,uC;AACA,qB;;AAEA,uC;;AAEA,qD;;AAEA,yC;AACA,0E;AACA,4C;;AAEA,wB;;AAEA,sD;AACA,M;;AAEA,gC;AACA,0E;AACA,8E;AACA,gC;AACA,kC;AACA,6C;AACA,mD;;AAEA,6E;AACA,uC;AACA,qB;;AAEA,2C;;AAEA,qD;;AAEA,yC;AACA,0E;AACA,4C;;AAEA,wB;;AAEA,yB;AACA,8D;AACA,mB;AACA,4E;AACA,yB;AACA,6D;AACA,uB;AACA,sB;AACA,O;AACA,M;;AAEA,+B;AACA,kE;AACA,yB;;AAEA,6C;AACA,mD;AACA,wD;AACA,8B;AACA,uD;;AAEA,+E;AACA,yC;AACA,uB;;AAEA,2C;;AAEA,uD;;AAEA,2C;AACA,4E;AACA,8C;;AAEA,0B;;AAEA,mB;AACA,kD;AACA,yB;AACA,6D;AACA,mC;AACA,sB;AACA,O;AACA,M;;AAEA,yE;AACA,yC;AACA,qB;AACA,iD;AACA,e;AACA,O;;AAEA,4C;AACA,M;;AAEA,4B;AACA,4E;AACA,sE;AACA,yC;AACA,qB;AACA,iD;AACA,e;AACA,O;;AAEA,gC;AACA,kC;AACA,mB;AACA,8D;AACA,iE;AACA,sE;AACA,O;AACA,sD;AACA,M;;AAEA,4B;AACA,gE;AACA,gC;AACA,kC;AACA,yB;;AAEA,kB;AACA,2C;AACA,wC;;AAEA,4D;AACA,2D;AACA,6D;AACA,2D;AACA,8D;;AAEA,gC;AACA,qE;AACA,4D;AACA,6B;AACA,c;AACA,2E;AACA,uC;AACA,4C;AACA,sC;AACA,O;;AAEA,mD;AACA,oC;AACA,gF;AACA,gF;AACA,uC;AACA,kD;AACA,oD;AACA,2D;AACA,+C;AACA,+C;AACA,8C;AACA,S;AACA,iD;AACA,iD;AACA,iD;AACA,S;AACA,+E;AACA,mC;AACA,oD;AACA,mE;AACA,gE;AACA,sC;AACA,8B;AACA,gC;AACA,8E;AACA,O;AACA,8D;AACA,2D;;AAEA,4B;AACA,0D;AACA,qC;AACA,2B;AACA,4B;AACA,2B;AACA,6C;AACA,8C;AACA,W;AACA,O;AACA,qB;AACA,M;;AAEA,iC;AACA,0E;AACA,yB;AACA,4B;AACA,6B;;AAEA,oE;AACA,qC;AACA,0C;;AAEA,qD;AACA,2B;AACA,mB;AACA,kD;AACA,yB;AACA,2E;AACA,mC;AACA,8B;AACA,kE;AACA,uC;AACA,6B;AACA,8B;AACA,6B;AACA,qB;AACA,qB;AACA,a;AACA,S;AACA,sB;AACA,O;AACA,M;;AAEA,6B;AACA,0D;AACA,sC;AACA,M;;AAEA,qB;;AAEA,uD;AACA,6B;AACA,M;AACA,6E;AACA,6B;AACA,M;AACA,yE;AACA,6B;AACA,M;AACA,6E;AACA,0D;AACA,6B;AACA,M;AACA,kE;AACA,6B;AACA,M;;AAEA,oB;;AAEA,wD;AACA,oE;AACA,M;AACA,oD;AACA,+C;AACA,M;;AAEA,uB;;AAEA,wD;AACA,yB;AACA,6B;AACA,2C;AACA,8C;AACA,wC;AACA,uB;AACA,wC;AACA,kB;AACA,iB;AACA,kC;AACA,0B;AACA,8E;AACA,yB;AACA,a;AACA,W;AACA,gB;AACA,qB;AACA,S;AACA,gC;AACA,O;AACA,sB;AACA,M;AACA,6E;AACA,oD;AACA,0D;AACA,2D;AACA,4D;AACA,8D;AACA,gE;AACA,O;AACA,4C;AACA,M;AACA,wE;AACA,qD;AACA,gB;AACA,6D;AACA,4D;AACA,U;AACA,K;AACA,I;;AAEA,uB;AACA,qE;AACA,G;;AAEA,wB;AACA,K;;;AAGA,gD;AACA,6C;AACA,6C;AACA,kC;AACA,6B;AACA,oE;AACA,oB;AACA,iD;AACA,sE;AACA,K;AACA,kB;AACA,G;AACA,yC;AACA,kD;AACA,G;AACA,2C;AACA,oD;AACA,G;AACA,uC;AACA,qC;AACA,uD;AACA,2C;AACA,K;AACA,4B;AACA,iE;AACA,kB;AACA,mD;AACA,mE;AACA,K;AACA,mB;AACA,G;AACA,gD;AACA,gC;AACA,qC;AACA,2C;;AAEA,0D;AACA,yE;AACA,yE;AACA,uE;AACA,uE;;AAEA,yC;AACA,+E;AACA,mB;AACA,G;;AAEA,+B;AACA,yB;AACA,oB;AACA,a;AACA,K;AACA,qD;AACA,iD;AACA,qC;AACA,G;;AAEA,gC;AACA,iE;AACA,iE;AACA,iE;AACA,iE;AACA,iE;AACA,iE;AACA,iE;AACA,iE;AACA,iE;AACA,iE;AACA,iE;AACA,iE;AACA,kE;;AAEA,kC;AACA,iE;AACA,iE;AACA,iE;AACA,iE;AACA,iE;AACA,iE;AACA,iE;AACA,iE;AACA,iE;AACA,iE;AACA,iE;AACA,iE;AACA,iE;AACA,iE;AACA,iE;AACA,iE;AACA,iE;AACA,iE;AACA,iE;AACA,iE;AACA,iE;AACA,iE;AACA,iE;AACA,iE;AACA,iE;AACA,iE;AACA,kE;;AAEA,wB;;AAEA,0B;AACA,mB;;AAEA,iB;AACA,2B;AACA,yB;AACA,mB;AACA,qB;;AAEA,2B;AACA,qE;AACA,2E;AACA,oE;AACA,2B;;AAEA,mB;AACA,kB;AACA,0B;AACA,8E;AACA,yE;AACA,0E;AACA,wE;;AAEA,uE;AACA,qE;AACA,mE;;AAEA,qD;AACA,2C;AACA,mD;AACA,qD;AACA,gB;AACA,gB;AACA,gB;AACA,gB;AACA,gB;AACA,mC;AACA,iD;AACA,uE;;AAEA,sC;AACA,qC;;AAEA,uB;AACA,G;;AAEA,kD;AACA,mD;;AAEA,sB;AACA,oB;AACA,K;AACA,gE;AACA,yB;AACA,2B;AACA,qE;AACA,0D;;AAEA,8B;AACA,oE;AACA,sE;AACA,Y;AACA,yD;AACA,K;AACA,uC;AACA,8D;;AAEA,wB;AACA,wD;AACA,2D;;;AAGA,8D;AACA,uB;AACA,mC;AACA,2C;AACA,qD;AACA,W;AACA,e;AACA,gB;AACA,gB;AACA,e;AACA,uC;AACA,uD;AACA,6E;;AAEA,W;AACA,8B;AACA,wB;AACA,iD;AACA,kC;;AAEA,sC;;AAEA,e;;AAEA,8B;AACA,kC;AACA,4B;;AAEA,kB;AACA,G;;AAEA,kC;AACA,iE;AACA,iE;AACA,iE;AACA,iE;AACA,iE;AACA,iE;AACA,iE;AACA,iE;AACA,iE;AACA,iE;AACA,iE;AACA,iE;AACA,iE;AACA,iE;AACA,iE;AACA,kE;;AAEA,oC;AACA,iE;AACA,iE;AACA,iE;AACA,iE;AACA,iE;AACA,iE;AACA,kE;;AAEA,0B;;AAEA,4B;AACA,mB;;AAEA,iB;AACA,2B;AACA,yB;AACA,mB;AACA,qB;;AAEA,2B;AACA,uE;AACA,6E;AACA,oE;AACA,2B;;AAEA,mB;AACA,kB;AACA,0B;AACA,8E;AACA,oE;AACA,sE;AACA,yE;AACA,mE;;AAEA,yB;AACA,G;;AAEA,0E;AACA,wB;AACA,sB;AACA,K;AACA,mE;;AAEA,yB;AACA,2B;AACA,qE;AACA,0D;;AAEA,4B;AACA,kB;AACA,oB;AACA,mD;AACA,gC;AACA,uB;AACA,4E;AACA,oE;AACA,gB;AACA,yB;AACA,4C;AACA,gB;AACA,O;AACA,K;AACA,oB;AACA,6C;AACA,2C;AACA,+D;AACA,+B;AACA,mD;AACA,sE;AACA,4B;AACA,uB;AACA,2C;AACA,wC;AACA,gD;AACA,wC;AACA,4D;AACA,gE;AACA,wE;AACA,gE;AACA,oE;AACA,6D;AACA,iE;AACA,gE;AACA,wE;AACA,wE;AACA,gE;AACA,oE;AACA,oE;AACA,6D;AACA,iE;AACA,iE;;AAEA,sD;AACA,sD;AACA,sD;AACA,sD;AACA,0D;AACA,8D;AACA,sD;AACA,uD;AACA,uD;AACA,uD;AACA,uD;AACA,uD;AACA,0D;AACA,8D;AACA,8D;AACA,2B;AACA,2B;AACA,a;AACA,W;AACA,gB;AACA,yB;AACA,wD;AACA,8C;AACA,sD;AACA,8C;AACA,sD;AACA,sD;AACA,wB;AACA,wB;AACA,W;AACA,gB;AACA,O;AACA,K;;AAEA,W;AACA,0B;AACA,uE;AACA,mD;AACA,Y;AACA,gC;AACA,K;AACA,kC;;AAEA,yC;AACA,iD;AACA,2D;AACA,uD;AACA,6E;;AAEA,yC;AACA,iD;AACA,2D;AACA,oD;AACA,2E;AACA,iC;;AAEA,sE;AACA,yE;;AAEA,0C;;AAEA,e;;AAEA,kC;AACA,kC;;AAEA,kB;AACA,G;;AAEA,sB;AACA,0C;AACA,kC;AACA,mC;AACA,K;AACA,8C;AACA,oC;AACA,qC;AACA,K;AACA,sB;AACA,wB;AACA,G;;AAEA,U;AACA,qB;AACA,+B;AACA,qB;AACA,O;AACA,0B;AACA,W;AACA,qB;AACA,8B;AACA,qB;AACA,gD;AACA,M;AACA,+B;AACA,6B;AACA,kB;AACA,I;AACA,K;;;AAGA,oB;;AAEA,0B;AACA,4C;AACA,sB;AACA,4B;AACA,oB;AACA,oB;AACA,oB;AACA,oB;AACA,Y;AACA,sB;AACA,wD;AACA,iB;AACA,+B;AACA,sE;AACA,uC;AACA,8E;AACA,S;;AAEA,8D;AACA,gC;AACA,wC;AACA,S;AACA,oB;AACA,O;AACA,M;AACA,G;AACA,E;;AAEA,4D;AACA,gE;AACA,kE;AACA,yD;AACA,oD;AACA,Y;AACA,0C;AACA,+D;AACA,K;AACA,0C;AACA,+D;AACA,K;AACA,0C;AACA,+D;AACA,K;AACA,6D;AACA,iE;AACA,6D;AACA,iE;AACA,6D;AACA,iE;AACA,mB;AACA,a;AACA,K;AACA,qE;AACA,qE;AACA,qE;;AAEA,qD;AACA,0B;AACA,0B;AACA,U;AACA,wC;AACA,mB;AACA,8D;AACA,gC;AACA,oC;AACA,oC;AACA,oC;AACA,c;AACA,8D;AACA,gC;AACA,oC;AACA,oC;AACA,oC;AACA,O;AACA,yD;AACA,8B;AACA,kC;AACA,kC;AACA,kC;AACA,6C;AACA,6C;AACA,oC;AACA,wC;AACA,iC;AACA,sC;AACA,iD;AACA,iD;AACA,iD;AACA,yB;AACA,O;AACA,K;AACA,G;;AAEA,8C;AACA,2B;AACA,2B;AACA,c;AACA,0B;AACA,qB;AACA,mD;AACA,8D;AACA,sC;AACA,oC;AACA,qC;AACA,+C;AACA,uC;AACA,uD;AACA,wD;AACA,uC;AACA,4E;AACA,6E;AACA,W;AACA,S;AACA,c;AACA,uB;AACA,qD;AACA,qC;AACA,wC;AACA,yC;AACA,S;AACA,c;AACA,c;AACA,gC;AACA,c;AACA,K;AACA,G;;AAEA,2E;AACA,8C;AACA,2E;AACA,4B;AACA,6B;AACA,uD;AACA,iE;;AAEA,wC;AACA,wC;AACA,qD;AACA,sD;;AAEA,4E;AACA,0C;AACA,8E;AACA,0C;AACA,qC;AACA,uC;;AAEA,mB;AACA,qB;AACA,qB;AACA,wB;AACA,wB;AACA,yB;AACA,wB;AACA,M;;AAEA,iC;AACA,+B;AACA,qE;AACA,wD;;AAEA,4D;AACA,yE;AACA,gD;AACA,gC;AACA,Y;AACA,yE;AACA,qC;;AAEA,uD;AACA,4B;AACA,8B;AACA,wD;AACA,wC;AACA,4C;AACA,4C;AACA,6B;AACA,S;AACA,O;AACA,4C;AACA,8C;AACA,O;AACA,sC;AACA,gC;AACA,K;;AAEA,+D;AACA,4C;AACA,G;AACA,0B;AACA,K;;AAEA,mB;AACA,qC;AACA,wB;AACA,wB;AACA,wB;AACA,yB;AACA,wB;AACA,wB;AACA,wB;AACA,4B;AACA,Y;AACA,sB;AACA,qE;AACA,kB;AACA,0B;AACA,8E;AACA,gB;AACA,wE;AACA,0E;AACA,uB;AACA,yE;AACA,+C;AACA,gD;AACA,W;AACA,S;;;AAGA,4E;AACA,2B;AACA,4E;AACA,4D;;AAEA,2B;AACA,2D;AACA,uB;AACA,6C;AACA,W;AACA,S;;AAEA,qD;AACA,sD;AACA,gD;AACA,iD;;AAEA,6E;AACA,O;AACA,M;AACA,G;AACA,E;;AAEA,oB;AACA,mC;AACA,Y;AACA,sB;AACA,sD;AACA,yB;AACA,O;AACA,M;AACA,G;AACA,E;;AAEA,uC;AACA,qC;AACA,mB;AACA,wC;AACA,G;AACA,+B;AACA,C;;AAEA,sD;AACA,mB;AACA,e;AACA,gB;AACA,I;;AAEA,+D;;AAEA,2E;AACA,8B;AACA,8C;AACA,sB;AACA,uB;AACA,uB;AACA,2B;AACA,4B;AACA,uB;AACA,qB;AACA,iC;AACA,uC;AACA,0B;AACA,mB;AACA,G;;AAEA,6B;AACA,2E;AACA,2C;AACA,2B;AACA,6B;AACA,6B;AACA,qC;AACA,uC;AACA,6B;AACA,2B;AACA,uC;;AAEA,wC;;AAEA,iE;;AAEA,6B;AACA,2D;AACA,8C;;AAEA,2C;AACA,4C;;AAEA,oE;AACA,wE;AACA,8D;AACA,4B;AACA,8D;AACA,4C;;AAEA,yD;AACA,6E;AACA,8E;AACA,0D;AACA,qE;AACA,0B;;AAEA,uE;AACA,0B;;AAEA,+E;AACA,qC;AACA,kE;AACA,6C;;AAEA,oE;;AAEA,iD;AACA,sC;;AAEA,+C;AACA,gE;AACA,uD;;AAEA,oD;;AAEA,iD;AACA,8B;AACA,M;;AAEA,4E;AACA,mD;AACA,M;;AAEA,yE;AACA,6B;AACA,sD;AACA,mD;AACA,M;;AAEA,6D;AACA,6B;AACA,iD;AACA,M;;AAEA,iE;AACA,uD;AACA,gC;AACA,iC;AACA,yD;AACA,wB;AACA,2B;AACA,O;AACA,M;;AAEA,mC;AACA,0E;AACA,4B;AACA,iC;AACA,+B;AACA,8C;AACA,kD;AACA,kB;AACA,mC;AACA,yE;AACA,yC;AACA,2C;AACA,kB;AACA,kB;AACA,0D;AACA,S;AACA,Q;;AAEA,+D;AACA,mE;;AAEA,qB;AACA,sD;AACA,4C;AACA,4B;;AAEA,iE;AACA,K;AACA,I;;AAEA,uB;AACA,K;;;AAGA,8B;;AAEA,kB;AACA,mD;AACA,uE;AACA,wB;AACA,qD;AACA,+C;AACA,2E;AACA,sB;AACA,K;;AAEA,wC;AACA,4D;AACA,I;;AAEA,qC;AACA,uE;AACA,uB;AACA,wD;AACA,K;AACA,2D;AACA,4C;AACA,O;AACA,oC;AACA,I;AACA,sB;AACA,8E;AACA,c;AACA,6C;AACA,gF;AACA,gF;AACA,gF;AACA,gF;AACA,gF;AACA,gF;AACA,gF;AACA,gF;AACA,gF;AACA,gF;AACA,gF;AACA,gF;AACA,gF;AACA,gF;AACA,gF;AACA,gF;AACA,gF;AACA,gF;AACA,gF;AACA,gF;AACA,gF;AACA,kC;AACA,O;AACA,I;;AAEA,oB;;AAEA,mB;AACA,iB;AACA,oB;AACA,I;;AAEA,wE;AACA,mB;AACA,mB;AACA,K;;AAEA,8E;AACA,gE;AACA,+C;AACA,+D;AACA,0B;AACA,kB;AACA,K;AACA,0B;AACA,+B;AACA,kB;AACA,K;AACA,iB;AACA,O;;AAEA,sB;;AAEA,6E;AACA,gD;;AAEA,4E;AACA,8C;AACA,uC;AACA,I;;AAEA,kD;AACA,iE;;AAEA,mB;AACA,yB;AACA,8B;AACA,qD;AACA,0B;;AAEA,8D;AACA,2B;AACA,oD;AACA,iB;AACA,O;AACA,2B;;AAEA,2C;AACA,yD;AACA,6B;AACA,uD;AACA,S;AACA,c;AACA,kC;AACA,mB;AACA,2B;AACA,iC;AACA,S;AACA,O;AACA,K;;AAEA,4D;AACA,yC;AACA,gD;AACA,2B;AACA,S;AACA,sE;AACA,mE;AACA,Y;AACA,yB;AACA,K;AACA,I;;AAEA,4E;AACA,2C;AACA,uE;AACA,+B;;AAEA,qE;AACA,sE;AACA,oD;AACA,6C;AACA,O;AACA,K;;AAEA,4C;AACA,sE;AACA,mB;AACA,oB;AACA,2C;AACA,yB;AACA,yB;AACA,M;AACA,mC;AACA,mB;AACA,I;;AAEA,sE;AACA,sE;AACA,0E;AACA,uB;AACA,+E;AACA,iE;AACA,2E;AACA,2E;AACA,mB;;AAEA,oC;AACA,gD;AACA,oD;AACA,mD;AACA,oD;AACA,O;;AAEA,wD;AACA,yC;AACA,+C;AACA,wC;AACA,O;;AAEA,gB;;AAEA,oD;AACA,uB;AACA,wB;AACA,wC;;AAEA,qB;AACA,4C;AACA,iB;AACA,uE;AACA,yB;AACA,+C;AACA,qB;AACA,iB;AACA,S;AACA,kC;AACA,iC;AACA,qD;AACA,oC;AACA,qB;AACA,iB;AACA,S;AACA,2D;AACA,O;;AAEA,qE;AACA,+E;AACA,+E;AACA,2B;AACA,+E;AACA,4E;AACA,mC;AACA,8E;AACA,sE;AACA,0C;AACA,uD;AACA,mC;AACA,mE;AACA,sD;AACA,mE;AACA,0E;AACA,O;AACA,mE;AACA,2C;AACA,0D;AACA,O;AACA,4E;;AAEA,qE;AACA,2E;AACA,2B;AACA,kC;;AAEA,qB;AACA,mD;AACA,wC;AACA,O;AACA,iC;;AAEA,8C;AACA,+B;AACA,8C;AACA,qD;AACA,mE;AACA,mD;AACA,kD;AACA,gC;AACA,yC;AACA,8B;AACA,O;AACA,qC;;AAEA,8C;AACA,uC;AACA,2B;AACA,S;AACA,qB;AACA,G;AACA,E;;AAEA,wD;AACA,mD;AACA,6B;AACA,iC;AACA,kC;AACA,8B;AACA,2B;AACA,0B;AACA,O;AACA,a;AACA,K;AACA,G;AACA,8B;AACA,0E;AACA,uB;AACA,oB;AACA,O;;AAEA,kC;AACA,oC;AACA,oB;AACA,O;;AAEA,wE;;AAEA,mD;;AAEA,2D;AACA,iD;AACA,qD;AACA,O;AACA,4B;AACA,M;;AAEA,gD;AACA,uB;AACA,oB;AACA,O;;AAEA,kC;AACA,oC;AACA,oB;AACA,O;;AAEA,0D;AACA,qC;;AAEA,+C;AACA,2D;AACA,2C;AACA,gF;AACA,kC;;AAEA,2D;AACA,iD;AACA,0D;AACA,O;;AAEA,kB;AACA,M;;AAEA,6E;AACA,gD;AACA,kE;AACA,yB;AACA,uE;AACA,O;AACA,4C;AACA,K;AACA,I;AACA,wB;AACA,K;;;AAGA,8B;;AAEA,0D;AACA,yE;AACA,kD;;AAEA,8B;AACA,0C;AACA,4D;;AAEA,mB;AACA,a;AACA,K;;AAEA,sC;AACA,0C;AACA,yC;AACA,2D;;AAEA,sC;AACA,4D;AACA,2E;AACA,uE;AACA,iD;AACA,G;;AAEA,4C;AACA,sD;AACA,iC;AACA,4C;AACA,6C;;AAEA,uC;AACA,iB;AACA,iC;AACA,mC;AACA,yC;AACA,6B;AACA,gC;AACA,qC;AACA,wE;AACA,wE;AACA,yE;AACA,O;AACA,K;AACA,gC;AACA,kC;AACA,qB;AACA,G;;AAEA,oE;AACA,gD;AACA,4C;AACA,6C;AACA,uC;AACA,yC;AACA,oC;;AAEA,gD;AACA,0C;AACA,2C;AACA,yE;AACA,2C;AACA,yC;;AAEA,oC;AACA,kD;AACA,0C;;AAEA,iC;;AAEA,mB;AACA,G;;AAEA,kD;AACA,yB;;AAEA,iD;AACA,+C;AACA,yC;AACA,K;AACA,+C;AACA,gE;AACA,K;;AAEA,+C;AACA,sC;;AAEA,+C;AACA,gD;AACA,8C;AACA,6B;AACA,0D;AACA,sC;AACA,wC;AACA,kD;AACA,8D;;AAEA,uD;AACA,yD;AACA,yE;AACA,uC;;AAEA,gD;AACA,2C;AACA,yC;;AAEA,c;AACA,0B;AACA,6B;;AAEA,kC;AACA,mC;AACA,+D;AACA,+D;AACA,+D;AACA,oE;AACA,oE;AACA,qE;AACA,K;;AAEA,6C;AACA,2C;AACA,mC;;AAEA,uC;AACA,2C;AACA,Y;AACA,6C;AACA,qD;AACA,mD;AACA,4B;AACA,qD;AACA,2B;AACA,sD;AACA,S;AACA,O;AACA,0B;;AAEA,yB;;AAEA,yD;AACA,kB;AACA,wB;AACA,S;AACA,6C;AACA,sC;AACA,4C;AACA,S;AACA,Q;;AAEA,2D;AACA,oB;AACA,yB;AACA,S;AACA,yD;AACA,sC;AACA,+C;AACA,S;AACA,Q;;AAEA,0D;AACA,qB;AACA,+B;AACA,gB;AACA,+B;AACA,S;AACA,Q;;AAEA,qE;AACA,2B;AACA,gB;AACA,6E;AACA,yB;AACA,gB;AACA,2E;AACA,yB;AACA,gB;;AAEA,yE;AACA,6B;AACA,gB;AACA,K;;AAEA,+B;AACA,8B;AACA,wC;AACA,iC;AACA,0C;;AAEA,qB;AACA,G;;AAEA,kD;AACA,8C;AACA,sC;;AAEA,2C;AACA,4C;AACA,yD;AACA,6B;AACA,K;;AAEA,gC;;AAEA,qB;AACA,G;;AAEA,uC;AACA,kC;AACA,iC;AACA,iE;AACA,+B;AACA,qD;AACA,+B;AACA,qD;AACA,c;AACA,8E;AACA,K;AACA,G;;AAEA,U;AACA,kC;AACA,I;AACA,K;AACA,wC;;;AAGA,oB;AACA,sB;AACA,uB;AACA,sB;AACA,E;;AAEA,kE;AACA,kB;AACA,qE;;AAEA,8B;;AAEA,qC;AACA,iC;AACA,c;AACA,iC;AACA,kB;AACA,iD;AACA,c;AACA,kC;AACA,O;AACA,K;AACA,oB;AACA,G;;AAEA,oC;AACA,iB;AACA,uC;AACA,qC;AACA,0B;AACA,4B;AACA,K;AACA,oB;AACA,G;;AAEA,oD;AACA,mB;AACA,0B;;AAEA,+B;AACA,mC;AACA,kC;AACA,6B;AACA,W;;AAEA,wC;AACA,4C;AACA,4C;AACA,4C;AACA,W;;AAEA,sB;AACA,qB;;AAEA,yC;;AAEA,+B;AACA,mC;AACA,kC;AACA,6B;AACA,G;;AAEA,sC;AACA,c;AACA,c;AACA,uC;AACA,yC;AACA,0B;AACA,K;AACA,yB;AACA,G;;AAEA,kC;AACA,8B;AACA,gC;AACA,sC;AACA,6B;;AAEA,mB;AACA,oC;AACA,sB;AACA,qB;AACA,oC;AACA,c;AACA,+B;AACA,sB;AACA,qB;AACA,6B;AACA,c;AACA,gC;AACA,sB;AACA,qB;AACA,6B;AACA,c;AACA,c;AACA,0C;AACA,K;;AAEA,wC;AACA,2D;AACA,4C;AACA,a;AACA,kC;AACA,sD;AACA,uE;AACA,mC;AACA,8B;AACA,iC;AACA,K;;AAEA,4C;AACA,0B;AACA,yB;AACA,oC;AACA,+C;AACA,wC;AACA,6C;AACA,S;AACA,O;AACA,K;;AAEA,+B;AACA,yB;AACA,yB;AACA,wB;AACA,mB;AACA,0B;AACA,0B;AACA,yB;AACA,oB;AACA,4B;AACA,8B;AACA,iC;AACA,4B;AACA,8B;AACA,O;;AAEA,8B;AACA,gC;;AAEA,wD;AACA,+D;AACA,e;AACA,sD;AACA,+B;;AAEA,gB;AACA,kC;AACA,oE;AACA,wB;AACA,wB;AACA,wB;AACA,wB;AACA,wB;AACA,iE;AACA,2B;AACA,4B;AACA,4B;AACA,K;;AAEA,8C;AACA,sB;AACA,4B;AACA,iC;AACA,wC;AACA,6C;AACA,yC;AACA,gC;;AAEA,kE;AACA,oC;AACA,oC;AACA,mC;AACA,8B;;AAEA,iE;AACA,kE;AACA,8C;AACA,yC;AACA,mB;AACA,iC;AACA,gC;AACA,8C;AACA,+C;AACA,+C;AACA,+C;AACA,2D;;AAEA,oD;AACA,G;;AAEA,gD;AACA,4C;AACA,yD;AACA,iC;AACA,I;AACA,K;;AAEA,sD;AACA,4B;AACA,2B;AACA,8C;AACA,sB;;AAEA,sC;AACA,2C;AACA,qB;;AAEA,0C;AACA,e;AACA,e;;AAEA,+C;AACA,mB;AACA,mB;;AAEA,iC;AACA,yB;AACA,yB;AACA,wB;AACA,sB;;AAEA,+C;AACA,4C;AACA,iC;;AAEA,uB;AACA,yB;AACA,uB;AACA,uB;AACA,sB;AACA,wB;;AAEA,wB;AACA,uB;;AAEA,2B;;AAEA,e;AACA,qB;AACA,6B;;AAEA,qB;AACA,G;;AAEA,6B;AACA,2C;AACA,iC;AACA,M;AACA,mE;AACA,iB;AACA,iB;AACA,K;AACA,I;AACA,uB;AACA,K;;AAEA,kD;AACA,4C;AACA,0C;AACA,sD;AACA,+C;AACA,oD;AACA,sD;AACA,uE;AACA,e;AACA,G;;AAEA,iC;AACA,oB;AACA,iB;AACA,kC;;AAEA,yC;AACA,oC;AACA,8D;AACA,yB;AACA,iD;AACA,iB;AACA,O;;AAEA,sC;AACA,2B;AACA,c;AACA,+B;AACA,O;AACA,K;AACA,kB;AACA,G;;AAEA,K;AACA,0B;AACA,4C;AACA,sB;AACA,K;AACA,sB;AACA,kD;AACA,8B;AACA,K;AACA,8B;AACA,yB;AACA,uB;AACA,e;AACA,K;AACA,8B;AACA,Q;AACA,U;AACA,2B;AACA,iD;AACA,G;;AAEA,K;AACA,yE;AACA,0E;AACA,6C;AACA,uC;AACA,sB;AACA,K;AACA,kB;AACA,mC;AACA,qC;AACA,uC;AACA,oB;AACA,S;AACA,0D;AACA,O;AACA,4C;AACA,gD;AACA,uC;AACA,O;AACA,Y;AACA,iE;AACA,8D;AACA,O;AACA,K;AACA,yE;AACA,uD;AACA,G;;AAEA,0C;AACA,uC;AACA,oE;AACA,6B;AACA,yB;AACA,iC;AACA,qB;AACA,+B;;AAEA,4B;AACA,4B;AACA,yB;AACA,G;;AAEA,wC;AACA,sD;AACA,gD;AACA,oD;AACA,qD;AACA,oB;AACA,oB;;AAEA,2B;AACA,uC;AACA,qD;AACA,6B;AACA,gC;AACA,iC;AACA,M;;AAEA,6C;AACA,uD;AACA,2C;;AAEA,wD;AACA,4E;AACA,uC;AACA,M;;AAEA,8C;AACA,kB;AACA,gC;AACA,qB;AACA,M;;AAEA,2E;AACA,yC;AACA,sC;AACA,6C;;AAEA,sB;AACA,4C;AACA,4C;AACA,kC;AACA,0D;AACA,8B;AACA,sD;AACA,wB;AACA,yB;AACA,uD;AACA,kD;AACA,iB;AACA,oB;AACA,uD;AACA,4C;AACA,iB;AACA,a;AACA,oD;AACA,W;AACA,S;AACA,O;AACA,oD;AACA,M;;AAEA,iE;AACA,+C;AACA,uE;AACA,mE;;AAEA,wD;AACA,4E;AACA,M;;AAEA,iE;AACA,mE;AACA,+B;;AAEA,mE;AACA,+C;AACA,0E;AACA,4E;AACA,6E;AACA,8E;AACA,6D;AACA,yC;AACA,yC;AACA,wC;AACA,sD;AACA,mC;AACA,wB;AACA,oB;AACA,M;;AAEA,qE;AACA,6C;AACA,yC;AACA,uC;AACA,sB;AACA,sB;;AAEA,2B;AACA,6B;AACA,O;;AAEA,4C;AACA,8B;AACA,+E;AACA,O;AACA,kC;AACA,M;;AAEA,+D;AACA,oC;AACA,0C;AACA,8B;AACA,kC;AACA,kC;;AAEA,2B;AACA,6B;AACA,6B;AACA,kB;AACA,8B;AACA,kC;AACA,kB;AACA,sC;AACA,sD;AACA,kB;AACA,2B;AACA,+B;AACA,kB;AACA,4B;AACA,mC;AACA,kB;AACA,kC;AACA,mC;AACA,kB;AACA,2B;AACA,2B;AACA,kB;AACA,4B;AACA,4C;AACA,kB;AACA,kC;AACA,yC;AACA,kB;AACA,kC;AACA,yC;AACA,kB;AACA,6B;AACA,oC;AACA,kB;AACA,iC;AACA,yD;AACA,0D;AACA,kB;AACA,gC;AACA,uC;AACA,kB;AACA,+B;AACA,sC;AACA,kB;AACA,8B;AACA,qC;AACA,kB;AACA,iC;AACA,wC;AACA,kB;AACA,mC;AACA,4D;AACA,kB;AACA,qC;AACA,8D;AACA,kB;AACA,2B;AACA,2C;AACA,kB;AACA,6B;AACA,oC;AACA,kB;AACA,wB;AACA,wB;AACA,kB;AACA,0B;AACA,0B;AACA,kB;AACA,0B;AACA,0B;AACA,kB;AACA,8B;AACA,8B;AACA,kB;AACA,gC;AACA,gC;AACA,kB;AACA,wB;AACA,iC;AACA,kB;AACA,0B;AACA,iC;AACA,kB;AACA,4C;AACA,4C;AACA,kB;AACA,oC;AACA,6D;AACA,kB;AACA,qC;AACA,4C;AACA,kB;AACA,2C;AACA,kD;AACA,kB;AACA,yC;AACA,gD;AACA,kB;AACA,yC;AACA,yD;AACA,kB;AACA,uC;AACA,uC;AACA,kB;AACA,6B;AACA,6B;AACA,kB;AACA,+B;AACA,+B;AACA,kB;AACA,mC;AACA,mC;AACA,kB;AACA,4B;AACA,4B;AACA,kB;AACA,6B;AACA,8D;AACA,6C;AACA,kB;AACA,iC;AACA,iD;AACA,kB;AACA,2B;AACA,2B;AACA,kB;AACA,kB;AACA,wC;AACA,kB;AACA,kB;AACA,8C;AACA,kB;AACA,S;AACA,O;AACA,M;;AAEA,sE;AACA,6C;AACA,M;;AAEA,sE;AACA,6C;AACA,M;;AAEA,+C;AACA,6C;AACA,M;;AAEA,yE;AACA,iC;AACA,6E;;AAEA,8C;AACA,8C;;AAEA,2B;AACA,gE;AACA,4E;AACA,qD;AACA,gE;AACA,8D;;AAEA,oE;AACA,oD;AACA,M;;AAEA,iD;AACA,8C;AACA,8C;AACA,gD;AACA,gD;AACA,qE;AACA,yE;AACA,kE;AACA,gC;AACA,M;;AAEA,mD;AACA,iC;AACA,+C;AACA,+C;;AAEA,2B;AACA,gE;AACA,4E;AACA,qD;AACA,gE;AACA,8D;AACA,M;;AAEA,qD;AACA,iC;AACA,8B;AACA,sC;;AAEA,2B;AACA,e;AACA,O;;AAEA,4C;AACA,4C;AACA,gD;AACA,0D;AACA,uC;AACA,mC;AACA,+D;;AAEA,mB;AACA,0C;AACA,8B;AACA,6B;AACA,uB;AACA,2C;AACA,mB;AACA,kC;AACA,yC;AACA,mB;AACA,S;AACA,yD;;AAEA,gC;AACA,uC;AACA,gF;AACA,uB;;AAEA,+C;AACA,O;AACA,qB;AACA,oC;AACA,c;AACA,oC;AACA,O;;AAEA,6C;AACA,sE;AACA,8D;AACA,4E;AACA,qD;AACA,gE;AACA,yD;AACA,4E;AACA,O;AACA,2D;AACA,8E;AACA,O;AACA,yD;AACA,sE;AACA,O;;AAEA,0D;AACA,gE;AACA,0D;AACA,yE;AACA,oD;AACA,qD;;AAEA,gD;;AAEA,M;;AAEA,uE;AACA,0B;AACA,0B;AACA,M;;AAEA,8D;AACA,2B;AACA,kE;AACA,+D;AACA,6C;AACA,O;;AAEA,sE;AACA,kC;AACA,mE;AACA,sC;AACA,M;;AAEA,oD;AACA,iC;AACA,oD;AACA,4B;AACA,kC;;AAEA,4C;AACA,oD;AACA,mC;AACA,yD;AACA,O;;AAEA,gD;AACA,uE;;AAEA,qE;AACA,oE;AACA,wD;;AAEA,qB;AACA,qB;AACA,mC;AACA,c;AACA,kC;AACA,O;AACA,8B;AACA,8C;AACA,gC;AACA,iC;;AAEA,gE;AACA,8D;AACA,2B;AACA,M;;AAEA,6C;AACA,qC;AACA,yC;AACA,yC;AACA,c;AACA,yC;AACA,O;AACA,wD;AACA,4E;AACA,M;;AAEA,sB;AACA,4D;AACA,qC;AACA,M;AACA,wD;AACA,oD;AACA,M;AACA,0D;AACA,sD;AACA,M;AACA,8D;AACA,sC;AACA,M;AACA,wE;AACA,2C;AACA,uC;AACA,M;AACA,oE;AACA,2C;AACA,qC;AACA,qE;AACA,gC;AACA,M;AACA,iE;AACA,yC;AACA,yC;AACA,M;;AAEA,kE;AACA,iC;AACA,uC;AACA,8D;AACA,iB;AACA,gC;;AAEA,iD;AACA,6B;AACA,6B;AACA,0B;AACA,0B;AACA,kC;AACA,mC;AACA,+B;AACA,gC;AACA,+E;AACA,4C;AACA,kB;AACA,0B;AACA,0B;AACA,0B;AACA,sC;AACA,kB;AACA,0B;AACA,0B;AACA,0B;AACA,uC;AACA,kB;AACA,2B;AACA,4B;AACA,4B;AACA,sE;AACA,kD;AACA,mB;AACA,kB;AACA,4B;AACA,4B;AACA,4B;AACA,mE;AACA,qD;AACA,mB;AACA,kB;AACA,4B;AACA,4B;AACA,4B;AACA,mE;AACA,iC;AACA,mB;AACA,kB;AACA,6B;AACA,wB;AACA,kB;AACA,S;AACA,O;AACA,0D;AACA,4D;AACA,0D;AACA,2E;AACA,6E;AACA,uD;AACA,gE;AACA,2D;AACA,uE;AACA,4D;AACA,gE;AACA,wD;;AAEA,0C;AACA,gC;AACA,yC;AACA,yC;AACA,c;AACA,yC;AACA,O;AACA,0E;AACA,+B;AACA,qC;AACA,oC;AACA,M;;AAEA,6C;AACA,iC;AACA,gC;AACA,yC;AACA,yC;AACA,c;AACA,yC;AACA,O;AACA,wD;AACA,4E;AACA,M;;AAEA,2C;AACA,iC;AACA,0C;AACA,8C;AACA,kB;AACA,mE;AACA,+D;AACA,oD;AACA,+B;AACA,iE;AACA,c;AACA,iE;AACA,O;AACA,gF;AACA,6C;AACA,2C;;AAEA,+C;AACA,iC;AACA,wD;AACA,iD;AACA,+D;AACA,uC;AACA,M;;AAEA,iD;AACA,iC;AACA,qD;AACA,e;AACA,gD;AACA,M;;AAEA,0D;AACA,sC;AACA,M;;AAEA,6D;AACA,uC;AACA,M;;AAEA,sD;AACA,4C;AACA,M;;AAEA,uD;AACA,wD;AACA,8B;AACA,2B;AACA,6B;;AAEA,sB;AACA,oB;AACA,qC;AACA,kB;AACA,oB;AACA,mC;AACA,kB;AACA,oB;AACA,oC;AACA,kB;AACA,oB;AACA,sC;AACA,kB;AACA,mB;AACA,6C;AACA,kB;AACA,oB;AACA,kB;AACA,oB;AACA,kB;AACA,sB;AACA,gC;AACA,kB;AACA,oB;AACA,kB;AACA,oB;AACA,kB;AACA,oB;AACA,kB;AACA,uB;AACA,kB;AACA,S;AACA,O;AACA,M;;AAEA,uC;AACA,iC;AACA,sE;AACA,M;;AAEA,2C;AACA,iC;AACA,0E;AACA,2D;AACA,M;;AAEA,2C;AACA,iC;AACA,sE;AACA,mE;AACA,M;;AAEA,mD;AACA,+D;AACA,mE;AACA,oB;AACA,kB;AACA,M;;AAEA,uD;AACA,wE;AACA,wB;AACA,M;;AAEA,qD;AACA,uB;AACA,oB;AACA,M;;AAEA,6D;AACA,uB;AACA,wB;AACA,M;;AAEA,6B;AACA,yD;AACA,iC;AACA,0D;AACA,0C;AACA,0C;AACA,gD;AACA,iD;AACA,2D;AACA,kC;AACA,M;;AAEA,0E;AACA,iC;AACA,wC;AACA,4D;AACA,+D;AACA,+D;AACA,iE;AACA,2C;AACA,8C;AACA,6C;AACA,0E;;AAEA,mC;AACA,gC;AACA,yC;AACA,yC;AACA,c;AACA,yC;AACA,O;AACA,M;;AAEA,sE;AACA,yC;AACA,qB;AACA,iD;AACA,e;AACA,O;AACA,4C;AACA,M;;AAEA,4B;AACA,qE;AACA,iC;AACA,gC;AACA,kC;;AAEA,gD;AACA,8D;AACA,8C;AACA,8C;AACA,wD;AACA,0D;AACA,iC;AACA,2B;AACA,4D;AACA,2D;AACA,2C;AACA,mD;AACA,4D;AACA,8D;AACA,6C;AACA,2D;AACA,kD;AACA,iB;AACA,gC;AACA,c;AACA,qC;AACA,O;AACA,gC;AACA,yC;AACA,yC;AACA,c;AACA,yC;AACA,O;AACA,M;;AAEA,0B;AACA,6D;AACA,iC;AACA,gC;AACA,kC;AACA,wC;;AAEA,4C;AACA,0D;AACA,sD;;AAEA,0D;AACA,0C;AACA,0C;AACA,oD;AACA,sD;AACA,mD;AACA,uE;AACA,kC;AACA,kC;;AAEA,kD;AACA,M;;AAEA,0B;AACA,kE;AACA,kB;;AAEA,mD;AACA,uD;AACA,wD;AACA,O;;AAEA,+C;AACA,sC;AACA,uC;;AAEA,gE;AACA,oD;AACA,oD;AACA,0D;AACA,4D;AACA,wC;AACA,6B;AACA,uB;AACA,O;AACA,M;;AAEA,wB;AACA,oD;AACA,qB;AACA,K;AACA,I;AACA,qB;AACA,K;;AAEA,gC;;;AAGA,yD;;AAEA,0D;AACA,6E;AACA,kC;AACA,iB;AACA,6C;AACA,sE;AACA,oD;AACA,gE;AACA,O;AACA,C;;;;;;;;;;;;;;;;;;;;;AC30PA,gF;AACA,mE;AACA,oC;AACA,E;AACA,kE;AACA,mE;AACA,0C;AACA,E;AACA,iD;AACA,E;AACA,sE;AACA,oE;AACA,2E;AACA,sE;AACA,iC;AACA,G;AACA,4B;;AAEA,a;;AAEA,8E;AACA,4C;AACA,mC;AACA,6D;AACA,C;;AAEA,6C;AACA,kD;AACA,0C;AACA,0C;AACA,uB;AACA,+D;AACA,uE;AACA,wD;AACA,U;AACA,yE;AACA,0D;AACA,U;AACA,K;;AAEA,2B;AACA,8C;AACA,yC;AACA,K;AACA,W;AACA,G;;AAEA,iC;AACA,kD;AACA,G;;AAEA,0C;AACA,+B;AACA,iB;AACA,K;AACA,6D;AACA,qC;AACA,K;AACA,G;;AAEA,6B;AACA,qB;AACA,mC;AACA,kB;AACA,kC;AACA,sB;AACA,O;AACA,iC;AACA,6B;AACA,Y;AACA,kB;AACA,gD;AACA,4B;AACA,O;AACA,K;;AAEA,+B;AACA,2B;AACA,sC;AACA,gC;;AAEA,kD;AACA,kC;AACA,K;AACA,kB;AACA,G;;AAEA,iC;AACA,gC;;AAEA,+D;AACA,yC;AACA,kC;AACA,iC;AACA,kC;AACA,mC;AACA,mC;AACA,K;;AAEA,yB;AACA,kC;AACA,gC;AACA,oB;AACA,kC;AACA,G;AACA,K;;AAEA,2B;AACA,mC;AACA,oD;AACA,qD;AACA,sC;AACA,S;AACA,+E;AACA,sD;AACA,kE;AACA,oE;AACA,oC;AACA,wC;AACA,6C;AACA,8E;AACA,iB;AACA,qC;AACA,K;AACA,iC;AACA,a;AACA,K;AACA,G;;AAEA,yE;AACA,qB;AACA,uB;AACA,6C;AACA,K;AACA,uB;AACA,6C;AACA,K;AACA,yB;AACA,6E;AACA,2E;AACA,uB;AACA,W;AACA,qB;AACA,S;AACA,4B;AACA,K;AACA,I;AACA,K;;;AAGA,8B;AACA,+B;AACA,sD;AACA,8C;AACA,iC;AACA,qC;AACA,yD;AACA,oB;AACA,6D;AACA,iE;AACA,O;AACA,G;AACA,8B;AACA,W;AACA,G;;AAEA,0E;AACA,6B;;AAEA,uD;AACA,mD;AACA,0C;AACA,M;AACA,wD;AACA,wD;AACA,mC;AACA,sC;AACA,0D;AACA,sE;AACA,S;AACA,O;AACA,K;AACA,K;;AAEA,iB;AACA,uC;AACA,qD;AACA,iD;AACA,kD;AACA,0E;AACA,gB;AACA,mC;AACA,S;AACA,O;AACA,O;AACA,W;AACA,G;;AAEA,mD;AACA,+C;AACA,gD;AACA,iC;AACA,O;AACA,mC;AACA,6B;AACA,qC;AACA,+B;AACA,8C;AACA,O;AACA,2B;AACA,K;AACA,K;AACA,K;;AAEA,yC;AACA,iB;AACA,0C;AACA,yB;AACA,W;AACA,G;;AAEA,c;AACA,wE;;AAEA,4C;AACA,oB;AACA,a;AACA,kD;AACA,0C;AACA,8C;AACA,8C;AACA,yD;AACA,8D;AACA,4C;AACA,wD;AACA,wD;AACA,K;AACA,kB;AACA,I;AACA,K;;AAEA,wC;AACA,iB;AACA,0C;AACA,yB;AACA,W;AACA,G;;AAEA,+C;AACA,c;AACA,wE;AACA,kC;AACA,qC;AACA,iC;AACA,wC;AACA,K;AACA,S;AACA,uC;AACA,mD;AACA,2B;AACA,mC;AACA,kC;AACA,uD;AACA,0D;AACA,iD;AACA,0D;AACA,gF;AACA,O;AACA,+D;AACA,sC;AACA,K;AACA,kB;AACA,I;AACA,K;;AAEA,2B;AACA,gC;AACA,qD;AACA,uD;AACA,W;AACA,G;;AAEA,iE;AACA,uE;AACA,uD;AACA,wE;AACA,iC;AACA,M;AACA,iB;AACA,I;AACA,K;;AAEA,+B;AACA,0C;AACA,kC;AACA,0C;AACA,yB;AACA,sC;AACA,G;;AAEA,2D;AACA,qB;AACA,0B;AACA,6B;AACA,O;;AAEA,uB;AACA,iE;AACA,2C;AACA,yD;AACA,mB;AACA,S;AACA,mE;AACA,6B;AACA,oC;AACA,a;AACA,uC;AACA,O;;AAEA,+C;AACA,uB;AACA,wB;AACA,yB;AACA,S;AACA,qB;AACA,M;AACA,oB;AACA,K;AACA,K;;AAEA,iC;AACA,uC;AACA,oC;AACA,0C;AACA,2B;AACA,wC;AACA,G;;AAEA,uD;AACA,oC;AACA,+B;AACA,yB;AACA,mB;AACA,K;AACA,uC;AACA,2B;AACA,0B;AACA,K;AACA,+B;AACA,4B;AACA,K;AACA,uC;AACA,wB;AACA,G;;AAEA,4B;AACA,yB;AACA,kD;AACA,M;AACA,8B;AACA,0D;AACA,M;AACA,4B;AACA,kD;AACA,M;AACA,4B;AACA,iD;AACA,K;AACA,I;;AAEA,6D;AACA,qB;AACA,4B;AACA,+B;AACA,O;;AAEA,yD;AACA,kB;AACA,sB;AACA,0B;AACA,0B;AACA,S;AACA,S;AACA,iD;AACA,yB;AACA,wB;AACA,yB;AACA,S;AACA,uB;AACA,M;AACA,oB;AACA,K;AACA,K;;AAEA,8B;AACA,2D;AACA,0B;AACA,iB;AACA,uC;AACA,+B;AACA,sB;AACA,yB;AACA,2B;AACA,yB;AACA,M;AACA,wC;AACA,kD;AACA,iC;AACA,+C;AACA,oB;AACA,mC;AACA,+C;AACA,sB;AACA,kC;AACA,+C;AACA,qB;AACA,G;AACA,K;;AAEA,uC;AACA,oB;AACA,uC;AACA,kD;AACA,0D;AACA,0C;AACA,mC;AACA,8B;AACA,K;AACA,G;AACA,6B;AACA,6E;AACA,G;AACA,oD;AACA,mE;AACA,qE;AACA,G;AACA,K;;AAEA,kD;AACA,c;AACA,gC;AACA,4E;AACA,oD;AACA,wC;AACA,G;AACA,K;;AAEA,4C;AACA,oC;AACA,gC;AACA,W;AACA,G;AACA,mD;AACA,K;;AAEA,gC;AACA,sD;AACA,kD;AACA,oC;AACA,yB;AACA,gD;AACA,iE;;AAEA,6E;AACA,mD;AACA,gE;AACA,4C;AACA,yB;AACA,oC;AACA,qD;;AAEA,4E;AACA,2E;;AAEA,yD;AACA,8B;AACA,+B;AACA,G;AACA,K;;AAEA,6D;AACA,8B;AACA,sC;AACA,sE;AACA,wD;AACA,yB;AACA,6E;AACA,gC;AACA,G;AACA,K;;AAEA,mD;AACA,yC;AACA,uE;AACA,gC;AACA,sE;AACA,6D;AACA,wD;AACA,2B;AACA,S;AACA,Q;AACA,K;AACA,U;AACA,6E;AACA,0E;AACA,uC;AACA,oD;AACA,2E;AACA,4C;AACA,gE;AACA,6D;AACA,8C;AACA,8D;AACA,mE;AACA,kE;AACA,4D;AACA,yC;AACA,gE;AACA,2C;AACA,+D;AACA,K;;AAEA,mB;AACA,uE;AACA,2E;AACA,yD;AACA,oD;AACA,4C;AACA,0D;AACA,6B;AACA,W;AACA,U;AACA,yB;AACA,Q;AACA,K;AACA,G;AACA,K;;AAEA,mC;AACA,wC;AACA,gD;AACA,oC;AACA,G;;AAEA,8D;AACA,c;AACA,uE;AACA,6D;AACA,W;AACA,G;AACA,0C;AACA,W;AACA,G;AACA,gC;AACA,sC;AACA,yC;AACA,8B;AACA,K;;AAEA,uC;AACA,8D;AACA,uD;AACA,2B;AACA,U;AACA,oC;AACA,G;AACA,K;;AAEA,qE;AACA,kC;AACA,oC;AACA,oE;AACA,gD;AACA,qB;AACA,mC;AACA,G;AACA,K","file":"/packages/pascoual_pdfjs.js","sourcesContent":["/* -*- Mode: Java; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */\n/* vim: set shiftwidth=2 tabstop=2 autoindent cindent expandtab: */\n/* Copyright 2012 Mozilla Foundation\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/*jshint globalstrict: false */\n/* globals PDFJS */\n\n// Initializing PDFJS global object (if still undefined)\nif (typeof PDFJS === 'undefined') {\n  (typeof window !== 'undefined' ? window : this).PDFJS = {};\n}\n// Pascoual hack for Meteor\nif (!PDFJS)\n  PDFJS = {};\n\nPDFJS.version = '1.1.114';\nPDFJS.build = '3fd44fd';\n\n(function pdfjsWrapper() {\n  // Use strict in our context only - users might not want it\n  'use strict';\n\n/* -*- Mode: Java; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */\n/* vim: set shiftwidth=2 tabstop=2 autoindent cindent expandtab: */\n/* Copyright 2012 Mozilla Foundation\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/* globals Cmd, ColorSpace, Dict, MozBlobBuilder, Name, PDFJS, Ref, URL,\n           Promise */\n\n'use strict';\n\nvar globalScope = (typeof window === 'undefined') ? this : window;\n\nvar isWorker = (typeof window === 'undefined');\n\nvar FONT_IDENTITY_MATRIX = [0.001, 0, 0, 0.001, 0, 0];\n\nvar TextRenderingMode = {\n  FILL: 0,\n  STROKE: 1,\n  FILL_STROKE: 2,\n  INVISIBLE: 3,\n  FILL_ADD_TO_PATH: 4,\n  STROKE_ADD_TO_PATH: 5,\n  FILL_STROKE_ADD_TO_PATH: 6,\n  ADD_TO_PATH: 7,\n  FILL_STROKE_MASK: 3,\n  ADD_TO_PATH_FLAG: 4\n};\n\nvar ImageKind = {\n  GRAYSCALE_1BPP: 1,\n  RGB_24BPP: 2,\n  RGBA_32BPP: 3\n};\n\nvar AnnotationType = {\n  WIDGET: 1,\n  TEXT: 2,\n  LINK: 3\n};\n\nvar StreamType = {\n  UNKNOWN: 0,\n  FLATE: 1,\n  LZW: 2,\n  DCT: 3,\n  JPX: 4,\n  JBIG: 5,\n  A85: 6,\n  AHX: 7,\n  CCF: 8,\n  RL: 9\n};\n\nvar FontType = {\n  UNKNOWN: 0,\n  TYPE1: 1,\n  TYPE1C: 2,\n  CIDFONTTYPE0: 3,\n  CIDFONTTYPE0C: 4,\n  TRUETYPE: 5,\n  CIDFONTTYPE2: 6,\n  TYPE3: 7,\n  OPENTYPE: 8,\n  TYPE0: 9,\n  MMTYPE1: 10\n};\n\n// The global PDFJS object exposes the API\n// In production, it will be declared outside a global wrapper\n// In development, it will be declared here\nif (!globalScope.PDFJS) {\n  globalScope.PDFJS = {};\n}\n\nglobalScope.PDFJS.pdfBug = false;\n\nPDFJS.VERBOSITY_LEVELS = {\n  errors: 0,\n  warnings: 1,\n  infos: 5\n};\n\n// All the possible operations for an operator list.\nvar OPS = PDFJS.OPS = {\n  // Intentionally start from 1 so it is easy to spot bad operators that will be\n  // 0's.\n  dependency: 1,\n  setLineWidth: 2,\n  setLineCap: 3,\n  setLineJoin: 4,\n  setMiterLimit: 5,\n  setDash: 6,\n  setRenderingIntent: 7,\n  setFlatness: 8,\n  setGState: 9,\n  save: 10,\n  restore: 11,\n  transform: 12,\n  moveTo: 13,\n  lineTo: 14,\n  curveTo: 15,\n  curveTo2: 16,\n  curveTo3: 17,\n  closePath: 18,\n  rectangle: 19,\n  stroke: 20,\n  closeStroke: 21,\n  fill: 22,\n  eoFill: 23,\n  fillStroke: 24,\n  eoFillStroke: 25,\n  closeFillStroke: 26,\n  closeEOFillStroke: 27,\n  endPath: 28,\n  clip: 29,\n  eoClip: 30,\n  beginText: 31,\n  endText: 32,\n  setCharSpacing: 33,\n  setWordSpacing: 34,\n  setHScale: 35,\n  setLeading: 36,\n  setFont: 37,\n  setTextRenderingMode: 38,\n  setTextRise: 39,\n  moveText: 40,\n  setLeadingMoveText: 41,\n  setTextMatrix: 42,\n  nextLine: 43,\n  showText: 44,\n  showSpacedText: 45,\n  nextLineShowText: 46,\n  nextLineSetSpacingShowText: 47,\n  setCharWidth: 48,\n  setCharWidthAndBounds: 49,\n  setStrokeColorSpace: 50,\n  setFillColorSpace: 51,\n  setStrokeColor: 52,\n  setStrokeColorN: 53,\n  setFillColor: 54,\n  setFillColorN: 55,\n  setStrokeGray: 56,\n  setFillGray: 57,\n  setStrokeRGBColor: 58,\n  setFillRGBColor: 59,\n  setStrokeCMYKColor: 60,\n  setFillCMYKColor: 61,\n  shadingFill: 62,\n  beginInlineImage: 63,\n  beginImageData: 64,\n  endInlineImage: 65,\n  paintXObject: 66,\n  markPoint: 67,\n  markPointProps: 68,\n  beginMarkedContent: 69,\n  beginMarkedContentProps: 70,\n  endMarkedContent: 71,\n  beginCompat: 72,\n  endCompat: 73,\n  paintFormXObjectBegin: 74,\n  paintFormXObjectEnd: 75,\n  beginGroup: 76,\n  endGroup: 77,\n  beginAnnotations: 78,\n  endAnnotations: 79,\n  beginAnnotation: 80,\n  endAnnotation: 81,\n  paintJpegXObject: 82,\n  paintImageMaskXObject: 83,\n  paintImageMaskXObjectGroup: 84,\n  paintImageXObject: 85,\n  paintInlineImageXObject: 86,\n  paintInlineImageXObjectGroup: 87,\n  paintImageXObjectRepeat: 88,\n  paintImageMaskXObjectRepeat: 89,\n  paintSolidColorImageMask: 90,\n  constructPath: 91\n};\n\n// A notice for devs. These are good for things that are helpful to devs, such\n// as warning that Workers were disabled, which is important to devs but not\n// end users.\nfunction info(msg) {\n  if (PDFJS.verbosity >= PDFJS.VERBOSITY_LEVELS.infos) {\n    console.log('Info: ' + msg);\n  }\n}\n\n// Non-fatal warnings.\nfunction warn(msg) {\n  if (PDFJS.verbosity >= PDFJS.VERBOSITY_LEVELS.warnings) {\n    console.log('Warning: ' + msg);\n  }\n}\n\n// Fatal errors that should trigger the fallback UI and halt execution by\n// throwing an exception.\nfunction error(msg) {\n  if (PDFJS.verbosity >= PDFJS.VERBOSITY_LEVELS.errors) {\n    console.log('Error: ' + msg);\n    console.log(backtrace());\n  }\n  UnsupportedManager.notify(UNSUPPORTED_FEATURES.unknown);\n  throw new Error(msg);\n}\n\nfunction backtrace() {\n  try {\n    throw new Error();\n  } catch (e) {\n    return e.stack ? e.stack.split('\\n').slice(2).join('\\n') : '';\n  }\n}\n\nfunction assert(cond, msg) {\n  if (!cond) {\n    error(msg);\n  }\n}\n\nvar UNSUPPORTED_FEATURES = PDFJS.UNSUPPORTED_FEATURES = {\n  unknown: 'unknown',\n  forms: 'forms',\n  javaScript: 'javaScript',\n  smask: 'smask',\n  shadingPattern: 'shadingPattern',\n  font: 'font'\n};\n\nvar UnsupportedManager = PDFJS.UnsupportedManager =\n  (function UnsupportedManagerClosure() {\n  var listeners = [];\n  return {\n    listen: function (cb) {\n      listeners.push(cb);\n    },\n    notify: function (featureId) {\n      warn('Unsupported feature \"' + featureId + '\"');\n      for (var i = 0, ii = listeners.length; i < ii; i++) {\n        listeners[i](featureId);\n      }\n    }\n  };\n})();\n\n// Combines two URLs. The baseUrl shall be absolute URL. If the url is an\n// absolute URL, it will be returned as is.\nfunction combineUrl(baseUrl, url) {\n  if (!url) {\n    return baseUrl;\n  }\n  if (/^[a-z][a-z0-9+\\-.]*:/i.test(url)) {\n    return url;\n  }\n  var i;\n  if (url.charAt(0) === '/') {\n    // absolute path\n    i = baseUrl.indexOf('://');\n    if (url.charAt(1) === '/') {\n      ++i;\n    } else {\n      i = baseUrl.indexOf('/', i + 3);\n    }\n    return baseUrl.substring(0, i) + url;\n  } else {\n    // relative path\n    var pathLength = baseUrl.length;\n    i = baseUrl.lastIndexOf('#');\n    pathLength = i >= 0 ? i : pathLength;\n    i = baseUrl.lastIndexOf('?', pathLength);\n    pathLength = i >= 0 ? i : pathLength;\n    var prefixLength = baseUrl.lastIndexOf('/', pathLength);\n    return baseUrl.substring(0, prefixLength + 1) + url;\n  }\n}\n\n// Validates if URL is safe and allowed, e.g. to avoid XSS.\nfunction isValidUrl(url, allowRelative) {\n  if (!url) {\n    return false;\n  }\n  // RFC 3986 (http://tools.ietf.org/html/rfc3986#section-3.1)\n  // scheme = ALPHA *( ALPHA / DIGIT / \"+\" / \"-\" / \".\" )\n  var protocol = /^[a-z][a-z0-9+\\-.]*(?=:)/i.exec(url);\n  if (!protocol) {\n    return allowRelative;\n  }\n  protocol = protocol[0].toLowerCase();\n  switch (protocol) {\n    case 'http':\n    case 'https':\n    case 'ftp':\n    case 'mailto':\n    case 'tel':\n      return true;\n    default:\n      return false;\n  }\n}\nPDFJS.isValidUrl = isValidUrl;\n\nfunction shadow(obj, prop, value) {\n  Object.defineProperty(obj, prop, { value: value,\n                                     enumerable: true,\n                                     configurable: true,\n                                     writable: false });\n  return value;\n}\nPDFJS.shadow = shadow;\n\nvar PasswordResponses = PDFJS.PasswordResponses = {\n  NEED_PASSWORD: 1,\n  INCORRECT_PASSWORD: 2\n};\n\nvar PasswordException = (function PasswordExceptionClosure() {\n  function PasswordException(msg, code) {\n    this.name = 'PasswordException';\n    this.message = msg;\n    this.code = code;\n  }\n\n  PasswordException.prototype = new Error();\n  PasswordException.constructor = PasswordException;\n\n  return PasswordException;\n})();\nPDFJS.PasswordException = PasswordException;\n\nvar UnknownErrorException = (function UnknownErrorExceptionClosure() {\n  function UnknownErrorException(msg, details) {\n    this.name = 'UnknownErrorException';\n    this.message = msg;\n    this.details = details;\n  }\n\n  UnknownErrorException.prototype = new Error();\n  UnknownErrorException.constructor = UnknownErrorException;\n\n  return UnknownErrorException;\n})();\nPDFJS.UnknownErrorException = UnknownErrorException;\n\nvar InvalidPDFException = (function InvalidPDFExceptionClosure() {\n  function InvalidPDFException(msg) {\n    this.name = 'InvalidPDFException';\n    this.message = msg;\n  }\n\n  InvalidPDFException.prototype = new Error();\n  InvalidPDFException.constructor = InvalidPDFException;\n\n  return InvalidPDFException;\n})();\nPDFJS.InvalidPDFException = InvalidPDFException;\n\nvar MissingPDFException = (function MissingPDFExceptionClosure() {\n  function MissingPDFException(msg) {\n    this.name = 'MissingPDFException';\n    this.message = msg;\n  }\n\n  MissingPDFException.prototype = new Error();\n  MissingPDFException.constructor = MissingPDFException;\n\n  return MissingPDFException;\n})();\nPDFJS.MissingPDFException = MissingPDFException;\n\nvar UnexpectedResponseException =\n    (function UnexpectedResponseExceptionClosure() {\n  function UnexpectedResponseException(msg, status) {\n    this.name = 'UnexpectedResponseException';\n    this.message = msg;\n    this.status = status;\n  }\n\n  UnexpectedResponseException.prototype = new Error();\n  UnexpectedResponseException.constructor = UnexpectedResponseException;\n\n  return UnexpectedResponseException;\n})();\nPDFJS.UnexpectedResponseException = UnexpectedResponseException;\n\nvar NotImplementedException = (function NotImplementedExceptionClosure() {\n  function NotImplementedException(msg) {\n    this.message = msg;\n  }\n\n  NotImplementedException.prototype = new Error();\n  NotImplementedException.prototype.name = 'NotImplementedException';\n  NotImplementedException.constructor = NotImplementedException;\n\n  return NotImplementedException;\n})();\n\nvar MissingDataException = (function MissingDataExceptionClosure() {\n  function MissingDataException(begin, end) {\n    this.begin = begin;\n    this.end = end;\n    this.message = 'Missing data [' + begin + ', ' + end + ')';\n  }\n\n  MissingDataException.prototype = new Error();\n  MissingDataException.prototype.name = 'MissingDataException';\n  MissingDataException.constructor = MissingDataException;\n\n  return MissingDataException;\n})();\n\nvar XRefParseException = (function XRefParseExceptionClosure() {\n  function XRefParseException(msg) {\n    this.message = msg;\n  }\n\n  XRefParseException.prototype = new Error();\n  XRefParseException.prototype.name = 'XRefParseException';\n  XRefParseException.constructor = XRefParseException;\n\n  return XRefParseException;\n})();\n\n\nfunction bytesToString(bytes) {\n  assert(bytes !== null && typeof bytes === 'object' &&\n         bytes.length !== undefined, 'Invalid argument for bytesToString');\n  var length = bytes.length;\n  var MAX_ARGUMENT_COUNT = 8192;\n  if (length < MAX_ARGUMENT_COUNT) {\n    return String.fromCharCode.apply(null, bytes);\n  }\n  var strBuf = [];\n  for (var i = 0; i < length; i += MAX_ARGUMENT_COUNT) {\n    var chunkEnd = Math.min(i + MAX_ARGUMENT_COUNT, length);\n    var chunk = bytes.subarray(i, chunkEnd);\n    strBuf.push(String.fromCharCode.apply(null, chunk));\n  }\n  return strBuf.join('');\n}\n\nfunction stringToBytes(str) {\n  assert(typeof str === 'string', 'Invalid argument for stringToBytes');\n  var length = str.length;\n  var bytes = new Uint8Array(length);\n  for (var i = 0; i < length; ++i) {\n    bytes[i] = str.charCodeAt(i) & 0xFF;\n  }\n  return bytes;\n}\n\nfunction string32(value) {\n  return String.fromCharCode((value >> 24) & 0xff, (value >> 16) & 0xff,\n                             (value >> 8) & 0xff, value & 0xff);\n}\n\nfunction log2(x) {\n  var n = 1, i = 0;\n  while (x > n) {\n    n <<= 1;\n    i++;\n  }\n  return i;\n}\n\nfunction readInt8(data, start) {\n  return (data[start] << 24) >> 24;\n}\n\nfunction readUint16(data, offset) {\n  return (data[offset] << 8) | data[offset + 1];\n}\n\nfunction readUint32(data, offset) {\n  return ((data[offset] << 24) | (data[offset + 1] << 16) |\n         (data[offset + 2] << 8) | data[offset + 3]) >>> 0;\n}\n\n// Lazy test the endianness of the platform\n// NOTE: This will be 'true' for simulated TypedArrays\nfunction isLittleEndian() {\n  var buffer8 = new Uint8Array(2);\n  buffer8[0] = 1;\n  var buffer16 = new Uint16Array(buffer8.buffer);\n  return (buffer16[0] === 1);\n}\n\nObject.defineProperty(PDFJS, 'isLittleEndian', {\n  configurable: true,\n  get: function PDFJS_isLittleEndian() {\n    return shadow(PDFJS, 'isLittleEndian', isLittleEndian());\n  }\n});\n\n  // Lazy test if the userAgant support CanvasTypedArrays\nfunction hasCanvasTypedArrays() {\n  var canvas = document.createElement('canvas');\n  canvas.width = canvas.height = 1;\n  var ctx = canvas.getContext('2d');\n  var imageData = ctx.createImageData(1, 1);\n  return (typeof imageData.data.buffer !== 'undefined');\n}\n\nObject.defineProperty(PDFJS, 'hasCanvasTypedArrays', {\n  configurable: true,\n  get: function PDFJS_hasCanvasTypedArrays() {\n    return shadow(PDFJS, 'hasCanvasTypedArrays', hasCanvasTypedArrays());\n  }\n});\n\nvar Uint32ArrayView = (function Uint32ArrayViewClosure() {\n\n  function Uint32ArrayView(buffer, length) {\n    this.buffer = buffer;\n    this.byteLength = buffer.length;\n    this.length = length === undefined ? (this.byteLength >> 2) : length;\n    ensureUint32ArrayViewProps(this.length);\n  }\n  Uint32ArrayView.prototype = Object.create(null);\n\n  var uint32ArrayViewSetters = 0;\n  function createUint32ArrayProp(index) {\n    return {\n      get: function () {\n        var buffer = this.buffer, offset = index << 2;\n        return (buffer[offset] | (buffer[offset + 1] << 8) |\n          (buffer[offset + 2] << 16) | (buffer[offset + 3] << 24)) >>> 0;\n      },\n      set: function (value) {\n        var buffer = this.buffer, offset = index << 2;\n        buffer[offset] = value & 255;\n        buffer[offset + 1] = (value >> 8) & 255;\n        buffer[offset + 2] = (value >> 16) & 255;\n        buffer[offset + 3] = (value >>> 24) & 255;\n      }\n    };\n  }\n\n  function ensureUint32ArrayViewProps(length) {\n    while (uint32ArrayViewSetters < length) {\n      Object.defineProperty(Uint32ArrayView.prototype,\n        uint32ArrayViewSetters,\n        createUint32ArrayProp(uint32ArrayViewSetters));\n      uint32ArrayViewSetters++;\n    }\n  }\n\n  return Uint32ArrayView;\n})();\n\nvar IDENTITY_MATRIX = [1, 0, 0, 1, 0, 0];\n\nvar Util = PDFJS.Util = (function UtilClosure() {\n  function Util() {}\n\n  var rgbBuf = ['rgb(', 0, ',', 0, ',', 0, ')'];\n\n  // makeCssRgb() can be called thousands of times. Using |rgbBuf| avoids\n  // creating many intermediate strings.\n  Util.makeCssRgb = function Util_makeCssRgb(r, g, b) {\n    rgbBuf[1] = r;\n    rgbBuf[3] = g;\n    rgbBuf[5] = b;\n    return rgbBuf.join('');\n  };\n\n  // Concatenates two transformation matrices together and returns the result.\n  Util.transform = function Util_transform(m1, m2) {\n    return [\n      m1[0] * m2[0] + m1[2] * m2[1],\n      m1[1] * m2[0] + m1[3] * m2[1],\n      m1[0] * m2[2] + m1[2] * m2[3],\n      m1[1] * m2[2] + m1[3] * m2[3],\n      m1[0] * m2[4] + m1[2] * m2[5] + m1[4],\n      m1[1] * m2[4] + m1[3] * m2[5] + m1[5]\n    ];\n  };\n\n  // For 2d affine transforms\n  Util.applyTransform = function Util_applyTransform(p, m) {\n    var xt = p[0] * m[0] + p[1] * m[2] + m[4];\n    var yt = p[0] * m[1] + p[1] * m[3] + m[5];\n    return [xt, yt];\n  };\n\n  Util.applyInverseTransform = function Util_applyInverseTransform(p, m) {\n    var d = m[0] * m[3] - m[1] * m[2];\n    var xt = (p[0] * m[3] - p[1] * m[2] + m[2] * m[5] - m[4] * m[3]) / d;\n    var yt = (-p[0] * m[1] + p[1] * m[0] + m[4] * m[1] - m[5] * m[0]) / d;\n    return [xt, yt];\n  };\n\n  // Applies the transform to the rectangle and finds the minimum axially\n  // aligned bounding box.\n  Util.getAxialAlignedBoundingBox =\n    function Util_getAxialAlignedBoundingBox(r, m) {\n\n    var p1 = Util.applyTransform(r, m);\n    var p2 = Util.applyTransform(r.slice(2, 4), m);\n    var p3 = Util.applyTransform([r[0], r[3]], m);\n    var p4 = Util.applyTransform([r[2], r[1]], m);\n    return [\n      Math.min(p1[0], p2[0], p3[0], p4[0]),\n      Math.min(p1[1], p2[1], p3[1], p4[1]),\n      Math.max(p1[0], p2[0], p3[0], p4[0]),\n      Math.max(p1[1], p2[1], p3[1], p4[1])\n    ];\n  };\n\n  Util.inverseTransform = function Util_inverseTransform(m) {\n    var d = m[0] * m[3] - m[1] * m[2];\n    return [m[3] / d, -m[1] / d, -m[2] / d, m[0] / d,\n      (m[2] * m[5] - m[4] * m[3]) / d, (m[4] * m[1] - m[5] * m[0]) / d];\n  };\n\n  // Apply a generic 3d matrix M on a 3-vector v:\n  //   | a b c |   | X |\n  //   | d e f | x | Y |\n  //   | g h i |   | Z |\n  // M is assumed to be serialized as [a,b,c,d,e,f,g,h,i],\n  // with v as [X,Y,Z]\n  Util.apply3dTransform = function Util_apply3dTransform(m, v) {\n    return [\n      m[0] * v[0] + m[1] * v[1] + m[2] * v[2],\n      m[3] * v[0] + m[4] * v[1] + m[5] * v[2],\n      m[6] * v[0] + m[7] * v[1] + m[8] * v[2]\n    ];\n  };\n\n  // This calculation uses Singular Value Decomposition.\n  // The SVD can be represented with formula A = USV. We are interested in the\n  // matrix S here because it represents the scale values.\n  Util.singularValueDecompose2dScale =\n    function Util_singularValueDecompose2dScale(m) {\n\n    var transpose = [m[0], m[2], m[1], m[3]];\n\n    // Multiply matrix m with its transpose.\n    var a = m[0] * transpose[0] + m[1] * transpose[2];\n    var b = m[0] * transpose[1] + m[1] * transpose[3];\n    var c = m[2] * transpose[0] + m[3] * transpose[2];\n    var d = m[2] * transpose[1] + m[3] * transpose[3];\n\n    // Solve the second degree polynomial to get roots.\n    var first = (a + d) / 2;\n    var second = Math.sqrt((a + d) * (a + d) - 4 * (a * d - c * b)) / 2;\n    var sx = first + second || 1;\n    var sy = first - second || 1;\n\n    // Scale values are the square roots of the eigenvalues.\n    return [Math.sqrt(sx), Math.sqrt(sy)];\n  };\n\n  // Normalize rectangle rect=[x1, y1, x2, y2] so that (x1,y1) < (x2,y2)\n  // For coordinate systems whose origin lies in the bottom-left, this\n  // means normalization to (BL,TR) ordering. For systems with origin in the\n  // top-left, this means (TL,BR) ordering.\n  Util.normalizeRect = function Util_normalizeRect(rect) {\n    var r = rect.slice(0); // clone rect\n    if (rect[0] > rect[2]) {\n      r[0] = rect[2];\n      r[2] = rect[0];\n    }\n    if (rect[1] > rect[3]) {\n      r[1] = rect[3];\n      r[3] = rect[1];\n    }\n    return r;\n  };\n\n  // Returns a rectangle [x1, y1, x2, y2] corresponding to the\n  // intersection of rect1 and rect2. If no intersection, returns 'false'\n  // The rectangle coordinates of rect1, rect2 should be [x1, y1, x2, y2]\n  Util.intersect = function Util_intersect(rect1, rect2) {\n    function compare(a, b) {\n      return a - b;\n    }\n\n    // Order points along the axes\n    var orderedX = [rect1[0], rect1[2], rect2[0], rect2[2]].sort(compare),\n        orderedY = [rect1[1], rect1[3], rect2[1], rect2[3]].sort(compare),\n        result = [];\n\n    rect1 = Util.normalizeRect(rect1);\n    rect2 = Util.normalizeRect(rect2);\n\n    // X: first and second points belong to different rectangles?\n    if ((orderedX[0] === rect1[0] && orderedX[1] === rect2[0]) ||\n        (orderedX[0] === rect2[0] && orderedX[1] === rect1[0])) {\n      // Intersection must be between second and third points\n      result[0] = orderedX[1];\n      result[2] = orderedX[2];\n    } else {\n      return false;\n    }\n\n    // Y: first and second points belong to different rectangles?\n    if ((orderedY[0] === rect1[1] && orderedY[1] === rect2[1]) ||\n        (orderedY[0] === rect2[1] && orderedY[1] === rect1[1])) {\n      // Intersection must be between second and third points\n      result[1] = orderedY[1];\n      result[3] = orderedY[2];\n    } else {\n      return false;\n    }\n\n    return result;\n  };\n\n  Util.sign = function Util_sign(num) {\n    return num < 0 ? -1 : 1;\n  };\n\n  Util.appendToArray = function Util_appendToArray(arr1, arr2) {\n    Array.prototype.push.apply(arr1, arr2);\n  };\n\n  Util.prependToArray = function Util_prependToArray(arr1, arr2) {\n    Array.prototype.unshift.apply(arr1, arr2);\n  };\n\n  Util.extendObj = function extendObj(obj1, obj2) {\n    for (var key in obj2) {\n      obj1[key] = obj2[key];\n    }\n  };\n\n  Util.getInheritableProperty = function Util_getInheritableProperty(dict,\n                                                                     name) {\n    while (dict && !dict.has(name)) {\n      dict = dict.get('Parent');\n    }\n    if (!dict) {\n      return null;\n    }\n    return dict.get(name);\n  };\n\n  Util.inherit = function Util_inherit(sub, base, prototype) {\n    sub.prototype = Object.create(base.prototype);\n    sub.prototype.constructor = sub;\n    for (var prop in prototype) {\n      sub.prototype[prop] = prototype[prop];\n    }\n  };\n\n  Util.loadScript = function Util_loadScript(src, callback) {\n    var script = document.createElement('script');\n    var loaded = false;\n    script.setAttribute('src', src);\n    if (callback) {\n      script.onload = function() {\n        if (!loaded) {\n          callback();\n        }\n        loaded = true;\n      };\n    }\n    document.getElementsByTagName('head')[0].appendChild(script);\n  };\n\n  return Util;\n})();\n\n/**\n * PDF page viewport created based on scale, rotation and offset.\n * @class\n * @alias PDFJS.PageViewport\n */\nvar PageViewport = PDFJS.PageViewport = (function PageViewportClosure() {\n  /**\n   * @constructor\n   * @private\n   * @param viewBox {Array} xMin, yMin, xMax and yMax coordinates.\n   * @param scale {number} scale of the viewport.\n   * @param rotation {number} rotations of the viewport in degrees.\n   * @param offsetX {number} offset X\n   * @param offsetY {number} offset Y\n   * @param dontFlip {boolean} if true, axis Y will not be flipped.\n   */\n  function PageViewport(viewBox, scale, rotation, offsetX, offsetY, dontFlip) {\n    this.viewBox = viewBox;\n    this.scale = scale;\n    this.rotation = rotation;\n    this.offsetX = offsetX;\n    this.offsetY = offsetY;\n\n    // creating transform to convert pdf coordinate system to the normal\n    // canvas like coordinates taking in account scale and rotation\n    var centerX = (viewBox[2] + viewBox[0]) / 2;\n    var centerY = (viewBox[3] + viewBox[1]) / 2;\n    var rotateA, rotateB, rotateC, rotateD;\n    rotation = rotation % 360;\n    rotation = rotation < 0 ? rotation + 360 : rotation;\n    switch (rotation) {\n      case 180:\n        rotateA = -1; rotateB = 0; rotateC = 0; rotateD = 1;\n        break;\n      case 90:\n        rotateA = 0; rotateB = 1; rotateC = 1; rotateD = 0;\n        break;\n      case 270:\n        rotateA = 0; rotateB = -1; rotateC = -1; rotateD = 0;\n        break;\n      //case 0:\n      default:\n        rotateA = 1; rotateB = 0; rotateC = 0; rotateD = -1;\n        break;\n    }\n\n    if (dontFlip) {\n      rotateC = -rotateC; rotateD = -rotateD;\n    }\n\n    var offsetCanvasX, offsetCanvasY;\n    var width, height;\n    if (rotateA === 0) {\n      offsetCanvasX = Math.abs(centerY - viewBox[1]) * scale + offsetX;\n      offsetCanvasY = Math.abs(centerX - viewBox[0]) * scale + offsetY;\n      width = Math.abs(viewBox[3] - viewBox[1]) * scale;\n      height = Math.abs(viewBox[2] - viewBox[0]) * scale;\n    } else {\n      offsetCanvasX = Math.abs(centerX - viewBox[0]) * scale + offsetX;\n      offsetCanvasY = Math.abs(centerY - viewBox[1]) * scale + offsetY;\n      width = Math.abs(viewBox[2] - viewBox[0]) * scale;\n      height = Math.abs(viewBox[3] - viewBox[1]) * scale;\n    }\n    // creating transform for the following operations:\n    // translate(-centerX, -centerY), rotate and flip vertically,\n    // scale, and translate(offsetCanvasX, offsetCanvasY)\n    this.transform = [\n      rotateA * scale,\n      rotateB * scale,\n      rotateC * scale,\n      rotateD * scale,\n      offsetCanvasX - rotateA * scale * centerX - rotateC * scale * centerY,\n      offsetCanvasY - rotateB * scale * centerX - rotateD * scale * centerY\n    ];\n\n    this.width = width;\n    this.height = height;\n    this.fontScale = scale;\n  }\n  PageViewport.prototype = /** @lends PDFJS.PageViewport.prototype */ {\n    /**\n     * Clones viewport with additional properties.\n     * @param args {Object} (optional) If specified, may contain the 'scale' or\n     * 'rotation' properties to override the corresponding properties in\n     * the cloned viewport.\n     * @returns {PDFJS.PageViewport} Cloned viewport.\n     */\n    clone: function PageViewPort_clone(args) {\n      args = args || {};\n      var scale = 'scale' in args ? args.scale : this.scale;\n      var rotation = 'rotation' in args ? args.rotation : this.rotation;\n      return new PageViewport(this.viewBox.slice(), scale, rotation,\n                              this.offsetX, this.offsetY, args.dontFlip);\n    },\n    /**\n     * Converts PDF point to the viewport coordinates. For examples, useful for\n     * converting PDF location into canvas pixel coordinates.\n     * @param x {number} X coordinate.\n     * @param y {number} Y coordinate.\n     * @returns {Object} Object that contains 'x' and 'y' properties of the\n     * point in the viewport coordinate space.\n     * @see {@link convertToPdfPoint}\n     * @see {@link convertToViewportRectangle}\n     */\n    convertToViewportPoint: function PageViewport_convertToViewportPoint(x, y) {\n      return Util.applyTransform([x, y], this.transform);\n    },\n    /**\n     * Converts PDF rectangle to the viewport coordinates.\n     * @param rect {Array} xMin, yMin, xMax and yMax coordinates.\n     * @returns {Array} Contains corresponding coordinates of the rectangle\n     * in the viewport coordinate space.\n     * @see {@link convertToViewportPoint}\n     */\n    convertToViewportRectangle:\n      function PageViewport_convertToViewportRectangle(rect) {\n      var tl = Util.applyTransform([rect[0], rect[1]], this.transform);\n      var br = Util.applyTransform([rect[2], rect[3]], this.transform);\n      return [tl[0], tl[1], br[0], br[1]];\n    },\n    /**\n     * Converts viewport coordinates to the PDF location. For examples, useful\n     * for converting canvas pixel location into PDF one.\n     * @param x {number} X coordinate.\n     * @param y {number} Y coordinate.\n     * @returns {Object} Object that contains 'x' and 'y' properties of the\n     * point in the PDF coordinate space.\n     * @see {@link convertToViewportPoint}\n     */\n    convertToPdfPoint: function PageViewport_convertToPdfPoint(x, y) {\n      return Util.applyInverseTransform([x, y], this.transform);\n    }\n  };\n  return PageViewport;\n})();\n\nvar PDFStringTranslateTable = [\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0x2D8, 0x2C7, 0x2C6, 0x2D9, 0x2DD, 0x2DB, 0x2DA, 0x2DC, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x2022, 0x2020, 0x2021, 0x2026, 0x2014,\n  0x2013, 0x192, 0x2044, 0x2039, 0x203A, 0x2212, 0x2030, 0x201E, 0x201C,\n  0x201D, 0x2018, 0x2019, 0x201A, 0x2122, 0xFB01, 0xFB02, 0x141, 0x152, 0x160,\n  0x178, 0x17D, 0x131, 0x142, 0x153, 0x161, 0x17E, 0, 0x20AC\n];\n\nfunction stringToPDFString(str) {\n  var i, n = str.length, strBuf = [];\n  if (str[0] === '\\xFE' && str[1] === '\\xFF') {\n    // UTF16BE BOM\n    for (i = 2; i < n; i += 2) {\n      strBuf.push(String.fromCharCode(\n        (str.charCodeAt(i) << 8) | str.charCodeAt(i + 1)));\n    }\n  } else {\n    for (i = 0; i < n; ++i) {\n      var code = PDFStringTranslateTable[str.charCodeAt(i)];\n      strBuf.push(code ? String.fromCharCode(code) : str.charAt(i));\n    }\n  }\n  return strBuf.join('');\n}\n\nfunction stringToUTF8String(str) {\n  return decodeURIComponent(escape(str));\n}\n\nfunction isEmptyObj(obj) {\n  for (var key in obj) {\n    return false;\n  }\n  return true;\n}\n\nfunction isBool(v) {\n  return typeof v === 'boolean';\n}\n\nfunction isInt(v) {\n  return typeof v === 'number' && ((v | 0) === v);\n}\n\nfunction isNum(v) {\n  return typeof v === 'number';\n}\n\nfunction isString(v) {\n  return typeof v === 'string';\n}\n\nfunction isName(v) {\n  return v instanceof Name;\n}\n\nfunction isCmd(v, cmd) {\n  return v instanceof Cmd && (cmd === undefined || v.cmd === cmd);\n}\n\nfunction isDict(v, type) {\n  if (!(v instanceof Dict)) {\n    return false;\n  }\n  if (!type) {\n    return true;\n  }\n  var dictType = v.get('Type');\n  return isName(dictType) && dictType.name === type;\n}\n\nfunction isArray(v) {\n  return v instanceof Array;\n}\n\nfunction isStream(v) {\n  return typeof v === 'object' && v !== null && v.getBytes !== undefined;\n}\n\nfunction isArrayBuffer(v) {\n  return typeof v === 'object' && v !== null && v.byteLength !== undefined;\n}\n\nfunction isRef(v) {\n  return v instanceof Ref;\n}\n\n/**\n * Promise Capability object.\n *\n * @typedef {Object} PromiseCapability\n * @property {Promise} promise - A promise object.\n * @property {function} resolve - Fullfills the promise.\n * @property {function} reject - Rejects the promise.\n */\n\n/**\n * Creates a promise capability object.\n * @alias PDFJS.createPromiseCapability\n *\n * @return {PromiseCapability} A capability object contains:\n * - a Promise, resolve and reject methods.\n */\nfunction createPromiseCapability() {\n  var capability = {};\n  capability.promise = new Promise(function (resolve, reject) {\n    capability.resolve = resolve;\n    capability.reject = reject;\n  });\n  return capability;\n}\n\nPDFJS.createPromiseCapability = createPromiseCapability;\n\n/**\n * Polyfill for Promises:\n * The following promise implementation tries to generally implement the\n * Promise/A+ spec. Some notable differences from other promise libaries are:\n * - There currently isn't a seperate deferred and promise object.\n * - Unhandled rejections eventually show an error if they aren't handled.\n *\n * Based off of the work in:\n * https://bugzilla.mozilla.org/show_bug.cgi?id=810490\n */\n(function PromiseClosure() {\n  if (globalScope.Promise) {\n    // Promises existing in the DOM/Worker, checking presence of all/resolve\n    if (typeof globalScope.Promise.all !== 'function') {\n      globalScope.Promise.all = function (iterable) {\n        var count = 0, results = [], resolve, reject;\n        var promise = new globalScope.Promise(function (resolve_, reject_) {\n          resolve = resolve_;\n          reject = reject_;\n        });\n        iterable.forEach(function (p, i) {\n          count++;\n          p.then(function (result) {\n            results[i] = result;\n            count--;\n            if (count === 0) {\n              resolve(results);\n            }\n          }, reject);\n        });\n        if (count === 0) {\n          resolve(results);\n        }\n        return promise;\n      };\n    }\n    if (typeof globalScope.Promise.resolve !== 'function') {\n      globalScope.Promise.resolve = function (value) {\n        return new globalScope.Promise(function (resolve) { resolve(value); });\n      };\n    }\n    if (typeof globalScope.Promise.reject !== 'function') {\n      globalScope.Promise.reject = function (reason) {\n        return new globalScope.Promise(function (resolve, reject) {\n          reject(reason);\n        });\n      };\n    }\n    if (typeof globalScope.Promise.prototype.catch !== 'function') {\n      globalScope.Promise.prototype.catch = function (onReject) {\n        return globalScope.Promise.prototype.then(undefined, onReject);\n      };\n    }\n    return;\n  }\n  var STATUS_PENDING = 0;\n  var STATUS_RESOLVED = 1;\n  var STATUS_REJECTED = 2;\n\n  // In an attempt to avoid silent exceptions, unhandled rejections are\n  // tracked and if they aren't handled in a certain amount of time an\n  // error is logged.\n  var REJECTION_TIMEOUT = 500;\n\n  var HandlerManager = {\n    handlers: [],\n    running: false,\n    unhandledRejections: [],\n    pendingRejectionCheck: false,\n\n    scheduleHandlers: function scheduleHandlers(promise) {\n      if (promise._status === STATUS_PENDING) {\n        return;\n      }\n\n      this.handlers = this.handlers.concat(promise._handlers);\n      promise._handlers = [];\n\n      if (this.running) {\n        return;\n      }\n      this.running = true;\n\n      setTimeout(this.runHandlers.bind(this), 0);\n    },\n\n    runHandlers: function runHandlers() {\n      var RUN_TIMEOUT = 1; // ms\n      var timeoutAt = Date.now() + RUN_TIMEOUT;\n      while (this.handlers.length > 0) {\n        var handler = this.handlers.shift();\n\n        var nextStatus = handler.thisPromise._status;\n        var nextValue = handler.thisPromise._value;\n\n        try {\n          if (nextStatus === STATUS_RESOLVED) {\n            if (typeof handler.onResolve === 'function') {\n              nextValue = handler.onResolve(nextValue);\n            }\n          } else if (typeof handler.onReject === 'function') {\n              nextValue = handler.onReject(nextValue);\n              nextStatus = STATUS_RESOLVED;\n\n              if (handler.thisPromise._unhandledRejection) {\n                this.removeUnhandeledRejection(handler.thisPromise);\n              }\n          }\n        } catch (ex) {\n          nextStatus = STATUS_REJECTED;\n          nextValue = ex;\n        }\n\n        handler.nextPromise._updateStatus(nextStatus, nextValue);\n        if (Date.now() >= timeoutAt) {\n          break;\n        }\n      }\n\n      if (this.handlers.length > 0) {\n        setTimeout(this.runHandlers.bind(this), 0);\n        return;\n      }\n\n      this.running = false;\n    },\n\n    addUnhandledRejection: function addUnhandledRejection(promise) {\n      this.unhandledRejections.push({\n        promise: promise,\n        time: Date.now()\n      });\n      this.scheduleRejectionCheck();\n    },\n\n    removeUnhandeledRejection: function removeUnhandeledRejection(promise) {\n      promise._unhandledRejection = false;\n      for (var i = 0; i < this.unhandledRejections.length; i++) {\n        if (this.unhandledRejections[i].promise === promise) {\n          this.unhandledRejections.splice(i);\n          i--;\n        }\n      }\n    },\n\n    scheduleRejectionCheck: function scheduleRejectionCheck() {\n      if (this.pendingRejectionCheck) {\n        return;\n      }\n      this.pendingRejectionCheck = true;\n      setTimeout(function rejectionCheck() {\n        this.pendingRejectionCheck = false;\n        var now = Date.now();\n        for (var i = 0; i < this.unhandledRejections.length; i++) {\n          if (now - this.unhandledRejections[i].time > REJECTION_TIMEOUT) {\n            var unhandled = this.unhandledRejections[i].promise._value;\n            var msg = 'Unhandled rejection: ' + unhandled;\n            if (unhandled.stack) {\n              msg += '\\n' + unhandled.stack;\n            }\n            warn(msg);\n            this.unhandledRejections.splice(i);\n            i--;\n          }\n        }\n        if (this.unhandledRejections.length) {\n          this.scheduleRejectionCheck();\n        }\n      }.bind(this), REJECTION_TIMEOUT);\n    }\n  };\n\n  function Promise(resolver) {\n    this._status = STATUS_PENDING;\n    this._handlers = [];\n    try {\n      resolver.call(this, this._resolve.bind(this), this._reject.bind(this));\n    } catch (e) {\n      this._reject(e);\n    }\n  }\n  /**\n   * Builds a promise that is resolved when all the passed in promises are\n   * resolved.\n   * @param {array} array of data and/or promises to wait for.\n   * @return {Promise} New dependant promise.\n   */\n  Promise.all = function Promise_all(promises) {\n    var resolveAll, rejectAll;\n    var deferred = new Promise(function (resolve, reject) {\n      resolveAll = resolve;\n      rejectAll = reject;\n    });\n    var unresolved = promises.length;\n    var results = [];\n    if (unresolved === 0) {\n      resolveAll(results);\n      return deferred;\n    }\n    function reject(reason) {\n      if (deferred._status === STATUS_REJECTED) {\n        return;\n      }\n      results = [];\n      rejectAll(reason);\n    }\n    for (var i = 0, ii = promises.length; i < ii; ++i) {\n      var promise = promises[i];\n      var resolve = (function(i) {\n        return function(value) {\n          if (deferred._status === STATUS_REJECTED) {\n            return;\n          }\n          results[i] = value;\n          unresolved--;\n          if (unresolved === 0) {\n            resolveAll(results);\n          }\n        };\n      })(i);\n      if (Promise.isPromise(promise)) {\n        promise.then(resolve, reject);\n      } else {\n        resolve(promise);\n      }\n    }\n    return deferred;\n  };\n\n  /**\n   * Checks if the value is likely a promise (has a 'then' function).\n   * @return {boolean} true if value is thenable\n   */\n  Promise.isPromise = function Promise_isPromise(value) {\n    return value && typeof value.then === 'function';\n  };\n\n  /**\n   * Creates resolved promise\n   * @param value resolve value\n   * @returns {Promise}\n   */\n  Promise.resolve = function Promise_resolve(value) {\n    return new Promise(function (resolve) { resolve(value); });\n  };\n\n  /**\n   * Creates rejected promise\n   * @param reason rejection value\n   * @returns {Promise}\n   */\n  Promise.reject = function Promise_reject(reason) {\n    return new Promise(function (resolve, reject) { reject(reason); });\n  };\n\n  Promise.prototype = {\n    _status: null,\n    _value: null,\n    _handlers: null,\n    _unhandledRejection: null,\n\n    _updateStatus: function Promise__updateStatus(status, value) {\n      if (this._status === STATUS_RESOLVED ||\n          this._status === STATUS_REJECTED) {\n        return;\n      }\n\n      if (status === STATUS_RESOLVED &&\n          Promise.isPromise(value)) {\n        value.then(this._updateStatus.bind(this, STATUS_RESOLVED),\n                   this._updateStatus.bind(this, STATUS_REJECTED));\n        return;\n      }\n\n      this._status = status;\n      this._value = value;\n\n      if (status === STATUS_REJECTED && this._handlers.length === 0) {\n        this._unhandledRejection = true;\n        HandlerManager.addUnhandledRejection(this);\n      }\n\n      HandlerManager.scheduleHandlers(this);\n    },\n\n    _resolve: function Promise_resolve(value) {\n      this._updateStatus(STATUS_RESOLVED, value);\n    },\n\n    _reject: function Promise_reject(reason) {\n      this._updateStatus(STATUS_REJECTED, reason);\n    },\n\n    then: function Promise_then(onResolve, onReject) {\n      var nextPromise = new Promise(function (resolve, reject) {\n        this.resolve = resolve;\n        this.reject = reject;\n      });\n      this._handlers.push({\n        thisPromise: this,\n        onResolve: onResolve,\n        onReject: onReject,\n        nextPromise: nextPromise\n      });\n      HandlerManager.scheduleHandlers(this);\n      return nextPromise;\n    },\n\n    catch: function Promise_catch(onReject) {\n      return this.then(undefined, onReject);\n    }\n  };\n\n  globalScope.Promise = Promise;\n})();\n\nvar StatTimer = (function StatTimerClosure() {\n  function rpad(str, pad, length) {\n    while (str.length < length) {\n      str += pad;\n    }\n    return str;\n  }\n  function StatTimer() {\n    this.started = {};\n    this.times = [];\n    this.enabled = true;\n  }\n  StatTimer.prototype = {\n    time: function StatTimer_time(name) {\n      if (!this.enabled) {\n        return;\n      }\n      if (name in this.started) {\n        warn('Timer is already running for ' + name);\n      }\n      this.started[name] = Date.now();\n    },\n    timeEnd: function StatTimer_timeEnd(name) {\n      if (!this.enabled) {\n        return;\n      }\n      if (!(name in this.started)) {\n        warn('Timer has not been started for ' + name);\n      }\n      this.times.push({\n        'name': name,\n        'start': this.started[name],\n        'end': Date.now()\n      });\n      // Remove timer from started so it can be called again.\n      delete this.started[name];\n    },\n    toString: function StatTimer_toString() {\n      var i, ii;\n      var times = this.times;\n      var out = '';\n      // Find the longest name for padding purposes.\n      var longest = 0;\n      for (i = 0, ii = times.length; i < ii; ++i) {\n        var name = times[i]['name'];\n        if (name.length > longest) {\n          longest = name.length;\n        }\n      }\n      for (i = 0, ii = times.length; i < ii; ++i) {\n        var span = times[i];\n        var duration = span.end - span.start;\n        out += rpad(span['name'], ' ', longest) + ' ' + duration + 'ms\\n';\n      }\n      return out;\n    }\n  };\n  return StatTimer;\n})();\n\nPDFJS.createBlob = function createBlob(data, contentType) {\n  if (typeof Blob !== 'undefined') {\n    return new Blob([data], { type: contentType });\n  }\n  // Blob builder is deprecated in FF14 and removed in FF18.\n  var bb = new MozBlobBuilder();\n  bb.append(data);\n  return bb.getBlob(contentType);\n};\n\nPDFJS.createObjectURL = (function createObjectURLClosure() {\n  // Blob/createObjectURL is not available, falling back to data schema.\n  var digits =\n    'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';\n\n  return function createObjectURL(data, contentType) {\n    if (!PDFJS.disableCreateObjectURL &&\n        typeof URL !== 'undefined' && URL.createObjectURL) {\n      var blob = PDFJS.createBlob(data, contentType);\n      return URL.createObjectURL(blob);\n    }\n\n    var buffer = 'data:' + contentType + ';base64,';\n    for (var i = 0, ii = data.length; i < ii; i += 3) {\n      var b1 = data[i] & 0xFF;\n      var b2 = data[i + 1] & 0xFF;\n      var b3 = data[i + 2] & 0xFF;\n      var d1 = b1 >> 2, d2 = ((b1 & 3) << 4) | (b2 >> 4);\n      var d3 = i + 1 < ii ? ((b2 & 0xF) << 2) | (b3 >> 6) : 64;\n      var d4 = i + 2 < ii ? (b3 & 0x3F) : 64;\n      buffer += digits[d1] + digits[d2] + digits[d3] + digits[d4];\n    }\n    return buffer;\n  };\n})();\n\nfunction MessageHandler(name, comObj) {\n  this.name = name;\n  this.comObj = comObj;\n  this.callbackIndex = 1;\n  this.postMessageTransfers = true;\n  var callbacksCapabilities = this.callbacksCapabilities = {};\n  var ah = this.actionHandler = {};\n\n  ah['console_log'] = [function ahConsoleLog(data) {\n    console.log.apply(console, data);\n  }];\n  ah['console_error'] = [function ahConsoleError(data) {\n    console.error.apply(console, data);\n  }];\n  ah['_unsupported_feature'] = [function ah_unsupportedFeature(data) {\n    UnsupportedManager.notify(data);\n  }];\n\n  comObj.onmessage = function messageHandlerComObjOnMessage(event) {\n    var data = event.data;\n    if (data.isReply) {\n      var callbackId = data.callbackId;\n      if (data.callbackId in callbacksCapabilities) {\n        var callback = callbacksCapabilities[callbackId];\n        delete callbacksCapabilities[callbackId];\n        if ('error' in data) {\n          callback.reject(data.error);\n        } else {\n          callback.resolve(data.data);\n        }\n      } else {\n        error('Cannot resolve callback ' + callbackId);\n      }\n    } else if (data.action in ah) {\n      var action = ah[data.action];\n      if (data.callbackId) {\n        Promise.resolve().then(function () {\n          return action[0].call(action[1], data.data);\n        }).then(function (result) {\n          comObj.postMessage({\n            isReply: true,\n            callbackId: data.callbackId,\n            data: result\n          });\n        }, function (reason) {\n          comObj.postMessage({\n            isReply: true,\n            callbackId: data.callbackId,\n            error: reason\n          });\n        });\n      } else {\n        action[0].call(action[1], data.data);\n      }\n    } else {\n      error('Unknown action from worker: ' + data.action);\n    }\n  };\n}\n\nMessageHandler.prototype = {\n  on: function messageHandlerOn(actionName, handler, scope) {\n    var ah = this.actionHandler;\n    if (ah[actionName]) {\n      error('There is already an actionName called \"' + actionName + '\"');\n    }\n    ah[actionName] = [handler, scope];\n  },\n  /**\n   * Sends a message to the comObj to invoke the action with the supplied data.\n   * @param {String} actionName Action to call.\n   * @param {JSON} data JSON data to send.\n   * @param {Array} [transfers] Optional list of transfers/ArrayBuffers\n   */\n  send: function messageHandlerSend(actionName, data, transfers) {\n    var message = {\n      action: actionName,\n      data: data\n    };\n    this.postMessage(message, transfers);\n  },\n  /**\n   * Sends a message to the comObj to invoke the action with the supplied data.\n   * Expects that other side will callback with the response.\n   * @param {String} actionName Action to call.\n   * @param {JSON} data JSON data to send.\n   * @param {Array} [transfers] Optional list of transfers/ArrayBuffers.\n   * @returns {Promise} Promise to be resolved with response data.\n   */\n  sendWithPromise:\n    function messageHandlerSendWithPromise(actionName, data, transfers) {\n    var callbackId = this.callbackIndex++;\n    var message = {\n      action: actionName,\n      data: data,\n      callbackId: callbackId\n    };\n    var capability = createPromiseCapability();\n    this.callbacksCapabilities[callbackId] = capability;\n    try {\n      this.postMessage(message, transfers);\n    } catch (e) {\n      capability.reject(e);\n    }\n    return capability.promise;\n  },\n  /**\n   * Sends raw message to the comObj.\n   * @private\n   * @param message {Object} Raw message.\n   * @param transfers List of transfers/ArrayBuffers, or undefined.\n   */\n  postMessage: function (message, transfers) {\n    if (transfers && this.postMessageTransfers) {\n      this.comObj.postMessage(message, transfers);\n    } else {\n      this.comObj.postMessage(message);\n    }\n  }\n};\n\nfunction loadJpegStream(id, imageUrl, objs) {\n  var img = new Image();\n  img.onload = (function loadJpegStream_onloadClosure() {\n    objs.resolve(id, img);\n  });\n  img.onerror = (function loadJpegStream_onerrorClosure() {\n    objs.resolve(id, null);\n    warn('Error during JPEG image loading');\n  });\n  img.src = imageUrl;\n}\n\n\n/**\n * The maximum allowed image size in total pixels e.g. width * height. Images\n * above this value will not be drawn. Use -1 for no limit.\n * @var {number}\n */\nPDFJS.maxImageSize = (PDFJS.maxImageSize === undefined ?\n                      -1 : PDFJS.maxImageSize);\n\n/**\n * The url of where the predefined Adobe CMaps are located. Include trailing\n * slash.\n * @var {string}\n */\nPDFJS.cMapUrl = (PDFJS.cMapUrl === undefined ? null : PDFJS.cMapUrl);\n\n/**\n * Specifies if CMaps are binary packed.\n * @var {boolean}\n */\nPDFJS.cMapPacked = PDFJS.cMapPacked === undefined ? false : PDFJS.cMapPacked;\n\n/**\n * By default fonts are converted to OpenType fonts and loaded via font face\n * rules. If disabled, the font will be rendered using a built in font renderer\n * that constructs the glyphs with primitive path commands.\n * @var {boolean}\n */\nPDFJS.disableFontFace = (PDFJS.disableFontFace === undefined ?\n                         false : PDFJS.disableFontFace);\n\n/**\n * Path for image resources, mainly for annotation icons. Include trailing\n * slash.\n * @var {string}\n */\nPDFJS.imageResourcesPath = (PDFJS.imageResourcesPath === undefined ?\n                            '' : PDFJS.imageResourcesPath);\n\n/**\n * Disable the web worker and run all code on the main thread. This will happen\n * automatically if the browser doesn't support workers or sending typed arrays\n * to workers.\n * @var {boolean}\n */\nPDFJS.disableWorker = (PDFJS.disableWorker === undefined ?\n                       false : PDFJS.disableWorker);\n\n/**\n * Path and filename of the worker file. Required when the worker is enabled in\n * development mode. If unspecified in the production build, the worker will be\n * loaded based on the location of the pdf.js file.\n * @var {string}\n */\nPDFJS.workerSrc = (PDFJS.workerSrc === undefined ? null : PDFJS.workerSrc);\n\n/**\n * Disable range request loading of PDF files. When enabled and if the server\n * supports partial content requests then the PDF will be fetched in chunks.\n * Enabled (false) by default.\n * @var {boolean}\n */\nPDFJS.disableRange = (PDFJS.disableRange === undefined ?\n                      false : PDFJS.disableRange);\n\n/**\n * Disable streaming of PDF file data. By default PDF.js attempts to load PDF\n * in chunks. This default behavior can be disabled.\n * @var {boolean}\n */\nPDFJS.disableStream = (PDFJS.disableStream === undefined ?\n                       false : PDFJS.disableStream);\n\n/**\n * Disable pre-fetching of PDF file data. When range requests are enabled PDF.js\n * will automatically keep fetching more data even if it isn't needed to display\n * the current page. This default behavior can be disabled.\n *\n * NOTE: It is also necessary to disable streaming, see above,\n *       in order for disabling of pre-fetching to work correctly.\n * @var {boolean}\n */\nPDFJS.disableAutoFetch = (PDFJS.disableAutoFetch === undefined ?\n                          false : PDFJS.disableAutoFetch);\n\n/**\n * Enables special hooks for debugging PDF.js.\n * @var {boolean}\n */\nPDFJS.pdfBug = (PDFJS.pdfBug === undefined ? false : PDFJS.pdfBug);\n\n/**\n * Enables transfer usage in postMessage for ArrayBuffers.\n * @var {boolean}\n */\nPDFJS.postMessageTransfers = (PDFJS.postMessageTransfers === undefined ?\n                              true : PDFJS.postMessageTransfers);\n\n/**\n * Disables URL.createObjectURL usage.\n * @var {boolean}\n */\nPDFJS.disableCreateObjectURL = (PDFJS.disableCreateObjectURL === undefined ?\n                                false : PDFJS.disableCreateObjectURL);\n\n/**\n * Disables WebGL usage.\n * @var {boolean}\n */\nPDFJS.disableWebGL = (PDFJS.disableWebGL === undefined ?\n                      true : PDFJS.disableWebGL);\n\n/**\n * Disables fullscreen support, and by extension Presentation Mode,\n * in browsers which support the fullscreen API.\n * @var {boolean}\n */\nPDFJS.disableFullscreen = (PDFJS.disableFullscreen === undefined ?\n                           false : PDFJS.disableFullscreen);\n\n/**\n * Enables CSS only zooming.\n * @var {boolean}\n */\nPDFJS.useOnlyCssZoom = (PDFJS.useOnlyCssZoom === undefined ?\n                        false : PDFJS.useOnlyCssZoom);\n\n/**\n * Controls the logging level.\n * The constants from PDFJS.VERBOSITY_LEVELS should be used:\n * - errors\n * - warnings [default]\n * - infos\n * @var {number}\n */\nPDFJS.verbosity = (PDFJS.verbosity === undefined ?\n                   PDFJS.VERBOSITY_LEVELS.warnings : PDFJS.verbosity);\n\n/**\n * The maximum supported canvas size in total pixels e.g. width * height.\n * The default value is 4096 * 4096. Use -1 for no limit.\n * @var {number}\n */\nPDFJS.maxCanvasPixels = (PDFJS.maxCanvasPixels === undefined ?\n                         16777216 : PDFJS.maxCanvasPixels);\n\n/**\n * Opens external links in a new window if enabled. The default behavior opens\n * external links in the PDF.js window.\n * @var {boolean}\n */\nPDFJS.openExternalLinksInNewWindow = (\n  PDFJS.openExternalLinksInNewWindow === undefined ?\n    false : PDFJS.openExternalLinksInNewWindow);\n\n/**\n * Document initialization / loading parameters object.\n *\n * @typedef {Object} DocumentInitParameters\n * @property {string}     url   - The URL of the PDF.\n * @property {TypedArray|Array|string} data - Binary PDF data. Use typed arrays\n *   (Uint8Array) to improve the memory usage. If PDF data is BASE64-encoded,\n *   use atob() to convert it to a binary string first.\n * @property {Object}     httpHeaders - Basic authentication headers.\n * @property {boolean}    withCredentials - Indicates whether or not cross-site\n *   Access-Control requests should be made using credentials such as cookies\n *   or authorization headers. The default is false.\n * @property {string}     password - For decrypting password-protected PDFs.\n * @property {TypedArray} initialData - A typed array with the first portion or\n *   all of the pdf data. Used by the extension since some data is already\n *   loaded before the switch to range requests.\n * @property {number}     length - The PDF file length. It's used for progress\n *   reports and range requests operations.\n * @property {PDFDataRangeTransport} range\n */\n\n/**\n * @typedef {Object} PDFDocumentStats\n * @property {Array} streamTypes - Used stream types in the document (an item\n *   is set to true if specific stream ID was used in the document).\n * @property {Array} fontTypes - Used font type in the document (an item is set\n *   to true if specific font ID was used in the document).\n */\n\n/**\n * This is the main entry point for loading a PDF and interacting with it.\n * NOTE: If a URL is used to fetch the PDF data a standard XMLHttpRequest(XHR)\n * is used, which means it must follow the same origin rules that any XHR does\n * e.g. No cross domain requests without CORS.\n *\n * @param {string|TypedArray|DocumentInitParameters|PDFDataRangeTransport} src\n * Can be a url to where a PDF is located, a typed array (Uint8Array)\n * already populated with data or parameter object.\n *\n * @param {PDFDataRangeTransport} pdfDataRangeTransport (deprecated) It is used\n * if you want to manually serve range requests for data in the PDF.\n *\n * @param {function} passwordCallback (deprecated) It is used to request a\n * password if wrong or no password was provided. The callback receives two\n * parameters: function that needs to be called with new password and reason\n * (see {PasswordResponses}).\n *\n * @param {function} progressCallback (deprecated) It is used to be able to\n * monitor the loading progress of the PDF file (necessary to implement e.g.\n * a loading bar). The callback receives an {Object} with the properties:\n * {number} loaded and {number} total.\n *\n * @return {PDFDocumentLoadingTask}\n */\nPDFJS.getDocument = function getDocument(src,\n                                         pdfDataRangeTransport,\n                                         passwordCallback,\n                                         progressCallback) {\n  var task = new PDFDocumentLoadingTask();\n\n  // Support of the obsolete arguments (for compatibility with API v1.0)\n  if (pdfDataRangeTransport) {\n    if (!(pdfDataRangeTransport instanceof PDFDataRangeTransport)) {\n      // Not a PDFDataRangeTransport instance, trying to add missing properties.\n      pdfDataRangeTransport = Object.create(pdfDataRangeTransport);\n      pdfDataRangeTransport.length = src.length;\n      pdfDataRangeTransport.initialData = src.initialData;\n    }\n    src = Object.create(src);\n    src.range = pdfDataRangeTransport;\n  }\n  task.onPassword = passwordCallback || null;\n  task.onProgress = progressCallback || null;\n\n  var workerInitializedCapability, transport;\n  var source;\n  if (typeof src === 'string') {\n    source = { url: src };\n  } else if (isArrayBuffer(src)) {\n    source = { data: src };\n  } else if (src instanceof PDFDataRangeTransport) {\n    source = { range: src };\n  } else {\n    if (typeof src !== 'object') {\n      error('Invalid parameter in getDocument, need either Uint8Array, ' +\n        'string or a parameter object');\n    }\n    if (!src.url && !src.data && !src.range) {\n      error('Invalid parameter object: need either .data, .range or .url');\n    }\n\n    source = src;\n  }\n\n  var params = {};\n  for (var key in source) {\n    if (key === 'url' && typeof window !== 'undefined') {\n      // The full path is required in the 'url' field.\n      params[key] = combineUrl(window.location.href, source[key]);\n      continue;\n    } else if (key === 'range') {\n      continue;\n    } else if (key === 'data' && !(source[key] instanceof Uint8Array)) {\n      // Converting string or array-like data to Uint8Array.\n      var pdfBytes = source[key];\n      if (typeof pdfBytes === 'string') {\n        params[key] = stringToBytes(pdfBytes);\n      } else if (typeof pdfBytes === 'object' && pdfBytes !== null &&\n                 !isNaN(pdfBytes.length)) {\n        params[key] = new Uint8Array(pdfBytes);\n      } else {\n        error('Invalid PDF binary data: either typed array, string or ' +\n              'array-like object is expected in the data property.');\n      }\n      continue;\n    }\n    params[key] = source[key];\n  }\n\n  workerInitializedCapability = createPromiseCapability();\n  transport = new WorkerTransport(workerInitializedCapability, source.range);\n  workerInitializedCapability.promise.then(function transportInitialized() {\n    transport.fetchDocument(task, params);\n  });\n\n  return task;\n};\n\n/**\n * PDF document loading operation.\n * @class\n */\nvar PDFDocumentLoadingTask = (function PDFDocumentLoadingTaskClosure() {\n  /** @constructs PDFDocumentLoadingTask */\n  function PDFDocumentLoadingTask() {\n    this._capability = createPromiseCapability();\n\n    /**\n     * Callback to request a password if wrong or no password was provided.\n     * The callback receives two parameters: function that needs to be called\n     * with new password and reason (see {PasswordResponses}).\n     */\n    this.onPassword = null;\n\n    /**\n     * Callback to be able to monitor the loading progress of the PDF file\n     * (necessary to implement e.g. a loading bar). The callback receives\n     * an {Object} with the properties: {number} loaded and {number} total.\n     */\n    this.onProgress = null;\n  }\n\n  PDFDocumentLoadingTask.prototype =\n      /** @lends PDFDocumentLoadingTask.prototype */ {\n    /**\n     * @return {Promise}\n     */\n    get promise() {\n      return this._capability.promise;\n    },\n\n    // TODO add cancel or abort method\n\n    /**\n     * Registers callbacks to indicate the document loading completion.\n     *\n     * @param {function} onFulfilled The callback for the loading completion.\n     * @param {function} onRejected The callback for the loading failure.\n     * @return {Promise} A promise that is resolved after the onFulfilled or\n     *                   onRejected callback.\n     */\n    then: function PDFDocumentLoadingTask_then(onFulfilled, onRejected) {\n      return this.promise.then.apply(this.promise, arguments);\n    }\n  };\n\n  return PDFDocumentLoadingTask;\n})();\n\n/**\n * Abstract class to support range requests file loading.\n * @class\n */\nvar PDFDataRangeTransport = (function pdfDataRangeTransportClosure() {\n  /**\n   * @constructs PDFDataRangeTransport\n   * @param {number} length\n   * @param {Uint8Array} initialData\n   */\n  function PDFDataRangeTransport(length, initialData) {\n    this.length = length;\n    this.initialData = initialData;\n\n    this._rangeListeners = [];\n    this._progressListeners = [];\n    this._progressiveReadListeners = [];\n    this._readyCapability = createPromiseCapability();\n  }\n  PDFDataRangeTransport.prototype =\n      /** @lends PDFDataRangeTransport.prototype */ {\n    addRangeListener:\n        function PDFDataRangeTransport_addRangeListener(listener) {\n      this._rangeListeners.push(listener);\n    },\n\n    addProgressListener:\n        function PDFDataRangeTransport_addProgressListener(listener) {\n      this._progressListeners.push(listener);\n    },\n\n    addProgressiveReadListener:\n        function PDFDataRangeTransport_addProgressiveReadListener(listener) {\n      this._progressiveReadListeners.push(listener);\n    },\n\n    onDataRange: function PDFDataRangeTransport_onDataRange(begin, chunk) {\n      var listeners = this._rangeListeners;\n      for (var i = 0, n = listeners.length; i < n; ++i) {\n        listeners[i](begin, chunk);\n      }\n    },\n\n    onDataProgress: function PDFDataRangeTransport_onDataProgress(loaded) {\n      this._readyCapability.promise.then(function () {\n        var listeners = this._progressListeners;\n        for (var i = 0, n = listeners.length; i < n; ++i) {\n          listeners[i](loaded);\n        }\n      }.bind(this));\n    },\n\n    onDataProgressiveRead:\n        function PDFDataRangeTransport_onDataProgress(chunk) {\n      this._readyCapability.promise.then(function () {\n        var listeners = this._progressiveReadListeners;\n        for (var i = 0, n = listeners.length; i < n; ++i) {\n          listeners[i](chunk);\n        }\n      }.bind(this));\n    },\n\n    transportReady: function PDFDataRangeTransport_transportReady() {\n      this._readyCapability.resolve();\n    },\n\n    requestDataRange:\n        function PDFDataRangeTransport_requestDataRange(begin, end) {\n      throw new Error('Abstract method PDFDataRangeTransport.requestDataRange');\n    }\n  };\n  return PDFDataRangeTransport;\n})();\n\nPDFJS.PDFDataRangeTransport = PDFDataRangeTransport;\n\n/**\n * Proxy to a PDFDocument in the worker thread. Also, contains commonly used\n * properties that can be read synchronously.\n * @class\n */\nvar PDFDocumentProxy = (function PDFDocumentProxyClosure() {\n  function PDFDocumentProxy(pdfInfo, transport) {\n    this.pdfInfo = pdfInfo;\n    this.transport = transport;\n  }\n  PDFDocumentProxy.prototype = /** @lends PDFDocumentProxy.prototype */ {\n    /**\n     * @return {number} Total number of pages the PDF contains.\n     */\n    get numPages() {\n      return this.pdfInfo.numPages;\n    },\n    /**\n     * @return {string} A unique ID to identify a PDF. Not guaranteed to be\n     * unique.\n     */\n    get fingerprint() {\n      return this.pdfInfo.fingerprint;\n    },\n    /**\n     * @param {number} pageNumber The page number to get. The first page is 1.\n     * @return {Promise} A promise that is resolved with a {@link PDFPageProxy}\n     * object.\n     */\n    getPage: function PDFDocumentProxy_getPage(pageNumber) {\n      return this.transport.getPage(pageNumber);\n    },\n    /**\n     * @param {{num: number, gen: number}} ref The page reference. Must have\n     *   the 'num' and 'gen' properties.\n     * @return {Promise} A promise that is resolved with the page index that is\n     * associated with the reference.\n     */\n    getPageIndex: function PDFDocumentProxy_getPageIndex(ref) {\n      return this.transport.getPageIndex(ref);\n    },\n    /**\n     * @return {Promise} A promise that is resolved with a lookup table for\n     * mapping named destinations to reference numbers.\n     *\n     * This can be slow for large documents: use getDestination instead\n     */\n    getDestinations: function PDFDocumentProxy_getDestinations() {\n      return this.transport.getDestinations();\n    },\n    /**\n     * @param {string} id The named destination to get.\n     * @return {Promise} A promise that is resolved with all information\n     * of the given named destination.\n     */\n    getDestination: function PDFDocumentProxy_getDestination(id) {\n      return this.transport.getDestination(id);\n    },\n    /**\n     * @return {Promise} A promise that is resolved with a lookup table for\n     * mapping named attachments to their content.\n     */\n    getAttachments: function PDFDocumentProxy_getAttachments() {\n      return this.transport.getAttachments();\n    },\n    /**\n     * @return {Promise} A promise that is resolved with an array of all the\n     * JavaScript strings in the name tree.\n     */\n    getJavaScript: function PDFDocumentProxy_getJavaScript() {\n      return this.transport.getJavaScript();\n    },\n    /**\n     * @return {Promise} A promise that is resolved with an {Array} that is a\n     * tree outline (if it has one) of the PDF. The tree is in the format of:\n     * [\n     *  {\n     *   title: string,\n     *   bold: boolean,\n     *   italic: boolean,\n     *   color: rgb array,\n     *   dest: dest obj,\n     *   items: array of more items like this\n     *  },\n     *  ...\n     * ].\n     */\n    getOutline: function PDFDocumentProxy_getOutline() {\n      return this.transport.getOutline();\n    },\n    /**\n     * @return {Promise} A promise that is resolved with an {Object} that has\n     * info and metadata properties.  Info is an {Object} filled with anything\n     * available in the information dictionary and similarly metadata is a\n     * {Metadata} object with information from the metadata section of the PDF.\n     */\n    getMetadata: function PDFDocumentProxy_getMetadata() {\n      return this.transport.getMetadata();\n    },\n    /**\n     * @return {Promise} A promise that is resolved with a TypedArray that has\n     * the raw data from the PDF.\n     */\n    getData: function PDFDocumentProxy_getData() {\n      return this.transport.getData();\n    },\n    /**\n     * @return {Promise} A promise that is resolved when the document's data\n     * is loaded. It is resolved with an {Object} that contains the length\n     * property that indicates size of the PDF data in bytes.\n     */\n    getDownloadInfo: function PDFDocumentProxy_getDownloadInfo() {\n      return this.transport.downloadInfoCapability.promise;\n    },\n    /**\n     * @return {Promise} A promise this is resolved with current stats about\n     * document structures (see {@link PDFDocumentStats}).\n     */\n    getStats: function PDFDocumentProxy_getStats() {\n      return this.transport.getStats();\n    },\n    /**\n     * Cleans up resources allocated by the document, e.g. created @font-face.\n     */\n    cleanup: function PDFDocumentProxy_cleanup() {\n      this.transport.startCleanup();\n    },\n    /**\n     * Destroys current document instance and terminates worker.\n     */\n    destroy: function PDFDocumentProxy_destroy() {\n      this.transport.destroy();\n    }\n  };\n  return PDFDocumentProxy;\n})();\n\n/**\n * Page text content.\n *\n * @typedef {Object} TextContent\n * @property {array} items - array of {@link TextItem}\n * @property {Object} styles - {@link TextStyles} objects, indexed by font\n *                    name.\n */\n\n/**\n * Page text content part.\n *\n * @typedef {Object} TextItem\n * @property {string} str - text content.\n * @property {string} dir - text direction: 'ttb', 'ltr' or 'rtl'.\n * @property {array} transform - transformation matrix.\n * @property {number} width - width in device space.\n * @property {number} height - height in device space.\n * @property {string} fontName - font name used by pdf.js for converted font.\n */\n\n/**\n * Text style.\n *\n * @typedef {Object} TextStyle\n * @property {number} ascent - font ascent.\n * @property {number} descent - font descent.\n * @property {boolean} vertical - text is in vertical mode.\n * @property {string} fontFamily - possible font family\n */\n\n/**\n * Page render parameters.\n *\n * @typedef {Object} RenderParameters\n * @property {Object} canvasContext - A 2D context of a DOM Canvas object.\n * @property {PDFJS.PageViewport} viewport - Rendering viewport obtained by\n *                                calling of PDFPage.getViewport method.\n * @property {string} intent - Rendering intent, can be 'display' or 'print'\n *                    (default value is 'display').\n * @property {Object} imageLayer - (optional) An object that has beginLayout,\n *                    endLayout and appendImage functions.\n * @property {function} continueCallback - (deprecated) A function that will be\n *                      called each time the rendering is paused.  To continue\n *                      rendering call the function that is the first argument\n *                      to the callback.\n */\n\n/**\n * PDF page operator list.\n *\n * @typedef {Object} PDFOperatorList\n * @property {Array} fnArray - Array containing the operator functions.\n * @property {Array} argsArray - Array containing the arguments of the\n *                               functions.\n */\n\n/**\n * Proxy to a PDFPage in the worker thread.\n * @class\n */\nvar PDFPageProxy = (function PDFPageProxyClosure() {\n  function PDFPageProxy(pageIndex, pageInfo, transport) {\n    this.pageIndex = pageIndex;\n    this.pageInfo = pageInfo;\n    this.transport = transport;\n    this.stats = new StatTimer();\n    this.stats.enabled = !!globalScope.PDFJS.enableStats;\n    this.commonObjs = transport.commonObjs;\n    this.objs = new PDFObjects();\n    this.cleanupAfterRender = false;\n    this.pendingDestroy = false;\n    this.intentStates = {};\n  }\n  PDFPageProxy.prototype = /** @lends PDFPageProxy.prototype */ {\n    /**\n     * @return {number} Page number of the page. First page is 1.\n     */\n    get pageNumber() {\n      return this.pageIndex + 1;\n    },\n    /**\n     * @return {number} The number of degrees the page is rotated clockwise.\n     */\n    get rotate() {\n      return this.pageInfo.rotate;\n    },\n    /**\n     * @return {Object} The reference that points to this page. It has 'num' and\n     * 'gen' properties.\n     */\n    get ref() {\n      return this.pageInfo.ref;\n    },\n    /**\n     * @return {Array} An array of the visible portion of the PDF page in the\n     * user space units - [x1, y1, x2, y2].\n     */\n    get view() {\n      return this.pageInfo.view;\n    },\n    /**\n     * @param {number} scale The desired scale of the viewport.\n     * @param {number} rotate Degrees to rotate the viewport. If omitted this\n     * defaults to the page rotation.\n     * @return {PDFJS.PageViewport} Contains 'width' and 'height' properties\n     * along with transforms required for rendering.\n     */\n    getViewport: function PDFPageProxy_getViewport(scale, rotate) {\n      if (arguments.length < 2) {\n        rotate = this.rotate;\n      }\n      return new PDFJS.PageViewport(this.view, scale, rotate, 0, 0);\n    },\n    /**\n     * @return {Promise} A promise that is resolved with an {Array} of the\n     * annotation objects.\n     */\n    getAnnotations: function PDFPageProxy_getAnnotations() {\n      if (this.annotationsPromise) {\n        return this.annotationsPromise;\n      }\n\n      var promise = this.transport.getAnnotations(this.pageIndex);\n      this.annotationsPromise = promise;\n      return promise;\n    },\n    /**\n     * Begins the process of rendering a page to the desired context.\n     * @param {RenderParameters} params Page render parameters.\n     * @return {RenderTask} An object that contains the promise, which\n     *                      is resolved when the page finishes rendering.\n     */\n    render: function PDFPageProxy_render(params) {\n      var stats = this.stats;\n      stats.time('Overall');\n\n      // If there was a pending destroy cancel it so no cleanup happens during\n      // this call to render.\n      this.pendingDestroy = false;\n\n      var renderingIntent = (params.intent === 'print' ? 'print' : 'display');\n\n      if (!this.intentStates[renderingIntent]) {\n        this.intentStates[renderingIntent] = {};\n      }\n      var intentState = this.intentStates[renderingIntent];\n\n      // If there's no displayReadyCapability yet, then the operatorList\n      // was never requested before. Make the request and create the promise.\n      if (!intentState.displayReadyCapability) {\n        intentState.receivingOperatorList = true;\n        intentState.displayReadyCapability = createPromiseCapability();\n        intentState.operatorList = {\n          fnArray: [],\n          argsArray: [],\n          lastChunk: false\n        };\n\n        this.stats.time('Page Request');\n        this.transport.messageHandler.send('RenderPageRequest', {\n          pageIndex: this.pageNumber - 1,\n          intent: renderingIntent\n        });\n      }\n\n      var internalRenderTask = new InternalRenderTask(complete, params,\n                                                      this.objs,\n                                                      this.commonObjs,\n                                                      intentState.operatorList,\n                                                      this.pageNumber);\n      if (!intentState.renderTasks) {\n        intentState.renderTasks = [];\n      }\n      intentState.renderTasks.push(internalRenderTask);\n      var renderTask = internalRenderTask.task;\n\n      // Obsolete parameter support\n      if (params.continueCallback) {\n        renderTask.onContinue = params.continueCallback;\n      }\n\n      var self = this;\n      intentState.displayReadyCapability.promise.then(\n        function pageDisplayReadyPromise(transparency) {\n          if (self.pendingDestroy) {\n            complete();\n            return;\n          }\n          stats.time('Rendering');\n          internalRenderTask.initalizeGraphics(transparency);\n          internalRenderTask.operatorListChanged();\n        },\n        function pageDisplayReadPromiseError(reason) {\n          complete(reason);\n        }\n      );\n\n      function complete(error) {\n        var i = intentState.renderTasks.indexOf(internalRenderTask);\n        if (i >= 0) {\n          intentState.renderTasks.splice(i, 1);\n        }\n\n        if (self.cleanupAfterRender) {\n          self.pendingDestroy = true;\n        }\n        self._tryDestroy();\n\n        if (error) {\n          internalRenderTask.capability.reject(error);\n        } else {\n          internalRenderTask.capability.resolve();\n        }\n        stats.timeEnd('Rendering');\n        stats.timeEnd('Overall');\n      }\n\n      return renderTask;\n    },\n\n    /**\n     * @return {Promise} A promise resolved with an {@link PDFOperatorList}\n     * object that represents page's operator list.\n     */\n    getOperatorList: function PDFPageProxy_getOperatorList() {\n      function operatorListChanged() {\n        if (intentState.operatorList.lastChunk) {\n          intentState.opListReadCapability.resolve(intentState.operatorList);\n        }\n      }\n\n      var renderingIntent = 'oplist';\n      if (!this.intentStates[renderingIntent]) {\n        this.intentStates[renderingIntent] = {};\n      }\n      var intentState = this.intentStates[renderingIntent];\n\n      if (!intentState.opListReadCapability) {\n        var opListTask = {};\n        opListTask.operatorListChanged = operatorListChanged;\n        intentState.receivingOperatorList = true;\n        intentState.opListReadCapability = createPromiseCapability();\n        intentState.renderTasks = [];\n        intentState.renderTasks.push(opListTask);\n        intentState.operatorList = {\n          fnArray: [],\n          argsArray: [],\n          lastChunk: false\n        };\n\n        this.transport.messageHandler.send('RenderPageRequest', {\n          pageIndex: this.pageIndex,\n          intent: renderingIntent\n        });\n      }\n      return intentState.opListReadCapability.promise;\n    },\n\n    /**\n     * @return {Promise} That is resolved a {@link TextContent}\n     * object that represent the page text content.\n     */\n    getTextContent: function PDFPageProxy_getTextContent() {\n      return this.transport.messageHandler.sendWithPromise('GetTextContent', {\n        pageIndex: this.pageNumber - 1\n      });\n    },\n    /**\n     * Destroys resources allocated by the page.\n     */\n    destroy: function PDFPageProxy_destroy() {\n      this.pendingDestroy = true;\n      this._tryDestroy();\n    },\n    /**\n     * For internal use only. Attempts to clean up if rendering is in a state\n     * where that's possible.\n     * @ignore\n     */\n    _tryDestroy: function PDFPageProxy__destroy() {\n      if (!this.pendingDestroy ||\n          Object.keys(this.intentStates).some(function(intent) {\n            var intentState = this.intentStates[intent];\n            return (intentState.renderTasks.length !== 0 ||\n                    intentState.receivingOperatorList);\n          }, this)) {\n        return;\n      }\n\n      Object.keys(this.intentStates).forEach(function(intent) {\n        delete this.intentStates[intent];\n      }, this);\n      this.objs.clear();\n      this.annotationsPromise = null;\n      this.pendingDestroy = false;\n    },\n    /**\n     * For internal use only.\n     * @ignore\n     */\n    _startRenderPage: function PDFPageProxy_startRenderPage(transparency,\n                                                            intent) {\n      var intentState = this.intentStates[intent];\n      // TODO Refactor RenderPageRequest to separate rendering\n      // and operator list logic\n      if (intentState.displayReadyCapability) {\n        intentState.displayReadyCapability.resolve(transparency);\n      }\n    },\n    /**\n     * For internal use only.\n     * @ignore\n     */\n    _renderPageChunk: function PDFPageProxy_renderPageChunk(operatorListChunk,\n                                                            intent) {\n      var intentState = this.intentStates[intent];\n      var i, ii;\n      // Add the new chunk to the current operator list.\n      for (i = 0, ii = operatorListChunk.length; i < ii; i++) {\n        intentState.operatorList.fnArray.push(operatorListChunk.fnArray[i]);\n        intentState.operatorList.argsArray.push(\n          operatorListChunk.argsArray[i]);\n      }\n      intentState.operatorList.lastChunk = operatorListChunk.lastChunk;\n\n      // Notify all the rendering tasks there are more operators to be consumed.\n      for (i = 0; i < intentState.renderTasks.length; i++) {\n        intentState.renderTasks[i].operatorListChanged();\n      }\n\n      if (operatorListChunk.lastChunk) {\n        intentState.receivingOperatorList = false;\n        this._tryDestroy();\n      }\n    }\n  };\n  return PDFPageProxy;\n})();\n\n/**\n * For internal use only.\n * @ignore\n */\nvar WorkerTransport = (function WorkerTransportClosure() {\n  function WorkerTransport(workerInitializedCapability, pdfDataRangeTransport) {\n    this.pdfDataRangeTransport = pdfDataRangeTransport;\n    this.workerInitializedCapability = workerInitializedCapability;\n    this.commonObjs = new PDFObjects();\n\n    this.loadingTask = null;\n\n    this.pageCache = [];\n    this.pagePromises = [];\n    this.downloadInfoCapability = createPromiseCapability();\n\n    // If worker support isn't disabled explicit and the browser has worker\n    // support, create a new web worker and test if it/the browser fullfills\n    // all requirements to run parts of pdf.js in a web worker.\n    // Right now, the requirement is, that an Uint8Array is still an Uint8Array\n    // as it arrives on the worker. Chrome added this with version 15.\n    if (!globalScope.PDFJS.disableWorker && typeof Worker !== 'undefined') {\n      var workerSrc = PDFJS.workerSrc;\n      if (!workerSrc) {\n        error('No PDFJS.workerSrc specified');\n      }\n\n      try {\n        // Some versions of FF can't create a worker on localhost, see:\n        // https://bugzilla.mozilla.org/show_bug.cgi?id=683280\n        var worker = new Worker(workerSrc);\n        var messageHandler = new MessageHandler('main', worker);\n        this.messageHandler = messageHandler;\n\n        messageHandler.on('test', function transportTest(data) {\n          var supportTypedArray = data && data.supportTypedArray;\n          if (supportTypedArray) {\n            this.worker = worker;\n            if (!data.supportTransfers) {\n              PDFJS.postMessageTransfers = false;\n            }\n            this.setupMessageHandler(messageHandler);\n            workerInitializedCapability.resolve();\n          } else {\n            this.setupFakeWorker();\n          }\n        }.bind(this));\n\n        var testObj = new Uint8Array([PDFJS.postMessageTransfers ? 255 : 0]);\n        // Some versions of Opera throw a DATA_CLONE_ERR on serializing the\n        // typed array. Also, checking if we can use transfers.\n        try {\n          messageHandler.send('test', testObj, [testObj.buffer]);\n        } catch (ex) {\n          info('Cannot use postMessage transfers');\n          testObj[0] = 0;\n          messageHandler.send('test', testObj);\n        }\n        return;\n      } catch (e) {\n        info('The worker has been disabled.');\n      }\n    }\n    // Either workers are disabled, not supported or have thrown an exception.\n    // Thus, we fallback to a faked worker.\n    this.setupFakeWorker();\n  }\n  WorkerTransport.prototype = {\n    destroy: function WorkerTransport_destroy() {\n      this.pageCache = [];\n      this.pagePromises = [];\n      var self = this;\n      this.messageHandler.sendWithPromise('Terminate', null).then(function () {\n        FontLoader.clear();\n        if (self.worker) {\n          self.worker.terminate();\n        }\n      });\n    },\n\n    setupFakeWorker: function WorkerTransport_setupFakeWorker() {\n      globalScope.PDFJS.disableWorker = true;\n\n      if (!PDFJS.fakeWorkerFilesLoadedCapability) {\n        PDFJS.fakeWorkerFilesLoadedCapability = createPromiseCapability();\n        // In the developer build load worker_loader which in turn loads all the\n        // other files and resolves the promise. In production only the\n        // pdf.worker.js file is needed.\n        Util.loadScript(PDFJS.workerSrc, function() {\n          PDFJS.fakeWorkerFilesLoadedCapability.resolve();\n        });\n      }\n      PDFJS.fakeWorkerFilesLoadedCapability.promise.then(function () {\n        warn('Setting up fake worker.');\n        // If we don't use a worker, just post/sendMessage to the main thread.\n        var fakeWorker = {\n          postMessage: function WorkerTransport_postMessage(obj) {\n            fakeWorker.onmessage({data: obj});\n          },\n          terminate: function WorkerTransport_terminate() {}\n        };\n\n        var messageHandler = new MessageHandler('main', fakeWorker);\n        this.setupMessageHandler(messageHandler);\n\n        // If the main thread is our worker, setup the handling for the messages\n        // the main thread sends to it self.\n        PDFJS.WorkerMessageHandler.setup(messageHandler);\n\n        this.workerInitializedCapability.resolve();\n      }.bind(this));\n    },\n\n    setupMessageHandler:\n      function WorkerTransport_setupMessageHandler(messageHandler) {\n      this.messageHandler = messageHandler;\n\n      function updatePassword(password) {\n        messageHandler.send('UpdatePassword', password);\n      }\n\n      var pdfDataRangeTransport = this.pdfDataRangeTransport;\n      if (pdfDataRangeTransport) {\n        pdfDataRangeTransport.addRangeListener(function(begin, chunk) {\n          messageHandler.send('OnDataRange', {\n            begin: begin,\n            chunk: chunk\n          });\n        });\n\n        pdfDataRangeTransport.addProgressListener(function(loaded) {\n          messageHandler.send('OnDataProgress', {\n            loaded: loaded\n          });\n        });\n\n        pdfDataRangeTransport.addProgressiveReadListener(function(chunk) {\n          messageHandler.send('OnDataRange', {\n            chunk: chunk\n          });\n        });\n\n        messageHandler.on('RequestDataRange',\n          function transportDataRange(data) {\n            pdfDataRangeTransport.requestDataRange(data.begin, data.end);\n          }, this);\n      }\n\n      messageHandler.on('GetDoc', function transportDoc(data) {\n        var pdfInfo = data.pdfInfo;\n        this.numPages = data.pdfInfo.numPages;\n        var pdfDocument = new PDFDocumentProxy(pdfInfo, this);\n        this.pdfDocument = pdfDocument;\n        this.loadingTask._capability.resolve(pdfDocument);\n      }, this);\n\n      messageHandler.on('NeedPassword',\n                        function transportNeedPassword(exception) {\n        var loadingTask = this.loadingTask;\n        if (loadingTask.onPassword) {\n          return loadingTask.onPassword(updatePassword,\n                                        PasswordResponses.NEED_PASSWORD);\n        }\n        loadingTask._capability.reject(\n          new PasswordException(exception.message, exception.code));\n      }, this);\n\n      messageHandler.on('IncorrectPassword',\n                        function transportIncorrectPassword(exception) {\n        var loadingTask = this.loadingTask;\n        if (loadingTask.onPassword) {\n          return loadingTask.onPassword(updatePassword,\n                                        PasswordResponses.INCORRECT_PASSWORD);\n        }\n        loadingTask._capability.reject(\n          new PasswordException(exception.message, exception.code));\n      }, this);\n\n      messageHandler.on('InvalidPDF', function transportInvalidPDF(exception) {\n        this.loadingTask._capability.reject(\n          new InvalidPDFException(exception.message));\n      }, this);\n\n      messageHandler.on('MissingPDF', function transportMissingPDF(exception) {\n        this.loadingTask._capability.reject(\n          new MissingPDFException(exception.message));\n      }, this);\n\n      messageHandler.on('UnexpectedResponse',\n                        function transportUnexpectedResponse(exception) {\n        this.loadingTask._capability.reject(\n          new UnexpectedResponseException(exception.message, exception.status));\n      }, this);\n\n      messageHandler.on('UnknownError',\n                        function transportUnknownError(exception) {\n        this.loadingTask._capability.reject(\n          new UnknownErrorException(exception.message, exception.details));\n      }, this);\n\n      messageHandler.on('DataLoaded', function transportPage(data) {\n        this.downloadInfoCapability.resolve(data);\n      }, this);\n\n      messageHandler.on('PDFManagerReady', function transportPage(data) {\n        if (this.pdfDataRangeTransport) {\n          this.pdfDataRangeTransport.transportReady();\n        }\n      }, this);\n\n      messageHandler.on('StartRenderPage', function transportRender(data) {\n        var page = this.pageCache[data.pageIndex];\n\n        page.stats.timeEnd('Page Request');\n        page._startRenderPage(data.transparency, data.intent);\n      }, this);\n\n      messageHandler.on('RenderPageChunk', function transportRender(data) {\n        var page = this.pageCache[data.pageIndex];\n\n        page._renderPageChunk(data.operatorList, data.intent);\n      }, this);\n\n      messageHandler.on('commonobj', function transportObj(data) {\n        var id = data[0];\n        var type = data[1];\n        if (this.commonObjs.hasData(id)) {\n          return;\n        }\n\n        switch (type) {\n          case 'Font':\n            var exportedData = data[2];\n\n            var font;\n            if ('error' in exportedData) {\n              var error = exportedData.error;\n              warn('Error during font loading: ' + error);\n              this.commonObjs.resolve(id, error);\n              break;\n            } else {\n              font = new FontFaceObject(exportedData);\n            }\n\n            FontLoader.bind(\n              [font],\n              function fontReady(fontObjs) {\n                this.commonObjs.resolve(id, font);\n              }.bind(this)\n            );\n            break;\n          case 'FontPath':\n            this.commonObjs.resolve(id, data[2]);\n            break;\n          default:\n            error('Got unknown common object type ' + type);\n        }\n      }, this);\n\n      messageHandler.on('obj', function transportObj(data) {\n        var id = data[0];\n        var pageIndex = data[1];\n        var type = data[2];\n        var pageProxy = this.pageCache[pageIndex];\n        var imageData;\n        if (pageProxy.objs.hasData(id)) {\n          return;\n        }\n\n        switch (type) {\n          case 'JpegStream':\n            imageData = data[3];\n            loadJpegStream(id, imageData, pageProxy.objs);\n            break;\n          case 'Image':\n            imageData = data[3];\n            pageProxy.objs.resolve(id, imageData);\n\n            // heuristics that will allow not to store large data\n            var MAX_IMAGE_SIZE_TO_STORE = 8000000;\n            if (imageData && 'data' in imageData &&\n                imageData.data.length > MAX_IMAGE_SIZE_TO_STORE) {\n              pageProxy.cleanupAfterRender = true;\n            }\n            break;\n          default:\n            error('Got unknown object type ' + type);\n        }\n      }, this);\n\n      messageHandler.on('DocProgress', function transportDocProgress(data) {\n        var loadingTask = this.loadingTask;\n        if (loadingTask.onProgress) {\n          loadingTask.onProgress({\n            loaded: data.loaded,\n            total: data.total\n          });\n        }\n      }, this);\n\n      messageHandler.on('PageError', function transportError(data) {\n        var page = this.pageCache[data.pageNum - 1];\n        var intentState = page.intentStates[data.intent];\n        if (intentState.displayReadyCapability) {\n          intentState.displayReadyCapability.reject(data.error);\n        } else {\n          error(data.error);\n        }\n      }, this);\n\n      messageHandler.on('JpegDecode', function(data) {\n        var imageUrl = data[0];\n        var components = data[1];\n        if (components !== 3 && components !== 1) {\n          return Promise.reject(\n            new Error('Only 3 components or 1 component can be returned'));\n        }\n\n        return new Promise(function (resolve, reject) {\n          var img = new Image();\n          img.onload = function () {\n            var width = img.width;\n            var height = img.height;\n            var size = width * height;\n            var rgbaLength = size * 4;\n            var buf = new Uint8Array(size * components);\n            var tmpCanvas = createScratchCanvas(width, height);\n            var tmpCtx = tmpCanvas.getContext('2d');\n            tmpCtx.drawImage(img, 0, 0);\n            var data = tmpCtx.getImageData(0, 0, width, height).data;\n            var i, j;\n\n            if (components === 3) {\n              for (i = 0, j = 0; i < rgbaLength; i += 4, j += 3) {\n                buf[j] = data[i];\n                buf[j + 1] = data[i + 1];\n                buf[j + 2] = data[i + 2];\n              }\n            } else if (components === 1) {\n              for (i = 0, j = 0; i < rgbaLength; i += 4, j++) {\n                buf[j] = data[i];\n              }\n            }\n            resolve({ data: buf, width: width, height: height});\n          };\n          img.onerror = function () {\n            reject(new Error('JpegDecode failed to load image'));\n          };\n          img.src = imageUrl;\n        });\n      });\n    },\n\n    fetchDocument: function WorkerTransport_fetchDocument(loadingTask, source) {\n      this.loadingTask = loadingTask;\n\n      source.disableAutoFetch = PDFJS.disableAutoFetch;\n      source.disableStream = PDFJS.disableStream;\n      source.chunkedViewerLoading = !!this.pdfDataRangeTransport;\n      if (this.pdfDataRangeTransport) {\n        source.length = this.pdfDataRangeTransport.length;\n        source.initialData = this.pdfDataRangeTransport.initialData;\n      }\n      this.messageHandler.send('GetDocRequest', {\n        source: source,\n        disableRange: PDFJS.disableRange,\n        maxImageSize: PDFJS.maxImageSize,\n        cMapUrl: PDFJS.cMapUrl,\n        cMapPacked: PDFJS.cMapPacked,\n        disableFontFace: PDFJS.disableFontFace,\n        disableCreateObjectURL: PDFJS.disableCreateObjectURL,\n        verbosity: PDFJS.verbosity\n      });\n    },\n\n    getData: function WorkerTransport_getData() {\n      return this.messageHandler.sendWithPromise('GetData', null);\n    },\n\n    getPage: function WorkerTransport_getPage(pageNumber, capability) {\n      if (pageNumber <= 0 || pageNumber > this.numPages ||\n          (pageNumber|0) !== pageNumber) {\n        return Promise.reject(new Error('Invalid page request'));\n      }\n\n      var pageIndex = pageNumber - 1;\n      if (pageIndex in this.pagePromises) {\n        return this.pagePromises[pageIndex];\n      }\n      var promise = this.messageHandler.sendWithPromise('GetPage', {\n        pageIndex: pageIndex\n      }).then(function (pageInfo) {\n        var page = new PDFPageProxy(pageIndex, pageInfo, this);\n        this.pageCache[pageIndex] = page;\n        return page;\n      }.bind(this));\n      this.pagePromises[pageIndex] = promise;\n      return promise;\n    },\n\n    getPageIndex: function WorkerTransport_getPageIndexByRef(ref) {\n      return this.messageHandler.sendWithPromise('GetPageIndex', { ref: ref });\n    },\n\n    getAnnotations: function WorkerTransport_getAnnotations(pageIndex) {\n      return this.messageHandler.sendWithPromise('GetAnnotations',\n        { pageIndex: pageIndex });\n    },\n\n    getDestinations: function WorkerTransport_getDestinations() {\n      return this.messageHandler.sendWithPromise('GetDestinations', null);\n    },\n\n    getDestination: function WorkerTransport_getDestination(id) {\n      return this.messageHandler.sendWithPromise('GetDestination', { id: id } );\n    },\n\n    getAttachments: function WorkerTransport_getAttachments() {\n      return this.messageHandler.sendWithPromise('GetAttachments', null);\n    },\n\n    getJavaScript: function WorkerTransport_getJavaScript() {\n      return this.messageHandler.sendWithPromise('GetJavaScript', null);\n    },\n\n    getOutline: function WorkerTransport_getOutline() {\n      return this.messageHandler.sendWithPromise('GetOutline', null);\n    },\n\n    getMetadata: function WorkerTransport_getMetadata() {\n      return this.messageHandler.sendWithPromise('GetMetadata', null).\n        then(function transportMetadata(results) {\n        return {\n          info: results[0],\n          metadata: (results[1] ? new PDFJS.Metadata(results[1]) : null)\n        };\n      });\n    },\n\n    getStats: function WorkerTransport_getStats() {\n      return this.messageHandler.sendWithPromise('GetStats', null);\n    },\n\n    startCleanup: function WorkerTransport_startCleanup() {\n      this.messageHandler.sendWithPromise('Cleanup', null).\n        then(function endCleanup() {\n        for (var i = 0, ii = this.pageCache.length; i < ii; i++) {\n          var page = this.pageCache[i];\n          if (page) {\n            page.destroy();\n          }\n        }\n        this.commonObjs.clear();\n        FontLoader.clear();\n      }.bind(this));\n    }\n  };\n  return WorkerTransport;\n\n})();\n\n/**\n * A PDF document and page is built of many objects. E.g. there are objects\n * for fonts, images, rendering code and such. These objects might get processed\n * inside of a worker. The `PDFObjects` implements some basic functions to\n * manage these objects.\n * @ignore\n */\nvar PDFObjects = (function PDFObjectsClosure() {\n  function PDFObjects() {\n    this.objs = {};\n  }\n\n  PDFObjects.prototype = {\n    /**\n     * Internal function.\n     * Ensures there is an object defined for `objId`.\n     */\n    ensureObj: function PDFObjects_ensureObj(objId) {\n      if (this.objs[objId]) {\n        return this.objs[objId];\n      }\n\n      var obj = {\n        capability: createPromiseCapability(),\n        data: null,\n        resolved: false\n      };\n      this.objs[objId] = obj;\n\n      return obj;\n    },\n\n    /**\n     * If called *without* callback, this returns the data of `objId` but the\n     * object needs to be resolved. If it isn't, this function throws.\n     *\n     * If called *with* a callback, the callback is called with the data of the\n     * object once the object is resolved. That means, if you call this\n     * function and the object is already resolved, the callback gets called\n     * right away.\n     */\n    get: function PDFObjects_get(objId, callback) {\n      // If there is a callback, then the get can be async and the object is\n      // not required to be resolved right now\n      if (callback) {\n        this.ensureObj(objId).capability.promise.then(callback);\n        return null;\n      }\n\n      // If there isn't a callback, the user expects to get the resolved data\n      // directly.\n      var obj = this.objs[objId];\n\n      // If there isn't an object yet or the object isn't resolved, then the\n      // data isn't ready yet!\n      if (!obj || !obj.resolved) {\n        error('Requesting object that isn\\'t resolved yet ' + objId);\n      }\n\n      return obj.data;\n    },\n\n    /**\n     * Resolves the object `objId` with optional `data`.\n     */\n    resolve: function PDFObjects_resolve(objId, data) {\n      var obj = this.ensureObj(objId);\n\n      obj.resolved = true;\n      obj.data = data;\n      obj.capability.resolve(data);\n    },\n\n    isResolved: function PDFObjects_isResolved(objId) {\n      var objs = this.objs;\n\n      if (!objs[objId]) {\n        return false;\n      } else {\n        return objs[objId].resolved;\n      }\n    },\n\n    hasData: function PDFObjects_hasData(objId) {\n      return this.isResolved(objId);\n    },\n\n    /**\n     * Returns the data of `objId` if object exists, null otherwise.\n     */\n    getData: function PDFObjects_getData(objId) {\n      var objs = this.objs;\n      if (!objs[objId] || !objs[objId].resolved) {\n        return null;\n      } else {\n        return objs[objId].data;\n      }\n    },\n\n    clear: function PDFObjects_clear() {\n      this.objs = {};\n    }\n  };\n  return PDFObjects;\n})();\n\n/**\n * Allows controlling of the rendering tasks.\n * @class\n */\nvar RenderTask = (function RenderTaskClosure() {\n  function RenderTask(internalRenderTask) {\n    this._internalRenderTask = internalRenderTask;\n\n    /**\n     * Callback for incremental rendering -- a function that will be called\n     * each time the rendering is paused.  To continue rendering call the\n     * function that is the first argument to the callback.\n     * @type {function}\n     */\n    this.onContinue = null;\n  }\n\n  RenderTask.prototype = /** @lends RenderTask.prototype */ {\n    /**\n     * Promise for rendering task completion.\n     * @return {Promise}\n     */\n    get promise() {\n      return this._internalRenderTask.capability.promise;\n    },\n\n    /**\n     * Cancels the rendering task. If the task is currently rendering it will\n     * not be cancelled until graphics pauses with a timeout. The promise that\n     * this object extends will resolved when cancelled.\n     */\n    cancel: function RenderTask_cancel() {\n      this._internalRenderTask.cancel();\n    },\n\n    /**\n     * Registers callbacks to indicate the rendering task completion.\n     *\n     * @param {function} onFulfilled The callback for the rendering completion.\n     * @param {function} onRejected The callback for the rendering failure.\n     * @return {Promise} A promise that is resolved after the onFulfilled or\n     *                   onRejected callback.\n     */\n    then: function RenderTask_then(onFulfilled, onRejected) {\n      return this.promise.then.apply(this.promise, arguments);\n    }\n  };\n\n  return RenderTask;\n})();\n\n/**\n * For internal use only.\n * @ignore\n */\nvar InternalRenderTask = (function InternalRenderTaskClosure() {\n\n  function InternalRenderTask(callback, params, objs, commonObjs, operatorList,\n                              pageNumber) {\n    this.callback = callback;\n    this.params = params;\n    this.objs = objs;\n    this.commonObjs = commonObjs;\n    this.operatorListIdx = null;\n    this.operatorList = operatorList;\n    this.pageNumber = pageNumber;\n    this.running = false;\n    this.graphicsReadyCallback = null;\n    this.graphicsReady = false;\n    this.cancelled = false;\n    this.capability = createPromiseCapability();\n    this.task = new RenderTask(this);\n    // caching this-bound methods\n    this._continueBound = this._continue.bind(this);\n    this._scheduleNextBound = this._scheduleNext.bind(this);\n    this._nextBound = this._next.bind(this);\n  }\n\n  InternalRenderTask.prototype = {\n\n    initalizeGraphics:\n        function InternalRenderTask_initalizeGraphics(transparency) {\n\n      if (this.cancelled) {\n        return;\n      }\n      if (PDFJS.pdfBug && 'StepperManager' in globalScope &&\n          globalScope.StepperManager.enabled) {\n        this.stepper = globalScope.StepperManager.create(this.pageNumber - 1);\n        this.stepper.init(this.operatorList);\n        this.stepper.nextBreakPoint = this.stepper.getNextBreakPoint();\n      }\n\n      var params = this.params;\n      this.gfx = new CanvasGraphics(params.canvasContext, this.commonObjs,\n                                    this.objs, params.imageLayer);\n\n      this.gfx.beginDrawing(params.viewport, transparency);\n      this.operatorListIdx = 0;\n      this.graphicsReady = true;\n      if (this.graphicsReadyCallback) {\n        this.graphicsReadyCallback();\n      }\n    },\n\n    cancel: function InternalRenderTask_cancel() {\n      this.running = false;\n      this.cancelled = true;\n      this.callback('cancelled');\n    },\n\n    operatorListChanged: function InternalRenderTask_operatorListChanged() {\n      if (!this.graphicsReady) {\n        if (!this.graphicsReadyCallback) {\n          this.graphicsReadyCallback = this._continueBound;\n        }\n        return;\n      }\n\n      if (this.stepper) {\n        this.stepper.updateOperatorList(this.operatorList);\n      }\n\n      if (this.running) {\n        return;\n      }\n      this._continue();\n    },\n\n    _continue: function InternalRenderTask__continue() {\n      this.running = true;\n      if (this.cancelled) {\n        return;\n      }\n      if (this.task.onContinue) {\n        this.task.onContinue.call(this.task, this._scheduleNextBound);\n      } else {\n        this._scheduleNext();\n      }\n    },\n\n    _scheduleNext: function InternalRenderTask__scheduleNext() {\n      window.requestAnimationFrame(this._nextBound);\n    },\n\n    _next: function InternalRenderTask__next() {\n      if (this.cancelled) {\n        return;\n      }\n      this.operatorListIdx = this.gfx.executeOperatorList(this.operatorList,\n                                        this.operatorListIdx,\n                                        this._continueBound,\n                                        this.stepper);\n      if (this.operatorListIdx === this.operatorList.argsArray.length) {\n        this.running = false;\n        if (this.operatorList.lastChunk) {\n          this.gfx.endDrawing();\n          this.callback();\n        }\n      }\n    }\n\n  };\n\n  return InternalRenderTask;\n})();\n\n\nvar Metadata = PDFJS.Metadata = (function MetadataClosure() {\n  function fixMetadata(meta) {\n    return meta.replace(/>\\\\376\\\\377([^<]+)/g, function(all, codes) {\n      var bytes = codes.replace(/\\\\([0-3])([0-7])([0-7])/g,\n                                function(code, d1, d2, d3) {\n        return String.fromCharCode(d1 * 64 + d2 * 8 + d3 * 1);\n      });\n      var chars = '';\n      for (var i = 0; i < bytes.length; i += 2) {\n        var code = bytes.charCodeAt(i) * 256 + bytes.charCodeAt(i + 1);\n        chars += code >= 32 && code < 127 && code !== 60 && code !== 62 &&\n          code !== 38 && false ? String.fromCharCode(code) :\n          '&#x' + (0x10000 + code).toString(16).substring(1) + ';';\n      }\n      return '>' + chars;\n    });\n  }\n\n  function Metadata(meta) {\n    if (typeof meta === 'string') {\n      // Ghostscript produces invalid metadata\n      meta = fixMetadata(meta);\n\n      var parser = new DOMParser();\n      meta = parser.parseFromString(meta, 'application/xml');\n    } else if (!(meta instanceof Document)) {\n      error('Metadata: Invalid metadata object');\n    }\n\n    this.metaDocument = meta;\n    this.metadata = {};\n    this.parse();\n  }\n\n  Metadata.prototype = {\n    parse: function Metadata_parse() {\n      var doc = this.metaDocument;\n      var rdf = doc.documentElement;\n\n      if (rdf.nodeName.toLowerCase() !== 'rdf:rdf') { // Wrapped in <xmpmeta>\n        rdf = rdf.firstChild;\n        while (rdf && rdf.nodeName.toLowerCase() !== 'rdf:rdf') {\n          rdf = rdf.nextSibling;\n        }\n      }\n\n      var nodeName = (rdf) ? rdf.nodeName.toLowerCase() : null;\n      if (!rdf || nodeName !== 'rdf:rdf' || !rdf.hasChildNodes()) {\n        return;\n      }\n\n      var children = rdf.childNodes, desc, entry, name, i, ii, length, iLength;\n      for (i = 0, length = children.length; i < length; i++) {\n        desc = children[i];\n        if (desc.nodeName.toLowerCase() !== 'rdf:description') {\n          continue;\n        }\n\n        for (ii = 0, iLength = desc.childNodes.length; ii < iLength; ii++) {\n          if (desc.childNodes[ii].nodeName.toLowerCase() !== '#text') {\n            entry = desc.childNodes[ii];\n            name = entry.nodeName.toLowerCase();\n            this.metadata[name] = entry.textContent.trim();\n          }\n        }\n      }\n    },\n\n    get: function Metadata_get(name) {\n      return this.metadata[name] || null;\n    },\n\n    has: function Metadata_has(name) {\n      return typeof this.metadata[name] !== 'undefined';\n    }\n  };\n\n  return Metadata;\n})();\n\n\n// <canvas> contexts store most of the state we need natively.\n// However, PDF needs a bit more state, which we store here.\n\n// Minimal font size that would be used during canvas fillText operations.\nvar MIN_FONT_SIZE = 16;\n// Maximum font size that would be used during canvas fillText operations.\nvar MAX_FONT_SIZE = 100;\nvar MAX_GROUP_SIZE = 4096;\n\n// Heuristic value used when enforcing minimum line widths.\nvar MIN_WIDTH_FACTOR = 0.65;\n\nvar COMPILE_TYPE3_GLYPHS = true;\nvar MAX_SIZE_TO_COMPILE = 1000;\n\nvar FULL_CHUNK_HEIGHT = 16;\n\nfunction createScratchCanvas(width, height) {\n  var canvas = document.createElement('canvas');\n  canvas.width = width;\n  canvas.height = height;\n  return canvas;\n}\n\nfunction addContextCurrentTransform(ctx) {\n  // If the context doesn't expose a `mozCurrentTransform`, add a JS based one.\n  if (!ctx.mozCurrentTransform) {\n    ctx._originalSave = ctx.save;\n    ctx._originalRestore = ctx.restore;\n    ctx._originalRotate = ctx.rotate;\n    ctx._originalScale = ctx.scale;\n    ctx._originalTranslate = ctx.translate;\n    ctx._originalTransform = ctx.transform;\n    ctx._originalSetTransform = ctx.setTransform;\n\n    ctx._transformMatrix = ctx._transformMatrix || [1, 0, 0, 1, 0, 0];\n    ctx._transformStack = [];\n\n    Object.defineProperty(ctx, 'mozCurrentTransform', {\n      get: function getCurrentTransform() {\n        return this._transformMatrix;\n      }\n    });\n\n    Object.defineProperty(ctx, 'mozCurrentTransformInverse', {\n      get: function getCurrentTransformInverse() {\n        // Calculation done using WolframAlpha:\n        // http://www.wolframalpha.com/input/?\n        //   i=Inverse+{{a%2C+c%2C+e}%2C+{b%2C+d%2C+f}%2C+{0%2C+0%2C+1}}\n\n        var m = this._transformMatrix;\n        var a = m[0], b = m[1], c = m[2], d = m[3], e = m[4], f = m[5];\n\n        var ad_bc = a * d - b * c;\n        var bc_ad = b * c - a * d;\n\n        return [\n          d / ad_bc,\n          b / bc_ad,\n          c / bc_ad,\n          a / ad_bc,\n          (d * e - c * f) / bc_ad,\n          (b * e - a * f) / ad_bc\n        ];\n      }\n    });\n\n    ctx.save = function ctxSave() {\n      var old = this._transformMatrix;\n      this._transformStack.push(old);\n      this._transformMatrix = old.slice(0, 6);\n\n      this._originalSave();\n    };\n\n    ctx.restore = function ctxRestore() {\n      var prev = this._transformStack.pop();\n      if (prev) {\n        this._transformMatrix = prev;\n        this._originalRestore();\n      }\n    };\n\n    ctx.translate = function ctxTranslate(x, y) {\n      var m = this._transformMatrix;\n      m[4] = m[0] * x + m[2] * y + m[4];\n      m[5] = m[1] * x + m[3] * y + m[5];\n\n      this._originalTranslate(x, y);\n    };\n\n    ctx.scale = function ctxScale(x, y) {\n      var m = this._transformMatrix;\n      m[0] = m[0] * x;\n      m[1] = m[1] * x;\n      m[2] = m[2] * y;\n      m[3] = m[3] * y;\n\n      this._originalScale(x, y);\n    };\n\n    ctx.transform = function ctxTransform(a, b, c, d, e, f) {\n      var m = this._transformMatrix;\n      this._transformMatrix = [\n        m[0] * a + m[2] * b,\n        m[1] * a + m[3] * b,\n        m[0] * c + m[2] * d,\n        m[1] * c + m[3] * d,\n        m[0] * e + m[2] * f + m[4],\n        m[1] * e + m[3] * f + m[5]\n      ];\n\n      ctx._originalTransform(a, b, c, d, e, f);\n    };\n\n    ctx.setTransform = function ctxSetTransform(a, b, c, d, e, f) {\n      this._transformMatrix = [a, b, c, d, e, f];\n\n      ctx._originalSetTransform(a, b, c, d, e, f);\n    };\n\n    ctx.rotate = function ctxRotate(angle) {\n      var cosValue = Math.cos(angle);\n      var sinValue = Math.sin(angle);\n\n      var m = this._transformMatrix;\n      this._transformMatrix = [\n        m[0] * cosValue + m[2] * sinValue,\n        m[1] * cosValue + m[3] * sinValue,\n        m[0] * (-sinValue) + m[2] * cosValue,\n        m[1] * (-sinValue) + m[3] * cosValue,\n        m[4],\n        m[5]\n      ];\n\n      this._originalRotate(angle);\n    };\n  }\n}\n\nvar CachedCanvases = (function CachedCanvasesClosure() {\n  var cache = {};\n  return {\n    getCanvas: function CachedCanvases_getCanvas(id, width, height,\n                                                 trackTransform) {\n      var canvasEntry;\n      if (cache[id] !== undefined) {\n        canvasEntry = cache[id];\n        canvasEntry.canvas.width = width;\n        canvasEntry.canvas.height = height;\n        // reset canvas transform for emulated mozCurrentTransform, if needed\n        canvasEntry.context.setTransform(1, 0, 0, 1, 0, 0);\n      } else {\n        var canvas = createScratchCanvas(width, height);\n        var ctx = canvas.getContext('2d');\n        if (trackTransform) {\n          addContextCurrentTransform(ctx);\n        }\n        cache[id] = canvasEntry = {canvas: canvas, context: ctx};\n      }\n      return canvasEntry;\n    },\n    clear: function () {\n      for (var id in cache) {\n        var canvasEntry = cache[id];\n        // Zeroing the width and height causes Firefox to release graphics\n        // resources immediately, which can greatly reduce memory consumption.\n        canvasEntry.canvas.width = 0;\n        canvasEntry.canvas.height = 0;\n        delete cache[id];\n      }\n    }\n  };\n})();\n\nfunction compileType3Glyph(imgData) {\n  var POINT_TO_PROCESS_LIMIT = 1000;\n\n  var width = imgData.width, height = imgData.height;\n  var i, j, j0, width1 = width + 1;\n  var points = new Uint8Array(width1 * (height + 1));\n  var POINT_TYPES =\n      new Uint8Array([0, 2, 4, 0, 1, 0, 5, 4, 8, 10, 0, 8, 0, 2, 1, 0]);\n\n  // decodes bit-packed mask data\n  var lineSize = (width + 7) & ~7, data0 = imgData.data;\n  var data = new Uint8Array(lineSize * height), pos = 0, ii;\n  for (i = 0, ii = data0.length; i < ii; i++) {\n    var mask = 128, elem = data0[i];\n    while (mask > 0) {\n      data[pos++] = (elem & mask) ? 0 : 255;\n      mask >>= 1;\n    }\n  }\n\n  // finding iteresting points: every point is located between mask pixels,\n  // so there will be points of the (width + 1)x(height + 1) grid. Every point\n  // will have flags assigned based on neighboring mask pixels:\n  //   4 | 8\n  //   --P--\n  //   2 | 1\n  // We are interested only in points with the flags:\n  //   - outside corners: 1, 2, 4, 8;\n  //   - inside corners: 7, 11, 13, 14;\n  //   - and, intersections: 5, 10.\n  var count = 0;\n  pos = 0;\n  if (data[pos] !== 0) {\n    points[0] = 1;\n    ++count;\n  }\n  for (j = 1; j < width; j++) {\n    if (data[pos] !== data[pos + 1]) {\n      points[j] = data[pos] ? 2 : 1;\n      ++count;\n    }\n    pos++;\n  }\n  if (data[pos] !== 0) {\n    points[j] = 2;\n    ++count;\n  }\n  for (i = 1; i < height; i++) {\n    pos = i * lineSize;\n    j0 = i * width1;\n    if (data[pos - lineSize] !== data[pos]) {\n      points[j0] = data[pos] ? 1 : 8;\n      ++count;\n    }\n    // 'sum' is the position of the current pixel configuration in the 'TYPES'\n    // array (in order 8-1-2-4, so we can use '>>2' to shift the column).\n    var sum = (data[pos] ? 4 : 0) + (data[pos - lineSize] ? 8 : 0);\n    for (j = 1; j < width; j++) {\n      sum = (sum >> 2) + (data[pos + 1] ? 4 : 0) +\n            (data[pos - lineSize + 1] ? 8 : 0);\n      if (POINT_TYPES[sum]) {\n        points[j0 + j] = POINT_TYPES[sum];\n        ++count;\n      }\n      pos++;\n    }\n    if (data[pos - lineSize] !== data[pos]) {\n      points[j0 + j] = data[pos] ? 2 : 4;\n      ++count;\n    }\n\n    if (count > POINT_TO_PROCESS_LIMIT) {\n      return null;\n    }\n  }\n\n  pos = lineSize * (height - 1);\n  j0 = i * width1;\n  if (data[pos] !== 0) {\n    points[j0] = 8;\n    ++count;\n  }\n  for (j = 1; j < width; j++) {\n    if (data[pos] !== data[pos + 1]) {\n      points[j0 + j] = data[pos] ? 4 : 8;\n      ++count;\n    }\n    pos++;\n  }\n  if (data[pos] !== 0) {\n    points[j0 + j] = 4;\n    ++count;\n  }\n  if (count > POINT_TO_PROCESS_LIMIT) {\n    return null;\n  }\n\n  // building outlines\n  var steps = new Int32Array([0, width1, -1, 0, -width1, 0, 0, 0, 1]);\n  var outlines = [];\n  for (i = 0; count && i <= height; i++) {\n    var p = i * width1;\n    var end = p + width;\n    while (p < end && !points[p]) {\n      p++;\n    }\n    if (p === end) {\n      continue;\n    }\n    var coords = [p % width1, i];\n\n    var type = points[p], p0 = p, pp;\n    do {\n      var step = steps[type];\n      do {\n        p += step;\n      } while (!points[p]);\n\n      pp = points[p];\n      if (pp !== 5 && pp !== 10) {\n        // set new direction\n        type = pp;\n        // delete mark\n        points[p] = 0;\n      } else { // type is 5 or 10, ie, a crossing\n        // set new direction\n        type = pp & ((0x33 * type) >> 4);\n        // set new type for \"future hit\"\n        points[p] &= (type >> 2 | type << 2);\n      }\n\n      coords.push(p % width1);\n      coords.push((p / width1) | 0);\n      --count;\n    } while (p0 !== p);\n    outlines.push(coords);\n    --i;\n  }\n\n  var drawOutline = function(c) {\n    c.save();\n    // the path shall be painted in [0..1]x[0..1] space\n    c.scale(1 / width, -1 / height);\n    c.translate(0, -height);\n    c.beginPath();\n    for (var i = 0, ii = outlines.length; i < ii; i++) {\n      var o = outlines[i];\n      c.moveTo(o[0], o[1]);\n      for (var j = 2, jj = o.length; j < jj; j += 2) {\n        c.lineTo(o[j], o[j+1]);\n      }\n    }\n    c.fill();\n    c.beginPath();\n    c.restore();\n  };\n\n  return drawOutline;\n}\n\nvar CanvasExtraState = (function CanvasExtraStateClosure() {\n  function CanvasExtraState(old) {\n    // Are soft masks and alpha values shapes or opacities?\n    this.alphaIsShape = false;\n    this.fontSize = 0;\n    this.fontSizeScale = 1;\n    this.textMatrix = IDENTITY_MATRIX;\n    this.textMatrixScale = 1;\n    this.fontMatrix = FONT_IDENTITY_MATRIX;\n    this.leading = 0;\n    // Current point (in user coordinates)\n    this.x = 0;\n    this.y = 0;\n    // Start of text line (in text coordinates)\n    this.lineX = 0;\n    this.lineY = 0;\n    // Character and word spacing\n    this.charSpacing = 0;\n    this.wordSpacing = 0;\n    this.textHScale = 1;\n    this.textRenderingMode = TextRenderingMode.FILL;\n    this.textRise = 0;\n    // Default fore and background colors\n    this.fillColor = '#000000';\n    this.strokeColor = '#000000';\n    this.patternFill = false;\n    // Note: fill alpha applies to all non-stroking operations\n    this.fillAlpha = 1;\n    this.strokeAlpha = 1;\n    this.lineWidth = 1;\n    this.activeSMask = null; // nonclonable field (see the save method below)\n\n    this.old = old;\n  }\n\n  CanvasExtraState.prototype = {\n    clone: function CanvasExtraState_clone() {\n      return Object.create(this);\n    },\n    setCurrentPoint: function CanvasExtraState_setCurrentPoint(x, y) {\n      this.x = x;\n      this.y = y;\n    }\n  };\n  return CanvasExtraState;\n})();\n\nvar CanvasGraphics = (function CanvasGraphicsClosure() {\n  // Defines the time the executeOperatorList is going to be executing\n  // before it stops and shedules a continue of execution.\n  var EXECUTION_TIME = 15;\n  // Defines the number of steps before checking the execution time\n  var EXECUTION_STEPS = 10;\n\n  function CanvasGraphics(canvasCtx, commonObjs, objs, imageLayer) {\n    this.ctx = canvasCtx;\n    this.current = new CanvasExtraState();\n    this.stateStack = [];\n    this.pendingClip = null;\n    this.pendingEOFill = false;\n    this.res = null;\n    this.xobjs = null;\n    this.commonObjs = commonObjs;\n    this.objs = objs;\n    this.imageLayer = imageLayer;\n    this.groupStack = [];\n    this.processingType3 = null;\n    // Patterns are painted relative to the initial page/form transform, see pdf\n    // spec 8.7.2 NOTE 1.\n    this.baseTransform = null;\n    this.baseTransformStack = [];\n    this.groupLevel = 0;\n    this.smaskStack = [];\n    this.smaskCounter = 0;\n    this.tempSMask = null;\n    if (canvasCtx) {\n      // NOTE: if mozCurrentTransform is polyfilled, then the current state of\n      // the transformation must already be set in canvasCtx._transformMatrix.\n      addContextCurrentTransform(canvasCtx);\n    }\n    this.cachedGetSinglePixelWidth = null;\n  }\n\n  function putBinaryImageData(ctx, imgData) {\n    if (typeof ImageData !== 'undefined' && imgData instanceof ImageData) {\n      ctx.putImageData(imgData, 0, 0);\n      return;\n    }\n\n    // Put the image data to the canvas in chunks, rather than putting the\n    // whole image at once.  This saves JS memory, because the ImageData object\n    // is smaller. It also possibly saves C++ memory within the implementation\n    // of putImageData(). (E.g. in Firefox we make two short-lived copies of\n    // the data passed to putImageData()). |n| shouldn't be too small, however,\n    // because too many putImageData() calls will slow things down.\n    //\n    // Note: as written, if the last chunk is partial, the putImageData() call\n    // will (conceptually) put pixels past the bounds of the canvas.  But\n    // that's ok; any such pixels are ignored.\n\n    var height = imgData.height, width = imgData.width;\n    var partialChunkHeight = height % FULL_CHUNK_HEIGHT;\n    var fullChunks = (height - partialChunkHeight) / FULL_CHUNK_HEIGHT;\n    var totalChunks = partialChunkHeight === 0 ? fullChunks : fullChunks + 1;\n\n    var chunkImgData = ctx.createImageData(width, FULL_CHUNK_HEIGHT);\n    var srcPos = 0, destPos;\n    var src = imgData.data;\n    var dest = chunkImgData.data;\n    var i, j, thisChunkHeight, elemsInThisChunk;\n\n    // There are multiple forms in which the pixel data can be passed, and\n    // imgData.kind tells us which one this is.\n    if (imgData.kind === ImageKind.GRAYSCALE_1BPP) {\n      // Grayscale, 1 bit per pixel (i.e. black-and-white).\n      var srcLength = src.byteLength;\n      var dest32 = PDFJS.hasCanvasTypedArrays ? new Uint32Array(dest.buffer) :\n        new Uint32ArrayView(dest);\n      var dest32DataLength = dest32.length;\n      var fullSrcDiff = (width + 7) >> 3;\n      var white = 0xFFFFFFFF;\n      var black = (PDFJS.isLittleEndian || !PDFJS.hasCanvasTypedArrays) ?\n        0xFF000000 : 0x000000FF;\n      for (i = 0; i < totalChunks; i++) {\n        thisChunkHeight =\n          (i < fullChunks) ? FULL_CHUNK_HEIGHT : partialChunkHeight;\n        destPos = 0;\n        for (j = 0; j < thisChunkHeight; j++) {\n          var srcDiff = srcLength - srcPos;\n          var k = 0;\n          var kEnd = (srcDiff > fullSrcDiff) ? width : srcDiff * 8 - 7;\n          var kEndUnrolled = kEnd & ~7;\n          var mask = 0;\n          var srcByte = 0;\n          for (; k < kEndUnrolled; k += 8) {\n            srcByte = src[srcPos++];\n            dest32[destPos++] = (srcByte & 128) ? white : black;\n            dest32[destPos++] = (srcByte & 64) ? white : black;\n            dest32[destPos++] = (srcByte & 32) ? white : black;\n            dest32[destPos++] = (srcByte & 16) ? white : black;\n            dest32[destPos++] = (srcByte & 8) ? white : black;\n            dest32[destPos++] = (srcByte & 4) ? white : black;\n            dest32[destPos++] = (srcByte & 2) ? white : black;\n            dest32[destPos++] = (srcByte & 1) ? white : black;\n          }\n          for (; k < kEnd; k++) {\n             if (mask === 0) {\n               srcByte = src[srcPos++];\n               mask = 128;\n             }\n\n            dest32[destPos++] = (srcByte & mask) ? white : black;\n            mask >>= 1;\n          }\n        }\n        // We ran out of input. Make all remaining pixels transparent.\n        while (destPos < dest32DataLength) {\n          dest32[destPos++] = 0;\n        }\n\n        ctx.putImageData(chunkImgData, 0, i * FULL_CHUNK_HEIGHT);\n      }\n    } else if (imgData.kind === ImageKind.RGBA_32BPP) {\n      // RGBA, 32-bits per pixel.\n\n      j = 0;\n      elemsInThisChunk = width * FULL_CHUNK_HEIGHT * 4;\n      for (i = 0; i < fullChunks; i++) {\n        dest.set(src.subarray(srcPos, srcPos + elemsInThisChunk));\n        srcPos += elemsInThisChunk;\n\n        ctx.putImageData(chunkImgData, 0, j);\n        j += FULL_CHUNK_HEIGHT;\n      }\n      if (i < totalChunks) {\n        elemsInThisChunk = width * partialChunkHeight * 4;\n        dest.set(src.subarray(srcPos, srcPos + elemsInThisChunk));\n        ctx.putImageData(chunkImgData, 0, j);\n      }\n\n    } else if (imgData.kind === ImageKind.RGB_24BPP) {\n      // RGB, 24-bits per pixel.\n      thisChunkHeight = FULL_CHUNK_HEIGHT;\n      elemsInThisChunk = width * thisChunkHeight;\n      for (i = 0; i < totalChunks; i++) {\n        if (i >= fullChunks) {\n          thisChunkHeight = partialChunkHeight;\n          elemsInThisChunk = width * thisChunkHeight;\n        }\n\n        destPos = 0;\n        for (j = elemsInThisChunk; j--;) {\n          dest[destPos++] = src[srcPos++];\n          dest[destPos++] = src[srcPos++];\n          dest[destPos++] = src[srcPos++];\n          dest[destPos++] = 255;\n        }\n        ctx.putImageData(chunkImgData, 0, i * FULL_CHUNK_HEIGHT);\n      }\n    } else {\n      error('bad image kind: ' + imgData.kind);\n    }\n  }\n\n  function putBinaryImageMask(ctx, imgData) {\n    var height = imgData.height, width = imgData.width;\n    var partialChunkHeight = height % FULL_CHUNK_HEIGHT;\n    var fullChunks = (height - partialChunkHeight) / FULL_CHUNK_HEIGHT;\n    var totalChunks = partialChunkHeight === 0 ? fullChunks : fullChunks + 1;\n\n    var chunkImgData = ctx.createImageData(width, FULL_CHUNK_HEIGHT);\n    var srcPos = 0;\n    var src = imgData.data;\n    var dest = chunkImgData.data;\n\n    for (var i = 0; i < totalChunks; i++) {\n      var thisChunkHeight =\n        (i < fullChunks) ? FULL_CHUNK_HEIGHT : partialChunkHeight;\n\n      // Expand the mask so it can be used by the canvas.  Any required\n      // inversion has already been handled.\n      var destPos = 3; // alpha component offset\n      for (var j = 0; j < thisChunkHeight; j++) {\n        var mask = 0;\n        for (var k = 0; k < width; k++) {\n          if (!mask) {\n            var elem = src[srcPos++];\n            mask = 128;\n          }\n          dest[destPos] = (elem & mask) ? 0 : 255;\n          destPos += 4;\n          mask >>= 1;\n        }\n      }\n      ctx.putImageData(chunkImgData, 0, i * FULL_CHUNK_HEIGHT);\n    }\n  }\n\n  function copyCtxState(sourceCtx, destCtx) {\n    var properties = ['strokeStyle', 'fillStyle', 'fillRule', 'globalAlpha',\n                      'lineWidth', 'lineCap', 'lineJoin', 'miterLimit',\n                      'globalCompositeOperation', 'font'];\n    for (var i = 0, ii = properties.length; i < ii; i++) {\n      var property = properties[i];\n      if (sourceCtx[property] !== undefined) {\n        destCtx[property] = sourceCtx[property];\n      }\n    }\n    if (sourceCtx.setLineDash !== undefined) {\n      destCtx.setLineDash(sourceCtx.getLineDash());\n      destCtx.lineDashOffset =  sourceCtx.lineDashOffset;\n    } else if (sourceCtx.mozDashOffset !== undefined) {\n      destCtx.mozDash = sourceCtx.mozDash;\n      destCtx.mozDashOffset = sourceCtx.mozDashOffset;\n    }\n  }\n\n  function composeSMaskBackdrop(bytes, r0, g0, b0) {\n    var length = bytes.length;\n    for (var i = 3; i < length; i += 4) {\n      var alpha = bytes[i];\n      if (alpha === 0) {\n        bytes[i - 3] = r0;\n        bytes[i - 2] = g0;\n        bytes[i - 1] = b0;\n      } else if (alpha < 255) {\n        var alpha_ = 255 - alpha;\n        bytes[i - 3] = (bytes[i - 3] * alpha + r0 * alpha_) >> 8;\n        bytes[i - 2] = (bytes[i - 2] * alpha + g0 * alpha_) >> 8;\n        bytes[i - 1] = (bytes[i - 1] * alpha + b0 * alpha_) >> 8;\n      }\n    }\n  }\n\n  function composeSMaskAlpha(maskData, layerData) {\n    var length = maskData.length;\n    var scale = 1 / 255;\n    for (var i = 3; i < length; i += 4) {\n      var alpha = maskData[i];\n      layerData[i] = (layerData[i] * alpha * scale) | 0;\n    }\n  }\n\n  function composeSMaskLuminosity(maskData, layerData) {\n    var length = maskData.length;\n    for (var i = 3; i < length; i += 4) {\n      var y = (maskData[i - 3] * 77) +  // * 0.3 / 255 * 0x10000\n              (maskData[i - 2] * 152) + // * 0.59 ....\n              (maskData[i - 1] * 28);   // * 0.11 ....\n      layerData[i] = (layerData[i] * y) >> 16;\n    }\n  }\n\n  function genericComposeSMask(maskCtx, layerCtx, width, height,\n                               subtype, backdrop) {\n    var hasBackdrop = !!backdrop;\n    var r0 = hasBackdrop ? backdrop[0] : 0;\n    var g0 = hasBackdrop ? backdrop[1] : 0;\n    var b0 = hasBackdrop ? backdrop[2] : 0;\n\n    var composeFn;\n    if (subtype === 'Luminosity') {\n      composeFn = composeSMaskLuminosity;\n    } else {\n      composeFn = composeSMaskAlpha;\n    }\n\n    // processing image in chunks to save memory\n    var PIXELS_TO_PROCESS = 1048576;\n    var chunkSize = Math.min(height, Math.ceil(PIXELS_TO_PROCESS / width));\n    for (var row = 0; row < height; row += chunkSize) {\n      var chunkHeight = Math.min(chunkSize, height - row);\n      var maskData = maskCtx.getImageData(0, row, width, chunkHeight);\n      var layerData = layerCtx.getImageData(0, row, width, chunkHeight);\n\n      if (hasBackdrop) {\n        composeSMaskBackdrop(maskData.data, r0, g0, b0);\n      }\n      composeFn(maskData.data, layerData.data);\n\n      maskCtx.putImageData(layerData, 0, row);\n    }\n  }\n\n  function composeSMask(ctx, smask, layerCtx) {\n    var mask = smask.canvas;\n    var maskCtx = smask.context;\n\n    ctx.setTransform(smask.scaleX, 0, 0, smask.scaleY,\n                     smask.offsetX, smask.offsetY);\n\n    var backdrop = smask.backdrop || null;\n    if (WebGLUtils.isEnabled) {\n      var composed = WebGLUtils.composeSMask(layerCtx.canvas, mask,\n        {subtype: smask.subtype, backdrop: backdrop});\n      ctx.setTransform(1, 0, 0, 1, 0, 0);\n      ctx.drawImage(composed, smask.offsetX, smask.offsetY);\n      return;\n    }\n    genericComposeSMask(maskCtx, layerCtx, mask.width, mask.height,\n                        smask.subtype, backdrop);\n    ctx.drawImage(mask, 0, 0);\n  }\n\n  var LINE_CAP_STYLES = ['butt', 'round', 'square'];\n  var LINE_JOIN_STYLES = ['miter', 'round', 'bevel'];\n  var NORMAL_CLIP = {};\n  var EO_CLIP = {};\n\n  CanvasGraphics.prototype = {\n\n    beginDrawing: function CanvasGraphics_beginDrawing(viewport, transparency) {\n      // For pdfs that use blend modes we have to clear the canvas else certain\n      // blend modes can look wrong since we'd be blending with a white\n      // backdrop. The problem with a transparent backdrop though is we then\n      // don't get sub pixel anti aliasing on text, so we fill with white if\n      // we can.\n      var width = this.ctx.canvas.width;\n      var height = this.ctx.canvas.height;\n      if (transparency) {\n        this.ctx.clearRect(0, 0, width, height);\n      } else {\n        this.ctx.mozOpaque = true;\n        this.ctx.save();\n        this.ctx.fillStyle = 'rgb(255, 255, 255)';\n        this.ctx.fillRect(0, 0, width, height);\n        this.ctx.restore();\n      }\n\n      var transform = viewport.transform;\n\n      this.ctx.save();\n      this.ctx.transform.apply(this.ctx, transform);\n\n      this.baseTransform = this.ctx.mozCurrentTransform.slice();\n\n      if (this.imageLayer) {\n        this.imageLayer.beginLayout();\n      }\n    },\n\n    executeOperatorList: function CanvasGraphics_executeOperatorList(\n                                    operatorList,\n                                    executionStartIdx, continueCallback,\n                                    stepper) {\n      var argsArray = operatorList.argsArray;\n      var fnArray = operatorList.fnArray;\n      var i = executionStartIdx || 0;\n      var argsArrayLen = argsArray.length;\n\n      // Sometimes the OperatorList to execute is empty.\n      if (argsArrayLen === i) {\n        return i;\n      }\n\n      var chunkOperations = (argsArrayLen - i > EXECUTION_STEPS &&\n                             typeof continueCallback === 'function');\n      var endTime = chunkOperations ? Date.now() + EXECUTION_TIME : 0;\n      var steps = 0;\n\n      var commonObjs = this.commonObjs;\n      var objs = this.objs;\n      var fnId;\n\n      while (true) {\n        if (stepper !== undefined && i === stepper.nextBreakPoint) {\n          stepper.breakIt(i, continueCallback);\n          return i;\n        }\n\n        fnId = fnArray[i];\n\n        if (fnId !== OPS.dependency) {\n          this[fnId].apply(this, argsArray[i]);\n        } else {\n          var deps = argsArray[i];\n          for (var n = 0, nn = deps.length; n < nn; n++) {\n            var depObjId = deps[n];\n            var common = depObjId[0] === 'g' && depObjId[1] === '_';\n            var objsPool = common ? commonObjs : objs;\n\n            // If the promise isn't resolved yet, add the continueCallback\n            // to the promise and bail out.\n            if (!objsPool.isResolved(depObjId)) {\n              objsPool.get(depObjId, continueCallback);\n              return i;\n            }\n          }\n        }\n\n        i++;\n\n        // If the entire operatorList was executed, stop as were done.\n        if (i === argsArrayLen) {\n          return i;\n        }\n\n        // If the execution took longer then a certain amount of time and\n        // `continueCallback` is specified, interrupt the execution.\n        if (chunkOperations && ++steps > EXECUTION_STEPS) {\n          if (Date.now() > endTime) {\n            continueCallback();\n            return i;\n          }\n          steps = 0;\n        }\n\n        // If the operatorList isn't executed completely yet OR the execution\n        // time was short enough, do another execution round.\n      }\n    },\n\n    endDrawing: function CanvasGraphics_endDrawing() {\n      this.ctx.restore();\n      CachedCanvases.clear();\n      WebGLUtils.clear();\n\n      if (this.imageLayer) {\n        this.imageLayer.endLayout();\n      }\n    },\n\n    // Graphics state\n    setLineWidth: function CanvasGraphics_setLineWidth(width) {\n      this.current.lineWidth = width;\n      this.ctx.lineWidth = width;\n    },\n    setLineCap: function CanvasGraphics_setLineCap(style) {\n      this.ctx.lineCap = LINE_CAP_STYLES[style];\n    },\n    setLineJoin: function CanvasGraphics_setLineJoin(style) {\n      this.ctx.lineJoin = LINE_JOIN_STYLES[style];\n    },\n    setMiterLimit: function CanvasGraphics_setMiterLimit(limit) {\n      this.ctx.miterLimit = limit;\n    },\n    setDash: function CanvasGraphics_setDash(dashArray, dashPhase) {\n      var ctx = this.ctx;\n      if (ctx.setLineDash !== undefined) {\n        ctx.setLineDash(dashArray);\n        ctx.lineDashOffset = dashPhase;\n      } else {\n        ctx.mozDash = dashArray;\n        ctx.mozDashOffset = dashPhase;\n      }\n    },\n    setRenderingIntent: function CanvasGraphics_setRenderingIntent(intent) {\n      // Maybe if we one day fully support color spaces this will be important\n      // for now we can ignore.\n      // TODO set rendering intent?\n    },\n    setFlatness: function CanvasGraphics_setFlatness(flatness) {\n      // There's no way to control this with canvas, but we can safely ignore.\n      // TODO set flatness?\n    },\n    setGState: function CanvasGraphics_setGState(states) {\n      for (var i = 0, ii = states.length; i < ii; i++) {\n        var state = states[i];\n        var key = state[0];\n        var value = state[1];\n\n        switch (key) {\n          case 'LW':\n            this.setLineWidth(value);\n            break;\n          case 'LC':\n            this.setLineCap(value);\n            break;\n          case 'LJ':\n            this.setLineJoin(value);\n            break;\n          case 'ML':\n            this.setMiterLimit(value);\n            break;\n          case 'D':\n            this.setDash(value[0], value[1]);\n            break;\n          case 'RI':\n            this.setRenderingIntent(value);\n            break;\n          case 'FL':\n            this.setFlatness(value);\n            break;\n          case 'Font':\n            this.setFont(value[0], value[1]);\n            break;\n          case 'CA':\n            this.current.strokeAlpha = state[1];\n            break;\n          case 'ca':\n            this.current.fillAlpha = state[1];\n            this.ctx.globalAlpha = state[1];\n            break;\n          case 'BM':\n            if (value && value.name && (value.name !== 'Normal')) {\n              var mode = value.name.replace(/([A-Z])/g,\n                function(c) {\n                  return '-' + c.toLowerCase();\n                }\n              ).substring(1);\n              this.ctx.globalCompositeOperation = mode;\n              if (this.ctx.globalCompositeOperation !== mode) {\n                warn('globalCompositeOperation \"' + mode +\n                     '\" is not supported');\n              }\n            } else {\n              this.ctx.globalCompositeOperation = 'source-over';\n            }\n            break;\n          case 'SMask':\n            if (this.current.activeSMask) {\n              this.endSMaskGroup();\n            }\n            this.current.activeSMask = value ? this.tempSMask : null;\n            if (this.current.activeSMask) {\n              this.beginSMaskGroup();\n            }\n            this.tempSMask = null;\n            break;\n        }\n      }\n    },\n    beginSMaskGroup: function CanvasGraphics_beginSMaskGroup() {\n\n      var activeSMask = this.current.activeSMask;\n      var drawnWidth = activeSMask.canvas.width;\n      var drawnHeight = activeSMask.canvas.height;\n      var cacheId = 'smaskGroupAt' + this.groupLevel;\n      var scratchCanvas = CachedCanvases.getCanvas(\n        cacheId, drawnWidth, drawnHeight, true);\n\n      var currentCtx = this.ctx;\n      var currentTransform = currentCtx.mozCurrentTransform;\n      this.ctx.save();\n\n      var groupCtx = scratchCanvas.context;\n      groupCtx.scale(1 / activeSMask.scaleX, 1 / activeSMask.scaleY);\n      groupCtx.translate(-activeSMask.offsetX, -activeSMask.offsetY);\n      groupCtx.transform.apply(groupCtx, currentTransform);\n\n      copyCtxState(currentCtx, groupCtx);\n      this.ctx = groupCtx;\n      this.setGState([\n        ['BM', 'Normal'],\n        ['ca', 1],\n        ['CA', 1]\n      ]);\n      this.groupStack.push(currentCtx);\n      this.groupLevel++;\n    },\n    endSMaskGroup: function CanvasGraphics_endSMaskGroup() {\n      var groupCtx = this.ctx;\n      this.groupLevel--;\n      this.ctx = this.groupStack.pop();\n\n      composeSMask(this.ctx, this.current.activeSMask, groupCtx);\n      this.ctx.restore();\n    },\n    save: function CanvasGraphics_save() {\n      this.ctx.save();\n      var old = this.current;\n      this.stateStack.push(old);\n      this.current = old.clone();\n      this.current.activeSMask = null;\n    },\n    restore: function CanvasGraphics_restore() {\n      if (this.stateStack.length !== 0) {\n        if (this.current.activeSMask !== null) {\n          this.endSMaskGroup();\n        }\n\n        this.current = this.stateStack.pop();\n        this.ctx.restore();\n\n        this.cachedGetSinglePixelWidth = null;\n      }\n    },\n    transform: function CanvasGraphics_transform(a, b, c, d, e, f) {\n      this.ctx.transform(a, b, c, d, e, f);\n\n      this.cachedGetSinglePixelWidth = null;\n    },\n\n    // Path\n    constructPath: function CanvasGraphics_constructPath(ops, args) {\n      var ctx = this.ctx;\n      var current = this.current;\n      var x = current.x, y = current.y;\n      for (var i = 0, j = 0, ii = ops.length; i < ii; i++) {\n        switch (ops[i] | 0) {\n          case OPS.rectangle:\n            x = args[j++];\n            y = args[j++];\n            var width = args[j++];\n            var height = args[j++];\n            if (width === 0) {\n              width = this.getSinglePixelWidth();\n            }\n            if (height === 0) {\n              height = this.getSinglePixelWidth();\n            }\n            var xw = x + width;\n            var yh = y + height;\n            this.ctx.moveTo(x, y);\n            this.ctx.lineTo(xw, y);\n            this.ctx.lineTo(xw, yh);\n            this.ctx.lineTo(x, yh);\n            this.ctx.lineTo(x, y);\n            this.ctx.closePath();\n            break;\n          case OPS.moveTo:\n            x = args[j++];\n            y = args[j++];\n            ctx.moveTo(x, y);\n            break;\n          case OPS.lineTo:\n            x = args[j++];\n            y = args[j++];\n            ctx.lineTo(x, y);\n            break;\n          case OPS.curveTo:\n            x = args[j + 4];\n            y = args[j + 5];\n            ctx.bezierCurveTo(args[j], args[j + 1], args[j + 2], args[j + 3],\n                              x, y);\n            j += 6;\n            break;\n          case OPS.curveTo2:\n            ctx.bezierCurveTo(x, y, args[j], args[j + 1],\n                              args[j + 2], args[j + 3]);\n            x = args[j + 2];\n            y = args[j + 3];\n            j += 4;\n            break;\n          case OPS.curveTo3:\n            x = args[j + 2];\n            y = args[j + 3];\n            ctx.bezierCurveTo(args[j], args[j + 1], x, y, x, y);\n            j += 4;\n            break;\n          case OPS.closePath:\n            ctx.closePath();\n            break;\n        }\n      }\n      current.setCurrentPoint(x, y);\n    },\n    closePath: function CanvasGraphics_closePath() {\n      this.ctx.closePath();\n    },\n    stroke: function CanvasGraphics_stroke(consumePath) {\n      consumePath = typeof consumePath !== 'undefined' ? consumePath : true;\n      var ctx = this.ctx;\n      var strokeColor = this.current.strokeColor;\n      // Prevent drawing too thin lines by enforcing a minimum line width.\n      ctx.lineWidth = Math.max(this.getSinglePixelWidth() * MIN_WIDTH_FACTOR,\n                               this.current.lineWidth);\n      // For stroke we want to temporarily change the global alpha to the\n      // stroking alpha.\n      ctx.globalAlpha = this.current.strokeAlpha;\n      if (strokeColor && strokeColor.hasOwnProperty('type') &&\n          strokeColor.type === 'Pattern') {\n        // for patterns, we transform to pattern space, calculate\n        // the pattern, call stroke, and restore to user space\n        ctx.save();\n        ctx.strokeStyle = strokeColor.getPattern(ctx, this);\n        ctx.stroke();\n        ctx.restore();\n      } else {\n        ctx.stroke();\n      }\n      if (consumePath) {\n        this.consumePath();\n      }\n      // Restore the global alpha to the fill alpha\n      ctx.globalAlpha = this.current.fillAlpha;\n    },\n    closeStroke: function CanvasGraphics_closeStroke() {\n      this.closePath();\n      this.stroke();\n    },\n    fill: function CanvasGraphics_fill(consumePath) {\n      consumePath = typeof consumePath !== 'undefined' ? consumePath : true;\n      var ctx = this.ctx;\n      var fillColor = this.current.fillColor;\n      var isPatternFill = this.current.patternFill;\n      var needRestore = false;\n\n      if (isPatternFill) {\n        ctx.save();\n        ctx.fillStyle = fillColor.getPattern(ctx, this);\n        needRestore = true;\n      }\n\n      if (this.pendingEOFill) {\n        if (ctx.mozFillRule !== undefined) {\n          ctx.mozFillRule = 'evenodd';\n          ctx.fill();\n          ctx.mozFillRule = 'nonzero';\n        } else {\n          try {\n            ctx.fill('evenodd');\n          } catch (ex) {\n            // shouldn't really happen, but browsers might think differently\n            ctx.fill();\n          }\n        }\n        this.pendingEOFill = false;\n      } else {\n        ctx.fill();\n      }\n\n      if (needRestore) {\n        ctx.restore();\n      }\n      if (consumePath) {\n        this.consumePath();\n      }\n    },\n    eoFill: function CanvasGraphics_eoFill() {\n      this.pendingEOFill = true;\n      this.fill();\n    },\n    fillStroke: function CanvasGraphics_fillStroke() {\n      this.fill(false);\n      this.stroke(false);\n\n      this.consumePath();\n    },\n    eoFillStroke: function CanvasGraphics_eoFillStroke() {\n      this.pendingEOFill = true;\n      this.fillStroke();\n    },\n    closeFillStroke: function CanvasGraphics_closeFillStroke() {\n      this.closePath();\n      this.fillStroke();\n    },\n    closeEOFillStroke: function CanvasGraphics_closeEOFillStroke() {\n      this.pendingEOFill = true;\n      this.closePath();\n      this.fillStroke();\n    },\n    endPath: function CanvasGraphics_endPath() {\n      this.consumePath();\n    },\n\n    // Clipping\n    clip: function CanvasGraphics_clip() {\n      this.pendingClip = NORMAL_CLIP;\n    },\n    eoClip: function CanvasGraphics_eoClip() {\n      this.pendingClip = EO_CLIP;\n    },\n\n    // Text\n    beginText: function CanvasGraphics_beginText() {\n      this.current.textMatrix = IDENTITY_MATRIX;\n      this.current.textMatrixScale = 1;\n      this.current.x = this.current.lineX = 0;\n      this.current.y = this.current.lineY = 0;\n    },\n    endText: function CanvasGraphics_endText() {\n      var paths = this.pendingTextPaths;\n      var ctx = this.ctx;\n      if (paths === undefined) {\n        ctx.beginPath();\n        return;\n      }\n\n      ctx.save();\n      ctx.beginPath();\n      for (var i = 0; i < paths.length; i++) {\n        var path = paths[i];\n        ctx.setTransform.apply(ctx, path.transform);\n        ctx.translate(path.x, path.y);\n        path.addToPath(ctx, path.fontSize);\n      }\n      ctx.restore();\n      ctx.clip();\n      ctx.beginPath();\n      delete this.pendingTextPaths;\n    },\n    setCharSpacing: function CanvasGraphics_setCharSpacing(spacing) {\n      this.current.charSpacing = spacing;\n    },\n    setWordSpacing: function CanvasGraphics_setWordSpacing(spacing) {\n      this.current.wordSpacing = spacing;\n    },\n    setHScale: function CanvasGraphics_setHScale(scale) {\n      this.current.textHScale = scale / 100;\n    },\n    setLeading: function CanvasGraphics_setLeading(leading) {\n      this.current.leading = -leading;\n    },\n    setFont: function CanvasGraphics_setFont(fontRefName, size) {\n      var fontObj = this.commonObjs.get(fontRefName);\n      var current = this.current;\n\n      if (!fontObj) {\n        error('Can\\'t find font for ' + fontRefName);\n      }\n\n      current.fontMatrix = (fontObj.fontMatrix ?\n                            fontObj.fontMatrix : FONT_IDENTITY_MATRIX);\n\n      // A valid matrix needs all main diagonal elements to be non-zero\n      // This also ensures we bypass FF bugzilla bug #719844.\n      if (current.fontMatrix[0] === 0 ||\n          current.fontMatrix[3] === 0) {\n        warn('Invalid font matrix for font ' + fontRefName);\n      }\n\n      // The spec for Tf (setFont) says that 'size' specifies the font 'scale',\n      // and in some docs this can be negative (inverted x-y axes).\n      if (size < 0) {\n        size = -size;\n        current.fontDirection = -1;\n      } else {\n        current.fontDirection = 1;\n      }\n\n      this.current.font = fontObj;\n      this.current.fontSize = size;\n\n      if (fontObj.isType3Font) {\n        return; // we don't need ctx.font for Type3 fonts\n      }\n\n      var name = fontObj.loadedName || 'sans-serif';\n      var bold = fontObj.black ? (fontObj.bold ? 'bolder' : 'bold') :\n                                 (fontObj.bold ? 'bold' : 'normal');\n\n      var italic = fontObj.italic ? 'italic' : 'normal';\n      var typeface = '\"' + name + '\", ' + fontObj.fallbackName;\n\n      // Some font backends cannot handle fonts below certain size.\n      // Keeping the font at minimal size and using the fontSizeScale to change\n      // the current transformation matrix before the fillText/strokeText.\n      // See https://bugzilla.mozilla.org/show_bug.cgi?id=726227\n      var browserFontSize = size < MIN_FONT_SIZE ? MIN_FONT_SIZE :\n                            size > MAX_FONT_SIZE ? MAX_FONT_SIZE : size;\n      this.current.fontSizeScale = size / browserFontSize;\n\n      var rule = italic + ' ' + bold + ' ' + browserFontSize + 'px ' + typeface;\n      this.ctx.font = rule;\n    },\n    setTextRenderingMode: function CanvasGraphics_setTextRenderingMode(mode) {\n      this.current.textRenderingMode = mode;\n    },\n    setTextRise: function CanvasGraphics_setTextRise(rise) {\n      this.current.textRise = rise;\n    },\n    moveText: function CanvasGraphics_moveText(x, y) {\n      this.current.x = this.current.lineX += x;\n      this.current.y = this.current.lineY += y;\n    },\n    setLeadingMoveText: function CanvasGraphics_setLeadingMoveText(x, y) {\n      this.setLeading(-y);\n      this.moveText(x, y);\n    },\n    setTextMatrix: function CanvasGraphics_setTextMatrix(a, b, c, d, e, f) {\n      this.current.textMatrix = [a, b, c, d, e, f];\n      this.current.textMatrixScale = Math.sqrt(a * a + b * b);\n\n      this.current.x = this.current.lineX = 0;\n      this.current.y = this.current.lineY = 0;\n    },\n    nextLine: function CanvasGraphics_nextLine() {\n      this.moveText(0, this.current.leading);\n    },\n\n    paintChar: function CanvasGraphics_paintChar(character, x, y) {\n      var ctx = this.ctx;\n      var current = this.current;\n      var font = current.font;\n      var textRenderingMode = current.textRenderingMode;\n      var fontSize = current.fontSize / current.fontSizeScale;\n      var fillStrokeMode = textRenderingMode &\n        TextRenderingMode.FILL_STROKE_MASK;\n      var isAddToPathSet = !!(textRenderingMode &\n        TextRenderingMode.ADD_TO_PATH_FLAG);\n\n      var addToPath;\n      if (font.disableFontFace || isAddToPathSet) {\n        addToPath = font.getPathGenerator(this.commonObjs, character);\n      }\n\n      if (font.disableFontFace) {\n        ctx.save();\n        ctx.translate(x, y);\n        ctx.beginPath();\n        addToPath(ctx, fontSize);\n        if (fillStrokeMode === TextRenderingMode.FILL ||\n            fillStrokeMode === TextRenderingMode.FILL_STROKE) {\n          ctx.fill();\n        }\n        if (fillStrokeMode === TextRenderingMode.STROKE ||\n            fillStrokeMode === TextRenderingMode.FILL_STROKE) {\n          ctx.stroke();\n        }\n        ctx.restore();\n      } else {\n        if (fillStrokeMode === TextRenderingMode.FILL ||\n            fillStrokeMode === TextRenderingMode.FILL_STROKE) {\n          ctx.fillText(character, x, y);\n        }\n        if (fillStrokeMode === TextRenderingMode.STROKE ||\n            fillStrokeMode === TextRenderingMode.FILL_STROKE) {\n          ctx.strokeText(character, x, y);\n        }\n      }\n\n      if (isAddToPathSet) {\n        var paths = this.pendingTextPaths || (this.pendingTextPaths = []);\n        paths.push({\n          transform: ctx.mozCurrentTransform,\n          x: x,\n          y: y,\n          fontSize: fontSize,\n          addToPath: addToPath\n        });\n      }\n    },\n\n    get isFontSubpixelAAEnabled() {\n      // Checks if anti-aliasing is enabled when scaled text is painted.\n      // On Windows GDI scaled fonts looks bad.\n      var ctx = document.createElement('canvas').getContext('2d');\n      ctx.scale(1.5, 1);\n      ctx.fillText('I', 0, 10);\n      var data = ctx.getImageData(0, 0, 10, 10).data;\n      var enabled = false;\n      for (var i = 3; i < data.length; i += 4) {\n        if (data[i] > 0 && data[i] < 255) {\n          enabled = true;\n          break;\n        }\n      }\n      return shadow(this, 'isFontSubpixelAAEnabled', enabled);\n    },\n\n    showText: function CanvasGraphics_showText(glyphs) {\n      var current = this.current;\n      var font = current.font;\n      if (font.isType3Font) {\n        return this.showType3Text(glyphs);\n      }\n\n      var fontSize = current.fontSize;\n      if (fontSize === 0) {\n        return;\n      }\n\n      var ctx = this.ctx;\n      var fontSizeScale = current.fontSizeScale;\n      var charSpacing = current.charSpacing;\n      var wordSpacing = current.wordSpacing;\n      var fontDirection = current.fontDirection;\n      var textHScale = current.textHScale * fontDirection;\n      var glyphsLength = glyphs.length;\n      var vertical = font.vertical;\n      var defaultVMetrics = font.defaultVMetrics;\n      var widthAdvanceScale = fontSize * current.fontMatrix[0];\n\n      var simpleFillText =\n        current.textRenderingMode === TextRenderingMode.FILL &&\n        !font.disableFontFace;\n\n      ctx.save();\n      ctx.transform.apply(ctx, current.textMatrix);\n      ctx.translate(current.x, current.y + current.textRise);\n\n      if (fontDirection > 0) {\n        ctx.scale(textHScale, -1);\n      } else {\n        ctx.scale(textHScale, 1);\n      }\n\n      var lineWidth = current.lineWidth;\n      var scale = current.textMatrixScale;\n      if (scale === 0 || lineWidth === 0) {\n        var fillStrokeMode = current.textRenderingMode &\n          TextRenderingMode.FILL_STROKE_MASK;\n        if (fillStrokeMode === TextRenderingMode.STROKE ||\n            fillStrokeMode === TextRenderingMode.FILL_STROKE) {\n          this.cachedGetSinglePixelWidth = null;\n          lineWidth = this.getSinglePixelWidth() * MIN_WIDTH_FACTOR;\n        }\n      } else {\n        lineWidth /= scale;\n      }\n\n      if (fontSizeScale !== 1.0) {\n        ctx.scale(fontSizeScale, fontSizeScale);\n        lineWidth /= fontSizeScale;\n      }\n\n      ctx.lineWidth = lineWidth;\n\n      var x = 0, i;\n      for (i = 0; i < glyphsLength; ++i) {\n        var glyph = glyphs[i];\n        if (glyph === null) {\n          // word break\n          x += fontDirection * wordSpacing;\n          continue;\n        } else if (isNum(glyph)) {\n          x += -glyph * fontSize * 0.001;\n          continue;\n        }\n\n        var restoreNeeded = false;\n        var character = glyph.fontChar;\n        var accent = glyph.accent;\n        var scaledX, scaledY, scaledAccentX, scaledAccentY;\n        var width = glyph.width;\n        if (vertical) {\n          var vmetric, vx, vy;\n          vmetric = glyph.vmetric || defaultVMetrics;\n          vx = glyph.vmetric ? vmetric[1] : width * 0.5;\n          vx = -vx * widthAdvanceScale;\n          vy = vmetric[2] * widthAdvanceScale;\n\n          width = vmetric ? -vmetric[0] : width;\n          scaledX = vx / fontSizeScale;\n          scaledY = (x + vy) / fontSizeScale;\n        } else {\n          scaledX = x / fontSizeScale;\n          scaledY = 0;\n        }\n\n        if (font.remeasure && width > 0 && this.isFontSubpixelAAEnabled) {\n          // some standard fonts may not have the exact width, trying to\n          // rescale per character\n          var measuredWidth = ctx.measureText(character).width * 1000 /\n            fontSize * fontSizeScale;\n          var characterScaleX = width / measuredWidth;\n          restoreNeeded = true;\n          ctx.save();\n          ctx.scale(characterScaleX, 1);\n          scaledX /= characterScaleX;\n        }\n\n        if (simpleFillText && !accent) {\n          // common case\n          ctx.fillText(character, scaledX, scaledY);\n        } else {\n          this.paintChar(character, scaledX, scaledY);\n          if (accent) {\n            scaledAccentX = scaledX + accent.offset.x / fontSizeScale;\n            scaledAccentY = scaledY - accent.offset.y / fontSizeScale;\n            this.paintChar(accent.fontChar, scaledAccentX, scaledAccentY);\n          }\n        }\n\n        var charWidth = width * widthAdvanceScale + charSpacing * fontDirection;\n        x += charWidth;\n\n        if (restoreNeeded) {\n          ctx.restore();\n        }\n      }\n      if (vertical) {\n        current.y -= x * textHScale;\n      } else {\n        current.x += x * textHScale;\n      }\n      ctx.restore();\n    },\n\n    showType3Text: function CanvasGraphics_showType3Text(glyphs) {\n      // Type3 fonts - each glyph is a \"mini-PDF\"\n      var ctx = this.ctx;\n      var current = this.current;\n      var font = current.font;\n      var fontSize = current.fontSize;\n      var fontDirection = current.fontDirection;\n      var charSpacing = current.charSpacing;\n      var wordSpacing = current.wordSpacing;\n      var textHScale = current.textHScale * fontDirection;\n      var fontMatrix = current.fontMatrix || FONT_IDENTITY_MATRIX;\n      var glyphsLength = glyphs.length;\n      var isTextInvisible =\n        current.textRenderingMode === TextRenderingMode.INVISIBLE;\n      var i, glyph, width;\n\n      if (isTextInvisible || fontSize === 0) {\n        return;\n      }\n\n      ctx.save();\n      ctx.transform.apply(ctx, current.textMatrix);\n      ctx.translate(current.x, current.y);\n\n      ctx.scale(textHScale, fontDirection);\n\n      for (i = 0; i < glyphsLength; ++i) {\n        glyph = glyphs[i];\n        if (glyph === null) {\n          // word break\n          this.ctx.translate(wordSpacing, 0);\n          current.x += wordSpacing * textHScale;\n          continue;\n        } else if (isNum(glyph)) {\n          var spacingLength = -glyph * 0.001 * fontSize;\n          this.ctx.translate(spacingLength, 0);\n          current.x += spacingLength * textHScale;\n          continue;\n        }\n\n        var operatorList = font.charProcOperatorList[glyph.operatorListId];\n        if (!operatorList) {\n          warn('Type3 character \\\"' + glyph.operatorListId +\n               '\\\" is not available');\n          continue;\n        }\n        this.processingType3 = glyph;\n        this.save();\n        ctx.scale(fontSize, fontSize);\n        ctx.transform.apply(ctx, fontMatrix);\n        this.executeOperatorList(operatorList);\n        this.restore();\n\n        var transformed = Util.applyTransform([glyph.width, 0], fontMatrix);\n        width = transformed[0] * fontSize + charSpacing;\n\n        ctx.translate(width, 0);\n        current.x += width * textHScale;\n      }\n      ctx.restore();\n      this.processingType3 = null;\n    },\n\n    // Type3 fonts\n    setCharWidth: function CanvasGraphics_setCharWidth(xWidth, yWidth) {\n      // We can safely ignore this since the width should be the same\n      // as the width in the Widths array.\n    },\n    setCharWidthAndBounds: function CanvasGraphics_setCharWidthAndBounds(xWidth,\n                                                                        yWidth,\n                                                                        llx,\n                                                                        lly,\n                                                                        urx,\n                                                                        ury) {\n      // TODO According to the spec we're also suppose to ignore any operators\n      // that set color or include images while processing this type3 font.\n      this.ctx.rect(llx, lly, urx - llx, ury - lly);\n      this.clip();\n      this.endPath();\n    },\n\n    // Color\n    getColorN_Pattern: function CanvasGraphics_getColorN_Pattern(IR) {\n      var pattern;\n      if (IR[0] === 'TilingPattern') {\n        var color = IR[1];\n        pattern = new TilingPattern(IR, color, this.ctx, this.objs,\n                                    this.commonObjs, this.baseTransform);\n      } else {\n        pattern = getShadingPatternFromIR(IR);\n      }\n      return pattern;\n    },\n    setStrokeColorN: function CanvasGraphics_setStrokeColorN(/*...*/) {\n      this.current.strokeColor = this.getColorN_Pattern(arguments);\n    },\n    setFillColorN: function CanvasGraphics_setFillColorN(/*...*/) {\n      this.current.fillColor = this.getColorN_Pattern(arguments);\n      this.current.patternFill = true;\n    },\n    setStrokeRGBColor: function CanvasGraphics_setStrokeRGBColor(r, g, b) {\n      var color = Util.makeCssRgb(r, g, b);\n      this.ctx.strokeStyle = color;\n      this.current.strokeColor = color;\n    },\n    setFillRGBColor: function CanvasGraphics_setFillRGBColor(r, g, b) {\n      var color = Util.makeCssRgb(r, g, b);\n      this.ctx.fillStyle = color;\n      this.current.fillColor = color;\n      this.current.patternFill = false;\n    },\n\n    shadingFill: function CanvasGraphics_shadingFill(patternIR) {\n      var ctx = this.ctx;\n\n      this.save();\n      var pattern = getShadingPatternFromIR(patternIR);\n      ctx.fillStyle = pattern.getPattern(ctx, this, true);\n\n      var inv = ctx.mozCurrentTransformInverse;\n      if (inv) {\n        var canvas = ctx.canvas;\n        var width = canvas.width;\n        var height = canvas.height;\n\n        var bl = Util.applyTransform([0, 0], inv);\n        var br = Util.applyTransform([0, height], inv);\n        var ul = Util.applyTransform([width, 0], inv);\n        var ur = Util.applyTransform([width, height], inv);\n\n        var x0 = Math.min(bl[0], br[0], ul[0], ur[0]);\n        var y0 = Math.min(bl[1], br[1], ul[1], ur[1]);\n        var x1 = Math.max(bl[0], br[0], ul[0], ur[0]);\n        var y1 = Math.max(bl[1], br[1], ul[1], ur[1]);\n\n        this.ctx.fillRect(x0, y0, x1 - x0, y1 - y0);\n      } else {\n        // HACK to draw the gradient onto an infinite rectangle.\n        // PDF gradients are drawn across the entire image while\n        // Canvas only allows gradients to be drawn in a rectangle\n        // The following bug should allow us to remove this.\n        // https://bugzilla.mozilla.org/show_bug.cgi?id=664884\n\n        this.ctx.fillRect(-1e10, -1e10, 2e10, 2e10);\n      }\n\n      this.restore();\n    },\n\n    // Images\n    beginInlineImage: function CanvasGraphics_beginInlineImage() {\n      error('Should not call beginInlineImage');\n    },\n    beginImageData: function CanvasGraphics_beginImageData() {\n      error('Should not call beginImageData');\n    },\n\n    paintFormXObjectBegin: function CanvasGraphics_paintFormXObjectBegin(matrix,\n                                                                        bbox) {\n      this.save();\n      this.baseTransformStack.push(this.baseTransform);\n\n      if (isArray(matrix) && 6 === matrix.length) {\n        this.transform.apply(this, matrix);\n      }\n\n      this.baseTransform = this.ctx.mozCurrentTransform;\n\n      if (isArray(bbox) && 4 === bbox.length) {\n        var width = bbox[2] - bbox[0];\n        var height = bbox[3] - bbox[1];\n        this.ctx.rect(bbox[0], bbox[1], width, height);\n        this.clip();\n        this.endPath();\n      }\n    },\n\n    paintFormXObjectEnd: function CanvasGraphics_paintFormXObjectEnd() {\n      this.restore();\n      this.baseTransform = this.baseTransformStack.pop();\n    },\n\n    beginGroup: function CanvasGraphics_beginGroup(group) {\n      this.save();\n      var currentCtx = this.ctx;\n      // TODO non-isolated groups - according to Rik at adobe non-isolated\n      // group results aren't usually that different and they even have tools\n      // that ignore this setting. Notes from Rik on implmenting:\n      // - When you encounter an transparency group, create a new canvas with\n      // the dimensions of the bbox\n      // - copy the content from the previous canvas to the new canvas\n      // - draw as usual\n      // - remove the backdrop alpha:\n      // alphaNew = 1 - (1 - alpha)/(1 - alphaBackdrop) with 'alpha' the alpha\n      // value of your transparency group and 'alphaBackdrop' the alpha of the\n      // backdrop\n      // - remove background color:\n      // colorNew = color - alphaNew *colorBackdrop /(1 - alphaNew)\n      if (!group.isolated) {\n        info('TODO: Support non-isolated groups.');\n      }\n\n      // TODO knockout - supposedly possible with the clever use of compositing\n      // modes.\n      if (group.knockout) {\n        warn('Knockout groups not supported.');\n      }\n\n      var currentTransform = currentCtx.mozCurrentTransform;\n      if (group.matrix) {\n        currentCtx.transform.apply(currentCtx, group.matrix);\n      }\n      assert(group.bbox, 'Bounding box is required.');\n\n      // Based on the current transform figure out how big the bounding box\n      // will actually be.\n      var bounds = Util.getAxialAlignedBoundingBox(\n                    group.bbox,\n                    currentCtx.mozCurrentTransform);\n      // Clip the bounding box to the current canvas.\n      var canvasBounds = [0,\n                          0,\n                          currentCtx.canvas.width,\n                          currentCtx.canvas.height];\n      bounds = Util.intersect(bounds, canvasBounds) || [0, 0, 0, 0];\n      // Use ceil in case we're between sizes so we don't create canvas that is\n      // too small and make the canvas at least 1x1 pixels.\n      var offsetX = Math.floor(bounds[0]);\n      var offsetY = Math.floor(bounds[1]);\n      var drawnWidth = Math.max(Math.ceil(bounds[2]) - offsetX, 1);\n      var drawnHeight = Math.max(Math.ceil(bounds[3]) - offsetY, 1);\n      var scaleX = 1, scaleY = 1;\n      if (drawnWidth > MAX_GROUP_SIZE) {\n        scaleX = drawnWidth / MAX_GROUP_SIZE;\n        drawnWidth = MAX_GROUP_SIZE;\n      }\n      if (drawnHeight > MAX_GROUP_SIZE) {\n        scaleY = drawnHeight / MAX_GROUP_SIZE;\n        drawnHeight = MAX_GROUP_SIZE;\n      }\n\n      var cacheId = 'groupAt' + this.groupLevel;\n      if (group.smask) {\n        // Using two cache entries is case if masks are used one after another.\n        cacheId +=  '_smask_' + ((this.smaskCounter++) % 2);\n      }\n      var scratchCanvas = CachedCanvases.getCanvas(\n        cacheId, drawnWidth, drawnHeight, true);\n      var groupCtx = scratchCanvas.context;\n\n      // Since we created a new canvas that is just the size of the bounding box\n      // we have to translate the group ctx.\n      groupCtx.scale(1 / scaleX, 1 / scaleY);\n      groupCtx.translate(-offsetX, -offsetY);\n      groupCtx.transform.apply(groupCtx, currentTransform);\n\n      if (group.smask) {\n        // Saving state and cached mask to be used in setGState.\n        this.smaskStack.push({\n          canvas: scratchCanvas.canvas,\n          context: groupCtx,\n          offsetX: offsetX,\n          offsetY: offsetY,\n          scaleX: scaleX,\n          scaleY: scaleY,\n          subtype: group.smask.subtype,\n          backdrop: group.smask.backdrop\n        });\n      } else {\n        // Setup the current ctx so when the group is popped we draw it at the\n        // right location.\n        currentCtx.setTransform(1, 0, 0, 1, 0, 0);\n        currentCtx.translate(offsetX, offsetY);\n        currentCtx.scale(scaleX, scaleY);\n      }\n      // The transparency group inherits all off the current graphics state\n      // except the blend mode, soft mask, and alpha constants.\n      copyCtxState(currentCtx, groupCtx);\n      this.ctx = groupCtx;\n      this.setGState([\n        ['BM', 'Normal'],\n        ['ca', 1],\n        ['CA', 1]\n      ]);\n      this.groupStack.push(currentCtx);\n      this.groupLevel++;\n    },\n\n    endGroup: function CanvasGraphics_endGroup(group) {\n      this.groupLevel--;\n      var groupCtx = this.ctx;\n      this.ctx = this.groupStack.pop();\n      // Turn off image smoothing to avoid sub pixel interpolation which can\n      // look kind of blurry for some pdfs.\n      if (this.ctx.imageSmoothingEnabled !== undefined) {\n        this.ctx.imageSmoothingEnabled = false;\n      } else {\n        this.ctx.mozImageSmoothingEnabled = false;\n      }\n      if (group.smask) {\n        this.tempSMask = this.smaskStack.pop();\n      } else {\n        this.ctx.drawImage(groupCtx.canvas, 0, 0);\n      }\n      this.restore();\n    },\n\n    beginAnnotations: function CanvasGraphics_beginAnnotations() {\n      this.save();\n      this.current = new CanvasExtraState();\n    },\n\n    endAnnotations: function CanvasGraphics_endAnnotations() {\n      this.restore();\n    },\n\n    beginAnnotation: function CanvasGraphics_beginAnnotation(rect, transform,\n                                                             matrix) {\n      this.save();\n\n      if (isArray(rect) && 4 === rect.length) {\n        var width = rect[2] - rect[0];\n        var height = rect[3] - rect[1];\n        this.ctx.rect(rect[0], rect[1], width, height);\n        this.clip();\n        this.endPath();\n      }\n\n      this.transform.apply(this, transform);\n      this.transform.apply(this, matrix);\n    },\n\n    endAnnotation: function CanvasGraphics_endAnnotation() {\n      this.restore();\n    },\n\n    paintJpegXObject: function CanvasGraphics_paintJpegXObject(objId, w, h) {\n      var domImage = this.objs.get(objId);\n      if (!domImage) {\n        warn('Dependent image isn\\'t ready yet');\n        return;\n      }\n\n      this.save();\n\n      var ctx = this.ctx;\n      // scale the image to the unit square\n      ctx.scale(1 / w, -1 / h);\n\n      ctx.drawImage(domImage, 0, 0, domImage.width, domImage.height,\n                    0, -h, w, h);\n      if (this.imageLayer) {\n        var currentTransform = ctx.mozCurrentTransformInverse;\n        var position = this.getCanvasPosition(0, 0);\n        this.imageLayer.appendImage({\n          objId: objId,\n          left: position[0],\n          top: position[1],\n          width: w / currentTransform[0],\n          height: h / currentTransform[3]\n        });\n      }\n      this.restore();\n    },\n\n    paintImageMaskXObject: function CanvasGraphics_paintImageMaskXObject(img) {\n      var ctx = this.ctx;\n      var width = img.width, height = img.height;\n      var fillColor = this.current.fillColor;\n      var isPatternFill = this.current.patternFill;\n\n      var glyph = this.processingType3;\n\n      if (COMPILE_TYPE3_GLYPHS && glyph && glyph.compiled === undefined) {\n        if (width <= MAX_SIZE_TO_COMPILE && height <= MAX_SIZE_TO_COMPILE) {\n          glyph.compiled =\n            compileType3Glyph({data: img.data, width: width, height: height});\n        } else {\n          glyph.compiled = null;\n        }\n      }\n\n      if (glyph && glyph.compiled) {\n        glyph.compiled(ctx);\n        return;\n      }\n\n      var maskCanvas = CachedCanvases.getCanvas('maskCanvas', width, height);\n      var maskCtx = maskCanvas.context;\n      maskCtx.save();\n\n      putBinaryImageMask(maskCtx, img);\n\n      maskCtx.globalCompositeOperation = 'source-in';\n\n      maskCtx.fillStyle = isPatternFill ?\n                          fillColor.getPattern(maskCtx, this) : fillColor;\n      maskCtx.fillRect(0, 0, width, height);\n\n      maskCtx.restore();\n\n      this.paintInlineImageXObject(maskCanvas.canvas);\n    },\n\n    paintImageMaskXObjectRepeat:\n      function CanvasGraphics_paintImageMaskXObjectRepeat(imgData, scaleX,\n                                                          scaleY, positions) {\n      var width = imgData.width;\n      var height = imgData.height;\n      var fillColor = this.current.fillColor;\n      var isPatternFill = this.current.patternFill;\n\n      var maskCanvas = CachedCanvases.getCanvas('maskCanvas', width, height);\n      var maskCtx = maskCanvas.context;\n      maskCtx.save();\n\n      putBinaryImageMask(maskCtx, imgData);\n\n      maskCtx.globalCompositeOperation = 'source-in';\n\n      maskCtx.fillStyle = isPatternFill ?\n                          fillColor.getPattern(maskCtx, this) : fillColor;\n      maskCtx.fillRect(0, 0, width, height);\n\n      maskCtx.restore();\n\n      var ctx = this.ctx;\n      for (var i = 0, ii = positions.length; i < ii; i += 2) {\n        ctx.save();\n        ctx.transform(scaleX, 0, 0, scaleY, positions[i], positions[i + 1]);\n        ctx.scale(1, -1);\n        ctx.drawImage(maskCanvas.canvas, 0, 0, width, height,\n          0, -1, 1, 1);\n        ctx.restore();\n      }\n    },\n\n    paintImageMaskXObjectGroup:\n      function CanvasGraphics_paintImageMaskXObjectGroup(images) {\n      var ctx = this.ctx;\n\n      var fillColor = this.current.fillColor;\n      var isPatternFill = this.current.patternFill;\n      for (var i = 0, ii = images.length; i < ii; i++) {\n        var image = images[i];\n        var width = image.width, height = image.height;\n\n        var maskCanvas = CachedCanvases.getCanvas('maskCanvas', width, height);\n        var maskCtx = maskCanvas.context;\n        maskCtx.save();\n\n        putBinaryImageMask(maskCtx, image);\n\n        maskCtx.globalCompositeOperation = 'source-in';\n\n        maskCtx.fillStyle = isPatternFill ?\n                            fillColor.getPattern(maskCtx, this) : fillColor;\n        maskCtx.fillRect(0, 0, width, height);\n\n        maskCtx.restore();\n\n        ctx.save();\n        ctx.transform.apply(ctx, image.transform);\n        ctx.scale(1, -1);\n        ctx.drawImage(maskCanvas.canvas, 0, 0, width, height,\n                      0, -1, 1, 1);\n        ctx.restore();\n      }\n    },\n\n    paintImageXObject: function CanvasGraphics_paintImageXObject(objId) {\n      var imgData = this.objs.get(objId);\n      if (!imgData) {\n        warn('Dependent image isn\\'t ready yet');\n        return;\n      }\n\n      this.paintInlineImageXObject(imgData);\n    },\n\n    paintImageXObjectRepeat:\n      function CanvasGraphics_paintImageXObjectRepeat(objId, scaleX, scaleY,\n                                                          positions) {\n      var imgData = this.objs.get(objId);\n      if (!imgData) {\n        warn('Dependent image isn\\'t ready yet');\n        return;\n      }\n\n      var width = imgData.width;\n      var height = imgData.height;\n      var map = [];\n      for (var i = 0, ii = positions.length; i < ii; i += 2) {\n        map.push({transform: [scaleX, 0, 0, scaleY, positions[i],\n                 positions[i + 1]], x: 0, y: 0, w: width, h: height});\n      }\n      this.paintInlineImageXObjectGroup(imgData, map);\n    },\n\n    paintInlineImageXObject:\n      function CanvasGraphics_paintInlineImageXObject(imgData) {\n      var width = imgData.width;\n      var height = imgData.height;\n      var ctx = this.ctx;\n\n      this.save();\n      // scale the image to the unit square\n      ctx.scale(1 / width, -1 / height);\n\n      var currentTransform = ctx.mozCurrentTransformInverse;\n      var a = currentTransform[0], b = currentTransform[1];\n      var widthScale = Math.max(Math.sqrt(a * a + b * b), 1);\n      var c = currentTransform[2], d = currentTransform[3];\n      var heightScale = Math.max(Math.sqrt(c * c + d * d), 1);\n\n      var imgToPaint, tmpCanvas;\n      // instanceof HTMLElement does not work in jsdom node.js module\n      if (imgData instanceof HTMLElement || !imgData.data) {\n        imgToPaint = imgData;\n      } else {\n        tmpCanvas = CachedCanvases.getCanvas('inlineImage', width, height);\n        var tmpCtx = tmpCanvas.context;\n        putBinaryImageData(tmpCtx, imgData);\n        imgToPaint = tmpCanvas.canvas;\n      }\n\n      var paintWidth = width, paintHeight = height;\n      var tmpCanvasId = 'prescale1';\n      // Vertial or horizontal scaling shall not be more than 2 to not loose the\n      // pixels during drawImage operation, painting on the temporary canvas(es)\n      // that are twice smaller in size\n      while ((widthScale > 2 && paintWidth > 1) ||\n             (heightScale > 2 && paintHeight > 1)) {\n        var newWidth = paintWidth, newHeight = paintHeight;\n        if (widthScale > 2 && paintWidth > 1) {\n          newWidth = Math.ceil(paintWidth / 2);\n          widthScale /= paintWidth / newWidth;\n        }\n        if (heightScale > 2 && paintHeight > 1) {\n          newHeight = Math.ceil(paintHeight / 2);\n          heightScale /= paintHeight / newHeight;\n        }\n        tmpCanvas = CachedCanvases.getCanvas(tmpCanvasId, newWidth, newHeight);\n        tmpCtx = tmpCanvas.context;\n        tmpCtx.clearRect(0, 0, newWidth, newHeight);\n        tmpCtx.drawImage(imgToPaint, 0, 0, paintWidth, paintHeight,\n                                     0, 0, newWidth, newHeight);\n        imgToPaint = tmpCanvas.canvas;\n        paintWidth = newWidth;\n        paintHeight = newHeight;\n        tmpCanvasId = tmpCanvasId === 'prescale1' ? 'prescale2' : 'prescale1';\n      }\n      ctx.drawImage(imgToPaint, 0, 0, paintWidth, paintHeight,\n                                0, -height, width, height);\n\n      if (this.imageLayer) {\n        var position = this.getCanvasPosition(0, -height);\n        this.imageLayer.appendImage({\n          imgData: imgData,\n          left: position[0],\n          top: position[1],\n          width: width / currentTransform[0],\n          height: height / currentTransform[3]\n        });\n      }\n      this.restore();\n    },\n\n    paintInlineImageXObjectGroup:\n      function CanvasGraphics_paintInlineImageXObjectGroup(imgData, map) {\n      var ctx = this.ctx;\n      var w = imgData.width;\n      var h = imgData.height;\n\n      var tmpCanvas = CachedCanvases.getCanvas('inlineImage', w, h);\n      var tmpCtx = tmpCanvas.context;\n      putBinaryImageData(tmpCtx, imgData);\n\n      for (var i = 0, ii = map.length; i < ii; i++) {\n        var entry = map[i];\n        ctx.save();\n        ctx.transform.apply(ctx, entry.transform);\n        ctx.scale(1, -1);\n        ctx.drawImage(tmpCanvas.canvas, entry.x, entry.y, entry.w, entry.h,\n                      0, -1, 1, 1);\n        if (this.imageLayer) {\n          var position = this.getCanvasPosition(entry.x, entry.y);\n          this.imageLayer.appendImage({\n            imgData: imgData,\n            left: position[0],\n            top: position[1],\n            width: w,\n            height: h\n          });\n        }\n        ctx.restore();\n      }\n    },\n\n    paintSolidColorImageMask:\n      function CanvasGraphics_paintSolidColorImageMask() {\n        this.ctx.fillRect(0, 0, 1, 1);\n    },\n\n    // Marked content\n\n    markPoint: function CanvasGraphics_markPoint(tag) {\n      // TODO Marked content.\n    },\n    markPointProps: function CanvasGraphics_markPointProps(tag, properties) {\n      // TODO Marked content.\n    },\n    beginMarkedContent: function CanvasGraphics_beginMarkedContent(tag) {\n      // TODO Marked content.\n    },\n    beginMarkedContentProps: function CanvasGraphics_beginMarkedContentProps(\n                                        tag, properties) {\n      // TODO Marked content.\n    },\n    endMarkedContent: function CanvasGraphics_endMarkedContent() {\n      // TODO Marked content.\n    },\n\n    // Compatibility\n\n    beginCompat: function CanvasGraphics_beginCompat() {\n      // TODO ignore undefined operators (should we do that anyway?)\n    },\n    endCompat: function CanvasGraphics_endCompat() {\n      // TODO stop ignoring undefined operators\n    },\n\n    // Helper functions\n\n    consumePath: function CanvasGraphics_consumePath() {\n      var ctx = this.ctx;\n      if (this.pendingClip) {\n        if (this.pendingClip === EO_CLIP) {\n          if (ctx.mozFillRule !== undefined) {\n            ctx.mozFillRule = 'evenodd';\n            ctx.clip();\n            ctx.mozFillRule = 'nonzero';\n          } else {\n            try {\n              ctx.clip('evenodd');\n            } catch (ex) {\n              // shouldn't really happen, but browsers might think differently\n              ctx.clip();\n            }\n          }\n        } else {\n          ctx.clip();\n        }\n        this.pendingClip = null;\n      }\n      ctx.beginPath();\n    },\n    getSinglePixelWidth: function CanvasGraphics_getSinglePixelWidth(scale) {\n      if (this.cachedGetSinglePixelWidth === null) {\n        var inverse = this.ctx.mozCurrentTransformInverse;\n        // max of the current horizontal and vertical scale\n        this.cachedGetSinglePixelWidth = Math.sqrt(Math.max(\n          (inverse[0] * inverse[0] + inverse[1] * inverse[1]),\n          (inverse[2] * inverse[2] + inverse[3] * inverse[3])));\n      }\n      return this.cachedGetSinglePixelWidth;\n    },\n    getCanvasPosition: function CanvasGraphics_getCanvasPosition(x, y) {\n        var transform = this.ctx.mozCurrentTransform;\n        return [\n          transform[0] * x + transform[2] * y + transform[4],\n          transform[1] * x + transform[3] * y + transform[5]\n        ];\n    }\n  };\n\n  for (var op in OPS) {\n    CanvasGraphics.prototype[OPS[op]] = CanvasGraphics.prototype[op];\n  }\n\n  return CanvasGraphics;\n})();\n\n\nvar WebGLUtils = (function WebGLUtilsClosure() {\n  function loadShader(gl, code, shaderType) {\n    var shader = gl.createShader(shaderType);\n    gl.shaderSource(shader, code);\n    gl.compileShader(shader);\n    var compiled = gl.getShaderParameter(shader, gl.COMPILE_STATUS);\n    if (!compiled) {\n      var errorMsg = gl.getShaderInfoLog(shader);\n      throw new Error('Error during shader compilation: ' + errorMsg);\n    }\n    return shader;\n  }\n  function createVertexShader(gl, code) {\n    return loadShader(gl, code, gl.VERTEX_SHADER);\n  }\n  function createFragmentShader(gl, code) {\n    return loadShader(gl, code, gl.FRAGMENT_SHADER);\n  }\n  function createProgram(gl, shaders) {\n    var program = gl.createProgram();\n    for (var i = 0, ii = shaders.length; i < ii; ++i) {\n      gl.attachShader(program, shaders[i]);\n    }\n    gl.linkProgram(program);\n    var linked = gl.getProgramParameter(program, gl.LINK_STATUS);\n    if (!linked) {\n      var errorMsg = gl.getProgramInfoLog(program);\n      throw new Error('Error during program linking: ' + errorMsg);\n    }\n    return program;\n  }\n  function createTexture(gl, image, textureId) {\n    gl.activeTexture(textureId);\n    var texture = gl.createTexture();\n    gl.bindTexture(gl.TEXTURE_2D, texture);\n\n    // Set the parameters so we can render any size image.\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\n\n    // Upload the image into the texture.\n    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);\n    return texture;\n  }\n\n  var currentGL, currentCanvas;\n  function generateGL() {\n    if (currentGL) {\n      return;\n    }\n    currentCanvas = document.createElement('canvas');\n    currentGL = currentCanvas.getContext('webgl',\n      { premultipliedalpha: false });\n  }\n\n  var smaskVertexShaderCode = '\\\n  attribute vec2 a_position;                                    \\\n  attribute vec2 a_texCoord;                                    \\\n                                                                \\\n  uniform vec2 u_resolution;                                    \\\n                                                                \\\n  varying vec2 v_texCoord;                                      \\\n                                                                \\\n  void main() {                                                 \\\n    vec2 clipSpace = (a_position / u_resolution) * 2.0 - 1.0;   \\\n    gl_Position = vec4(clipSpace * vec2(1, -1), 0, 1);          \\\n                                                                \\\n    v_texCoord = a_texCoord;                                    \\\n  }                                                             ';\n\n  var smaskFragmentShaderCode = '\\\n  precision mediump float;                                      \\\n                                                                \\\n  uniform vec4 u_backdrop;                                      \\\n  uniform int u_subtype;                                        \\\n  uniform sampler2D u_image;                                    \\\n  uniform sampler2D u_mask;                                     \\\n                                                                \\\n  varying vec2 v_texCoord;                                      \\\n                                                                \\\n  void main() {                                                 \\\n    vec4 imageColor = texture2D(u_image, v_texCoord);           \\\n    vec4 maskColor = texture2D(u_mask, v_texCoord);             \\\n    if (u_backdrop.a > 0.0) {                                   \\\n      maskColor.rgb = maskColor.rgb * maskColor.a +             \\\n                      u_backdrop.rgb * (1.0 - maskColor.a);     \\\n    }                                                           \\\n    float lum;                                                  \\\n    if (u_subtype == 0) {                                       \\\n      lum = maskColor.a;                                        \\\n    } else {                                                    \\\n      lum = maskColor.r * 0.3 + maskColor.g * 0.59 +            \\\n            maskColor.b * 0.11;                                 \\\n    }                                                           \\\n    imageColor.a *= lum;                                        \\\n    imageColor.rgb *= imageColor.a;                             \\\n    gl_FragColor = imageColor;                                  \\\n  }                                                             ';\n\n  var smaskCache = null;\n\n  function initSmaskGL() {\n    var canvas, gl;\n\n    generateGL();\n    canvas = currentCanvas;\n    currentCanvas = null;\n    gl = currentGL;\n    currentGL = null;\n\n    // setup a GLSL program\n    var vertexShader = createVertexShader(gl, smaskVertexShaderCode);\n    var fragmentShader = createFragmentShader(gl, smaskFragmentShaderCode);\n    var program = createProgram(gl, [vertexShader, fragmentShader]);\n    gl.useProgram(program);\n\n    var cache = {};\n    cache.gl = gl;\n    cache.canvas = canvas;\n    cache.resolutionLocation = gl.getUniformLocation(program, 'u_resolution');\n    cache.positionLocation = gl.getAttribLocation(program, 'a_position');\n    cache.backdropLocation = gl.getUniformLocation(program, 'u_backdrop');\n    cache.subtypeLocation = gl.getUniformLocation(program, 'u_subtype');\n\n    var texCoordLocation = gl.getAttribLocation(program, 'a_texCoord');\n    var texLayerLocation = gl.getUniformLocation(program, 'u_image');\n    var texMaskLocation = gl.getUniformLocation(program, 'u_mask');\n\n    // provide texture coordinates for the rectangle.\n    var texCoordBuffer = gl.createBuffer();\n    gl.bindBuffer(gl.ARRAY_BUFFER, texCoordBuffer);\n    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([\n      0.0,  0.0,\n      1.0,  0.0,\n      0.0,  1.0,\n      0.0,  1.0,\n      1.0,  0.0,\n      1.0,  1.0]), gl.STATIC_DRAW);\n    gl.enableVertexAttribArray(texCoordLocation);\n    gl.vertexAttribPointer(texCoordLocation, 2, gl.FLOAT, false, 0, 0);\n\n    gl.uniform1i(texLayerLocation, 0);\n    gl.uniform1i(texMaskLocation, 1);\n\n    smaskCache = cache;\n  }\n\n  function composeSMask(layer, mask, properties) {\n    var width = layer.width, height = layer.height;\n\n    if (!smaskCache) {\n      initSmaskGL();\n    }\n    var cache = smaskCache,canvas = cache.canvas, gl = cache.gl;\n    canvas.width = width;\n    canvas.height = height;\n    gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);\n    gl.uniform2f(cache.resolutionLocation, width, height);\n\n    if (properties.backdrop) {\n      gl.uniform4f(cache.resolutionLocation, properties.backdrop[0],\n                   properties.backdrop[1], properties.backdrop[2], 1);\n    } else {\n      gl.uniform4f(cache.resolutionLocation, 0, 0, 0, 0);\n    }\n    gl.uniform1i(cache.subtypeLocation,\n                 properties.subtype === 'Luminosity' ? 1 : 0);\n\n    // Create a textures\n    var texture = createTexture(gl, layer, gl.TEXTURE0);\n    var maskTexture = createTexture(gl, mask, gl.TEXTURE1);\n\n\n    // Create a buffer and put a single clipspace rectangle in\n    // it (2 triangles)\n    var buffer = gl.createBuffer();\n    gl.bindBuffer(gl.ARRAY_BUFFER, buffer);\n    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([\n      0, 0,\n      width, 0,\n      0, height,\n      0, height,\n      width, 0,\n      width, height]), gl.STATIC_DRAW);\n    gl.enableVertexAttribArray(cache.positionLocation);\n    gl.vertexAttribPointer(cache.positionLocation, 2, gl.FLOAT, false, 0, 0);\n\n    // draw\n    gl.clearColor(0, 0, 0, 0);\n    gl.enable(gl.BLEND);\n    gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);\n    gl.clear(gl.COLOR_BUFFER_BIT);\n\n    gl.drawArrays(gl.TRIANGLES, 0, 6);\n\n    gl.flush();\n\n    gl.deleteTexture(texture);\n    gl.deleteTexture(maskTexture);\n    gl.deleteBuffer(buffer);\n\n    return canvas;\n  }\n\n  var figuresVertexShaderCode = '\\\n  attribute vec2 a_position;                                    \\\n  attribute vec3 a_color;                                       \\\n                                                                \\\n  uniform vec2 u_resolution;                                    \\\n  uniform vec2 u_scale;                                         \\\n  uniform vec2 u_offset;                                        \\\n                                                                \\\n  varying vec4 v_color;                                         \\\n                                                                \\\n  void main() {                                                 \\\n    vec2 position = (a_position + u_offset) * u_scale;          \\\n    vec2 clipSpace = (position / u_resolution) * 2.0 - 1.0;     \\\n    gl_Position = vec4(clipSpace * vec2(1, -1), 0, 1);          \\\n                                                                \\\n    v_color = vec4(a_color / 255.0, 1.0);                       \\\n  }                                                             ';\n\n  var figuresFragmentShaderCode = '\\\n  precision mediump float;                                      \\\n                                                                \\\n  varying vec4 v_color;                                         \\\n                                                                \\\n  void main() {                                                 \\\n    gl_FragColor = v_color;                                     \\\n  }                                                             ';\n\n  var figuresCache = null;\n\n  function initFiguresGL() {\n    var canvas, gl;\n\n    generateGL();\n    canvas = currentCanvas;\n    currentCanvas = null;\n    gl = currentGL;\n    currentGL = null;\n\n    // setup a GLSL program\n    var vertexShader = createVertexShader(gl, figuresVertexShaderCode);\n    var fragmentShader = createFragmentShader(gl, figuresFragmentShaderCode);\n    var program = createProgram(gl, [vertexShader, fragmentShader]);\n    gl.useProgram(program);\n\n    var cache = {};\n    cache.gl = gl;\n    cache.canvas = canvas;\n    cache.resolutionLocation = gl.getUniformLocation(program, 'u_resolution');\n    cache.scaleLocation = gl.getUniformLocation(program, 'u_scale');\n    cache.offsetLocation = gl.getUniformLocation(program, 'u_offset');\n    cache.positionLocation = gl.getAttribLocation(program, 'a_position');\n    cache.colorLocation = gl.getAttribLocation(program, 'a_color');\n\n    figuresCache = cache;\n  }\n\n  function drawFigures(width, height, backgroundColor, figures, context) {\n    if (!figuresCache) {\n      initFiguresGL();\n    }\n    var cache = figuresCache, canvas = cache.canvas, gl = cache.gl;\n\n    canvas.width = width;\n    canvas.height = height;\n    gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);\n    gl.uniform2f(cache.resolutionLocation, width, height);\n\n    // count triangle points\n    var count = 0;\n    var i, ii, rows;\n    for (i = 0, ii = figures.length; i < ii; i++) {\n      switch (figures[i].type) {\n        case 'lattice':\n          rows = (figures[i].coords.length / figures[i].verticesPerRow) | 0;\n          count += (rows - 1) * (figures[i].verticesPerRow - 1) * 6;\n          break;\n        case 'triangles':\n          count += figures[i].coords.length;\n          break;\n      }\n    }\n    // transfer data\n    var coords = new Float32Array(count * 2);\n    var colors = new Uint8Array(count * 3);\n    var coordsMap = context.coords, colorsMap = context.colors;\n    var pIndex = 0, cIndex = 0;\n    for (i = 0, ii = figures.length; i < ii; i++) {\n      var figure = figures[i], ps = figure.coords, cs = figure.colors;\n      switch (figure.type) {\n        case 'lattice':\n          var cols = figure.verticesPerRow;\n          rows = (ps.length / cols) | 0;\n          for (var row = 1; row < rows; row++) {\n            var offset = row * cols + 1;\n            for (var col = 1; col < cols; col++, offset++) {\n              coords[pIndex] = coordsMap[ps[offset - cols - 1]];\n              coords[pIndex + 1] = coordsMap[ps[offset - cols - 1] + 1];\n              coords[pIndex + 2] = coordsMap[ps[offset - cols]];\n              coords[pIndex + 3] = coordsMap[ps[offset - cols] + 1];\n              coords[pIndex + 4] = coordsMap[ps[offset - 1]];\n              coords[pIndex + 5] = coordsMap[ps[offset - 1] + 1];\n              colors[cIndex] = colorsMap[cs[offset - cols - 1]];\n              colors[cIndex + 1] = colorsMap[cs[offset - cols - 1] + 1];\n              colors[cIndex + 2] = colorsMap[cs[offset - cols - 1] + 2];\n              colors[cIndex + 3] = colorsMap[cs[offset - cols]];\n              colors[cIndex + 4] = colorsMap[cs[offset - cols] + 1];\n              colors[cIndex + 5] = colorsMap[cs[offset - cols] + 2];\n              colors[cIndex + 6] = colorsMap[cs[offset - 1]];\n              colors[cIndex + 7] = colorsMap[cs[offset - 1] + 1];\n              colors[cIndex + 8] = colorsMap[cs[offset - 1] + 2];\n\n              coords[pIndex + 6] = coords[pIndex + 2];\n              coords[pIndex + 7] = coords[pIndex + 3];\n              coords[pIndex + 8] = coords[pIndex + 4];\n              coords[pIndex + 9] = coords[pIndex + 5];\n              coords[pIndex + 10] = coordsMap[ps[offset]];\n              coords[pIndex + 11] = coordsMap[ps[offset] + 1];\n              colors[cIndex + 9] = colors[cIndex + 3];\n              colors[cIndex + 10] = colors[cIndex + 4];\n              colors[cIndex + 11] = colors[cIndex + 5];\n              colors[cIndex + 12] = colors[cIndex + 6];\n              colors[cIndex + 13] = colors[cIndex + 7];\n              colors[cIndex + 14] = colors[cIndex + 8];\n              colors[cIndex + 15] = colorsMap[cs[offset]];\n              colors[cIndex + 16] = colorsMap[cs[offset] + 1];\n              colors[cIndex + 17] = colorsMap[cs[offset] + 2];\n              pIndex += 12;\n              cIndex += 18;\n            }\n          }\n          break;\n        case 'triangles':\n          for (var j = 0, jj = ps.length; j < jj; j++) {\n            coords[pIndex] = coordsMap[ps[j]];\n            coords[pIndex + 1] = coordsMap[ps[j] + 1];\n            colors[cIndex] = colorsMap[cs[i]];\n            colors[cIndex + 1] = colorsMap[cs[j] + 1];\n            colors[cIndex + 2] = colorsMap[cs[j] + 2];\n            pIndex += 2;\n            cIndex += 3;\n          }\n          break;\n      }\n    }\n\n    // draw\n    if (backgroundColor) {\n      gl.clearColor(backgroundColor[0] / 255, backgroundColor[1] / 255,\n                    backgroundColor[2] / 255, 1.0);\n    } else {\n      gl.clearColor(0, 0, 0, 0);\n    }\n    gl.clear(gl.COLOR_BUFFER_BIT);\n\n    var coordsBuffer = gl.createBuffer();\n    gl.bindBuffer(gl.ARRAY_BUFFER, coordsBuffer);\n    gl.bufferData(gl.ARRAY_BUFFER, coords, gl.STATIC_DRAW);\n    gl.enableVertexAttribArray(cache.positionLocation);\n    gl.vertexAttribPointer(cache.positionLocation, 2, gl.FLOAT, false, 0, 0);\n\n    var colorsBuffer = gl.createBuffer();\n    gl.bindBuffer(gl.ARRAY_BUFFER, colorsBuffer);\n    gl.bufferData(gl.ARRAY_BUFFER, colors, gl.STATIC_DRAW);\n    gl.enableVertexAttribArray(cache.colorLocation);\n    gl.vertexAttribPointer(cache.colorLocation, 3, gl.UNSIGNED_BYTE, false,\n                           0, 0);\n\n    gl.uniform2f(cache.scaleLocation, context.scaleX, context.scaleY);\n    gl.uniform2f(cache.offsetLocation, context.offsetX, context.offsetY);\n\n    gl.drawArrays(gl.TRIANGLES, 0, count);\n\n    gl.flush();\n\n    gl.deleteBuffer(coordsBuffer);\n    gl.deleteBuffer(colorsBuffer);\n\n    return canvas;\n  }\n\n  function cleanup() {\n    if (smaskCache && smaskCache.canvas) {\n      smaskCache.canvas.width = 0;\n      smaskCache.canvas.height = 0;\n    }\n    if (figuresCache && figuresCache.canvas) {\n      figuresCache.canvas.width = 0;\n      figuresCache.canvas.height = 0;\n    }\n    smaskCache = null;\n    figuresCache = null;\n  }\n\n  return {\n    get isEnabled() {\n      if (PDFJS.disableWebGL) {\n        return false;\n      }\n      var enabled = false;\n      try {\n        generateGL();\n        enabled = !!currentGL;\n      } catch (e) { }\n      return shadow(this, 'isEnabled', enabled);\n    },\n    composeSMask: composeSMask,\n    drawFigures: drawFigures,\n    clear: cleanup\n  };\n})();\n\n\nvar ShadingIRs = {};\n\nShadingIRs.RadialAxial = {\n  fromIR: function RadialAxial_fromIR(raw) {\n    var type = raw[1];\n    var colorStops = raw[2];\n    var p0 = raw[3];\n    var p1 = raw[4];\n    var r0 = raw[5];\n    var r1 = raw[6];\n    return {\n      type: 'Pattern',\n      getPattern: function RadialAxial_getPattern(ctx) {\n        var grad;\n        if (type === 'axial') {\n          grad = ctx.createLinearGradient(p0[0], p0[1], p1[0], p1[1]);\n        } else if (type === 'radial') {\n          grad = ctx.createRadialGradient(p0[0], p0[1], r0, p1[0], p1[1], r1);\n        }\n\n        for (var i = 0, ii = colorStops.length; i < ii; ++i) {\n          var c = colorStops[i];\n          grad.addColorStop(c[0], c[1]);\n        }\n        return grad;\n      }\n    };\n  }\n};\n\nvar createMeshCanvas = (function createMeshCanvasClosure() {\n  function drawTriangle(data, context, p1, p2, p3, c1, c2, c3) {\n    // Very basic Gouraud-shaded triangle rasterization algorithm.\n    var coords = context.coords, colors = context.colors;\n    var bytes = data.data, rowSize = data.width * 4;\n    var tmp;\n    if (coords[p1 + 1] > coords[p2 + 1]) {\n      tmp = p1; p1 = p2; p2 = tmp; tmp = c1; c1 = c2; c2 = tmp;\n    }\n    if (coords[p2 + 1] > coords[p3 + 1]) {\n      tmp = p2; p2 = p3; p3 = tmp; tmp = c2; c2 = c3; c3 = tmp;\n    }\n    if (coords[p1 + 1] > coords[p2 + 1]) {\n      tmp = p1; p1 = p2; p2 = tmp; tmp = c1; c1 = c2; c2 = tmp;\n    }\n    var x1 = (coords[p1] + context.offsetX) * context.scaleX;\n    var y1 = (coords[p1 + 1] + context.offsetY) * context.scaleY;\n    var x2 = (coords[p2] + context.offsetX) * context.scaleX;\n    var y2 = (coords[p2 + 1] + context.offsetY) * context.scaleY;\n    var x3 = (coords[p3] + context.offsetX) * context.scaleX;\n    var y3 = (coords[p3 + 1] + context.offsetY) * context.scaleY;\n    if (y1 >= y3) {\n      return;\n    }\n    var c1r = colors[c1], c1g = colors[c1 + 1], c1b = colors[c1 + 2];\n    var c2r = colors[c2], c2g = colors[c2 + 1], c2b = colors[c2 + 2];\n    var c3r = colors[c3], c3g = colors[c3 + 1], c3b = colors[c3 + 2];\n\n    var minY = Math.round(y1), maxY = Math.round(y3);\n    var xa, car, cag, cab;\n    var xb, cbr, cbg, cbb;\n    var k;\n    for (var y = minY; y <= maxY; y++) {\n      if (y < y2) {\n        k = y < y1 ? 0 : y1 === y2 ? 1 : (y1 - y) / (y1 - y2);\n        xa = x1 - (x1 - x2) * k;\n        car = c1r - (c1r - c2r) * k;\n        cag = c1g - (c1g - c2g) * k;\n        cab = c1b - (c1b - c2b) * k;\n      } else {\n        k = y > y3 ? 1 : y2 === y3 ? 0 : (y2 - y) / (y2 - y3);\n        xa = x2 - (x2 - x3) * k;\n        car = c2r - (c2r - c3r) * k;\n        cag = c2g - (c2g - c3g) * k;\n        cab = c2b - (c2b - c3b) * k;\n      }\n      k = y < y1 ? 0 : y > y3 ? 1 : (y1 - y) / (y1 - y3);\n      xb = x1 - (x1 - x3) * k;\n      cbr = c1r - (c1r - c3r) * k;\n      cbg = c1g - (c1g - c3g) * k;\n      cbb = c1b - (c1b - c3b) * k;\n      var x1_ = Math.round(Math.min(xa, xb));\n      var x2_ = Math.round(Math.max(xa, xb));\n      var j = rowSize * y + x1_ * 4;\n      for (var x = x1_; x <= x2_; x++) {\n        k = (xa - x) / (xa - xb);\n        k = k < 0 ? 0 : k > 1 ? 1 : k;\n        bytes[j++] = (car - (car - cbr) * k) | 0;\n        bytes[j++] = (cag - (cag - cbg) * k) | 0;\n        bytes[j++] = (cab - (cab - cbb) * k) | 0;\n        bytes[j++] = 255;\n      }\n    }\n  }\n\n  function drawFigure(data, figure, context) {\n    var ps = figure.coords;\n    var cs = figure.colors;\n    var i, ii;\n    switch (figure.type) {\n      case 'lattice':\n        var verticesPerRow = figure.verticesPerRow;\n        var rows = Math.floor(ps.length / verticesPerRow) - 1;\n        var cols = verticesPerRow - 1;\n        for (i = 0; i < rows; i++) {\n          var q = i * verticesPerRow;\n          for (var j = 0; j < cols; j++, q++) {\n            drawTriangle(data, context,\n              ps[q], ps[q + 1], ps[q + verticesPerRow],\n              cs[q], cs[q + 1], cs[q + verticesPerRow]);\n            drawTriangle(data, context,\n              ps[q + verticesPerRow + 1], ps[q + 1], ps[q + verticesPerRow],\n              cs[q + verticesPerRow + 1], cs[q + 1], cs[q + verticesPerRow]);\n          }\n        }\n        break;\n      case 'triangles':\n        for (i = 0, ii = ps.length; i < ii; i += 3) {\n          drawTriangle(data, context,\n            ps[i], ps[i + 1], ps[i + 2],\n            cs[i], cs[i + 1], cs[i + 2]);\n        }\n        break;\n      default:\n        error('illigal figure');\n        break;\n    }\n  }\n\n  function createMeshCanvas(bounds, combinesScale, coords, colors, figures,\n                            backgroundColor) {\n    // we will increase scale on some weird factor to let antialiasing take\n    // care of \"rough\" edges\n    var EXPECTED_SCALE = 1.1;\n    // MAX_PATTERN_SIZE is used to avoid OOM situation.\n    var MAX_PATTERN_SIZE = 3000; // 10in @ 300dpi shall be enough\n\n    var offsetX = Math.floor(bounds[0]);\n    var offsetY = Math.floor(bounds[1]);\n    var boundsWidth = Math.ceil(bounds[2]) - offsetX;\n    var boundsHeight = Math.ceil(bounds[3]) - offsetY;\n\n    var width = Math.min(Math.ceil(Math.abs(boundsWidth * combinesScale[0] *\n      EXPECTED_SCALE)), MAX_PATTERN_SIZE);\n    var height = Math.min(Math.ceil(Math.abs(boundsHeight * combinesScale[1] *\n      EXPECTED_SCALE)), MAX_PATTERN_SIZE);\n    var scaleX = boundsWidth / width;\n    var scaleY = boundsHeight / height;\n\n    var context = {\n      coords: coords,\n      colors: colors,\n      offsetX: -offsetX,\n      offsetY: -offsetY,\n      scaleX: 1 / scaleX,\n      scaleY: 1 / scaleY\n    };\n\n    var canvas, tmpCanvas, i, ii;\n    if (WebGLUtils.isEnabled) {\n      canvas = WebGLUtils.drawFigures(width, height, backgroundColor,\n                                      figures, context);\n\n      // https://bugzilla.mozilla.org/show_bug.cgi?id=972126\n      tmpCanvas = CachedCanvases.getCanvas('mesh', width, height, false);\n      tmpCanvas.context.drawImage(canvas, 0, 0);\n      canvas = tmpCanvas.canvas;\n    } else {\n      tmpCanvas = CachedCanvases.getCanvas('mesh', width, height, false);\n      var tmpCtx = tmpCanvas.context;\n\n      var data = tmpCtx.createImageData(width, height);\n      if (backgroundColor) {\n        var bytes = data.data;\n        for (i = 0, ii = bytes.length; i < ii; i += 4) {\n          bytes[i] = backgroundColor[0];\n          bytes[i + 1] = backgroundColor[1];\n          bytes[i + 2] = backgroundColor[2];\n          bytes[i + 3] = 255;\n        }\n      }\n      for (i = 0; i < figures.length; i++) {\n        drawFigure(data, figures[i], context);\n      }\n      tmpCtx.putImageData(data, 0, 0);\n      canvas = tmpCanvas.canvas;\n    }\n\n    return {canvas: canvas, offsetX: offsetX, offsetY: offsetY,\n            scaleX: scaleX, scaleY: scaleY};\n  }\n  return createMeshCanvas;\n})();\n\nShadingIRs.Mesh = {\n  fromIR: function Mesh_fromIR(raw) {\n    //var type = raw[1];\n    var coords = raw[2];\n    var colors = raw[3];\n    var figures = raw[4];\n    var bounds = raw[5];\n    var matrix = raw[6];\n    //var bbox = raw[7];\n    var background = raw[8];\n    return {\n      type: 'Pattern',\n      getPattern: function Mesh_getPattern(ctx, owner, shadingFill) {\n        var scale;\n        if (shadingFill) {\n          scale = Util.singularValueDecompose2dScale(ctx.mozCurrentTransform);\n        } else {\n          // Obtain scale from matrix and current transformation matrix.\n          scale = Util.singularValueDecompose2dScale(owner.baseTransform);\n          if (matrix) {\n            var matrixScale = Util.singularValueDecompose2dScale(matrix);\n            scale = [scale[0] * matrixScale[0],\n                     scale[1] * matrixScale[1]];\n          }\n        }\n\n\n        // Rasterizing on the main thread since sending/queue large canvases\n        // might cause OOM.\n        var temporaryPatternCanvas = createMeshCanvas(bounds, scale, coords,\n          colors, figures, shadingFill ? null : background);\n\n        if (!shadingFill) {\n          ctx.setTransform.apply(ctx, owner.baseTransform);\n          if (matrix) {\n            ctx.transform.apply(ctx, matrix);\n          }\n        }\n\n        ctx.translate(temporaryPatternCanvas.offsetX,\n                      temporaryPatternCanvas.offsetY);\n        ctx.scale(temporaryPatternCanvas.scaleX,\n                  temporaryPatternCanvas.scaleY);\n\n        return ctx.createPattern(temporaryPatternCanvas.canvas, 'no-repeat');\n      }\n    };\n  }\n};\n\nShadingIRs.Dummy = {\n  fromIR: function Dummy_fromIR() {\n    return {\n      type: 'Pattern',\n      getPattern: function Dummy_fromIR_getPattern() {\n        return 'hotpink';\n      }\n    };\n  }\n};\n\nfunction getShadingPatternFromIR(raw) {\n  var shadingIR = ShadingIRs[raw[0]];\n  if (!shadingIR) {\n    error('Unknown IR type: ' + raw[0]);\n  }\n  return shadingIR.fromIR(raw);\n}\n\nvar TilingPattern = (function TilingPatternClosure() {\n  var PaintType = {\n    COLORED: 1,\n    UNCOLORED: 2\n  };\n\n  var MAX_PATTERN_SIZE = 3000; // 10in @ 300dpi shall be enough\n\n  function TilingPattern(IR, color, ctx, objs, commonObjs, baseTransform) {\n    this.operatorList = IR[2];\n    this.matrix = IR[3] || [1, 0, 0, 1, 0, 0];\n    this.bbox = IR[4];\n    this.xstep = IR[5];\n    this.ystep = IR[6];\n    this.paintType = IR[7];\n    this.tilingType = IR[8];\n    this.color = color;\n    this.objs = objs;\n    this.commonObjs = commonObjs;\n    this.baseTransform = baseTransform;\n    this.type = 'Pattern';\n    this.ctx = ctx;\n  }\n\n  TilingPattern.prototype = {\n    createPatternCanvas: function TilinPattern_createPatternCanvas(owner) {\n      var operatorList = this.operatorList;\n      var bbox = this.bbox;\n      var xstep = this.xstep;\n      var ystep = this.ystep;\n      var paintType = this.paintType;\n      var tilingType = this.tilingType;\n      var color = this.color;\n      var objs = this.objs;\n      var commonObjs = this.commonObjs;\n\n      info('TilingType: ' + tilingType);\n\n      var x0 = bbox[0], y0 = bbox[1], x1 = bbox[2], y1 = bbox[3];\n\n      var topLeft = [x0, y0];\n      // we want the canvas to be as large as the step size\n      var botRight = [x0 + xstep, y0 + ystep];\n\n      var width = botRight[0] - topLeft[0];\n      var height = botRight[1] - topLeft[1];\n\n      // Obtain scale from matrix and current transformation matrix.\n      var matrixScale = Util.singularValueDecompose2dScale(this.matrix);\n      var curMatrixScale = Util.singularValueDecompose2dScale(\n        this.baseTransform);\n      var combinedScale = [matrixScale[0] * curMatrixScale[0],\n        matrixScale[1] * curMatrixScale[1]];\n\n      // MAX_PATTERN_SIZE is used to avoid OOM situation.\n      // Use width and height values that are as close as possible to the end\n      // result when the pattern is used. Too low value makes the pattern look\n      // blurry. Too large value makes it look too crispy.\n      width = Math.min(Math.ceil(Math.abs(width * combinedScale[0])),\n        MAX_PATTERN_SIZE);\n\n      height = Math.min(Math.ceil(Math.abs(height * combinedScale[1])),\n        MAX_PATTERN_SIZE);\n\n      var tmpCanvas = CachedCanvases.getCanvas('pattern', width, height, true);\n      var tmpCtx = tmpCanvas.context;\n      var graphics = new CanvasGraphics(tmpCtx, commonObjs, objs);\n      graphics.groupLevel = owner.groupLevel;\n\n      this.setFillAndStrokeStyleToContext(tmpCtx, paintType, color);\n\n      this.setScale(width, height, xstep, ystep);\n      this.transformToScale(graphics);\n\n      // transform coordinates to pattern space\n      var tmpTranslate = [1, 0, 0, 1, -topLeft[0], -topLeft[1]];\n      graphics.transform.apply(graphics, tmpTranslate);\n\n      this.clipBbox(graphics, bbox, x0, y0, x1, y1);\n\n      graphics.executeOperatorList(operatorList);\n      return tmpCanvas.canvas;\n    },\n\n    setScale: function TilingPattern_setScale(width, height, xstep, ystep) {\n      this.scale = [width / xstep, height / ystep];\n    },\n\n    transformToScale: function TilingPattern_transformToScale(graphics) {\n      var scale = this.scale;\n      var tmpScale = [scale[0], 0, 0, scale[1], 0, 0];\n      graphics.transform.apply(graphics, tmpScale);\n    },\n\n    scaleToContext: function TilingPattern_scaleToContext() {\n      var scale = this.scale;\n      this.ctx.scale(1 / scale[0], 1 / scale[1]);\n    },\n\n    clipBbox: function clipBbox(graphics, bbox, x0, y0, x1, y1) {\n      if (bbox && isArray(bbox) && bbox.length === 4) {\n        var bboxWidth = x1 - x0;\n        var bboxHeight = y1 - y0;\n        graphics.ctx.rect(x0, y0, bboxWidth, bboxHeight);\n        graphics.clip();\n        graphics.endPath();\n      }\n    },\n\n    setFillAndStrokeStyleToContext:\n      function setFillAndStrokeStyleToContext(context, paintType, color) {\n        switch (paintType) {\n          case PaintType.COLORED:\n            var ctx = this.ctx;\n            context.fillStyle = ctx.fillStyle;\n            context.strokeStyle = ctx.strokeStyle;\n            break;\n          case PaintType.UNCOLORED:\n            var cssColor = Util.makeCssRgb(color[0], color[1], color[2]);\n            context.fillStyle = cssColor;\n            context.strokeStyle = cssColor;\n            break;\n          default:\n            error('Unsupported paint type: ' + paintType);\n        }\n      },\n\n    getPattern: function TilingPattern_getPattern(ctx, owner) {\n      var temporaryPatternCanvas = this.createPatternCanvas(owner);\n\n      ctx = this.ctx;\n      ctx.setTransform.apply(ctx, this.baseTransform);\n      ctx.transform.apply(ctx, this.matrix);\n      this.scaleToContext();\n\n      return ctx.createPattern(temporaryPatternCanvas, 'repeat');\n    }\n  };\n\n  return TilingPattern;\n})();\n\n\nPDFJS.disableFontFace = false;\n\nvar FontLoader = {\n  insertRule: function fontLoaderInsertRule(rule) {\n    var styleElement = document.getElementById('PDFJS_FONT_STYLE_TAG');\n    if (!styleElement) {\n      styleElement = document.createElement('style');\n      styleElement.id = 'PDFJS_FONT_STYLE_TAG';\n      document.documentElement.getElementsByTagName('head')[0].appendChild(\n        styleElement);\n    }\n\n    var styleSheet = styleElement.sheet;\n    styleSheet.insertRule(rule, styleSheet.cssRules.length);\n  },\n\n  clear: function fontLoaderClear() {\n    var styleElement = document.getElementById('PDFJS_FONT_STYLE_TAG');\n    if (styleElement) {\n      styleElement.parentNode.removeChild(styleElement);\n    }\n    this.nativeFontFaces.forEach(function(nativeFontFace) {\n      document.fonts.delete(nativeFontFace);\n    });\n    this.nativeFontFaces.length = 0;\n  },\n  get loadTestFont() {\n    // This is a CFF font with 1 glyph for '.' that fills its entire width and\n    // height.\n    return shadow(this, 'loadTestFont', atob(\n      'T1RUTwALAIAAAwAwQ0ZGIDHtZg4AAAOYAAAAgUZGVE1lkzZwAAAEHAAAABxHREVGABQAFQ' +\n      'AABDgAAAAeT1MvMlYNYwkAAAEgAAAAYGNtYXABDQLUAAACNAAAAUJoZWFk/xVFDQAAALwA' +\n      'AAA2aGhlYQdkA+oAAAD0AAAAJGhtdHgD6AAAAAAEWAAAAAZtYXhwAAJQAAAAARgAAAAGbm' +\n      'FtZVjmdH4AAAGAAAAAsXBvc3T/hgAzAAADeAAAACAAAQAAAAEAALZRFsRfDzz1AAsD6AAA' +\n      'AADOBOTLAAAAAM4KHDwAAAAAA+gDIQAAAAgAAgAAAAAAAAABAAADIQAAAFoD6AAAAAAD6A' +\n      'ABAAAAAAAAAAAAAAAAAAAAAQAAUAAAAgAAAAQD6AH0AAUAAAKKArwAAACMAooCvAAAAeAA' +\n      'MQECAAACAAYJAAAAAAAAAAAAAQAAAAAAAAAAAAAAAFBmRWQAwAAuAC4DIP84AFoDIQAAAA' +\n      'AAAQAAAAAAAAAAACAAIAABAAAADgCuAAEAAAAAAAAAAQAAAAEAAAAAAAEAAQAAAAEAAAAA' +\n      'AAIAAQAAAAEAAAAAAAMAAQAAAAEAAAAAAAQAAQAAAAEAAAAAAAUAAQAAAAEAAAAAAAYAAQ' +\n      'AAAAMAAQQJAAAAAgABAAMAAQQJAAEAAgABAAMAAQQJAAIAAgABAAMAAQQJAAMAAgABAAMA' +\n      'AQQJAAQAAgABAAMAAQQJAAUAAgABAAMAAQQJAAYAAgABWABYAAAAAAAAAwAAAAMAAAAcAA' +\n      'EAAAAAADwAAwABAAAAHAAEACAAAAAEAAQAAQAAAC7//wAAAC7////TAAEAAAAAAAABBgAA' +\n      'AQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAA' +\n      'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA' +\n      'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA' +\n      'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA' +\n      'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMAAA' +\n      'AAAAD/gwAyAAAAAQAAAAAAAAAAAAAAAAAAAAABAAQEAAEBAQJYAAEBASH4DwD4GwHEAvgc' +\n      'A/gXBIwMAYuL+nz5tQXkD5j3CBLnEQACAQEBIVhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWF' +\n      'hYWFhYWFhYAAABAQAADwACAQEEE/t3Dov6fAH6fAT+fPp8+nwHDosMCvm1Cvm1DAz6fBQA' +\n      'AAAAAAABAAAAAMmJbzEAAAAAzgTjFQAAAADOBOQpAAEAAAAAAAAADAAUAAQAAAABAAAAAg' +\n      'ABAAAAAAAAAAAD6AAAAAAAAA=='\n    ));\n  },\n\n  loadTestFontId: 0,\n\n  loadingContext: {\n    requests: [],\n    nextRequestId: 0\n  },\n\n  isSyncFontLoadingSupported: (function detectSyncFontLoadingSupport() {\n    if (isWorker) {\n      return false;\n    }\n\n    // User agent string sniffing is bad, but there is no reliable way to tell\n    // if font is fully loaded and ready to be used with canvas.\n    var userAgent = window.navigator.userAgent;\n    var m = /Mozilla\\/5.0.*?rv:(\\d+).*? Gecko/.exec(userAgent);\n    if (m && m[1] >= 14) {\n      return true;\n    }\n    // TODO other browsers\n    if (userAgent === 'node') {\n      return true;\n    }\n    return false;\n  })(),\n\n  nativeFontFaces: [],\n\n  isFontLoadingAPISupported: (!isWorker && typeof document !== 'undefined' &&\n                              !!document.fonts),\n\n  addNativeFontFace: function fontLoader_addNativeFontFace(nativeFontFace) {\n    this.nativeFontFaces.push(nativeFontFace);\n    document.fonts.add(nativeFontFace);\n  },\n\n  bind: function fontLoaderBind(fonts, callback) {\n    assert(!isWorker, 'bind() shall be called from main thread');\n\n    var rules = [];\n    var fontsToLoad = [];\n    var fontLoadPromises = [];\n    for (var i = 0, ii = fonts.length; i < ii; i++) {\n      var font = fonts[i];\n\n      // Add the font to the DOM only once or skip if the font\n      // is already loaded.\n      if (font.attached || font.loading === false) {\n        continue;\n      }\n      font.attached = true;\n\n      if (this.isFontLoadingAPISupported) {\n        var nativeFontFace = font.createNativeFontFace();\n        if (nativeFontFace) {\n          fontLoadPromises.push(nativeFontFace.loaded);\n        }\n      } else {\n        var rule = font.bindDOM();\n        if (rule) {\n          rules.push(rule);\n          fontsToLoad.push(font);\n        }\n      }\n    }\n\n    var request = FontLoader.queueLoadingCallback(callback);\n    if (this.isFontLoadingAPISupported) {\n      Promise.all(fontsToLoad).then(function() {\n        request.complete();\n      });\n    } else if (rules.length > 0 && !this.isSyncFontLoadingSupported) {\n      FontLoader.prepareFontLoadEvent(rules, fontsToLoad, request);\n    } else {\n      request.complete();\n    }\n  },\n\n  queueLoadingCallback: function FontLoader_queueLoadingCallback(callback) {\n    function LoadLoader_completeRequest() {\n      assert(!request.end, 'completeRequest() cannot be called twice');\n      request.end = Date.now();\n\n      // sending all completed requests in order how they were queued\n      while (context.requests.length > 0 && context.requests[0].end) {\n        var otherRequest = context.requests.shift();\n        setTimeout(otherRequest.callback, 0);\n      }\n    }\n\n    var context = FontLoader.loadingContext;\n    var requestId = 'pdfjs-font-loading-' + (context.nextRequestId++);\n    var request = {\n      id: requestId,\n      complete: LoadLoader_completeRequest,\n      callback: callback,\n      started: Date.now()\n    };\n    context.requests.push(request);\n    return request;\n  },\n\n  prepareFontLoadEvent: function fontLoaderPrepareFontLoadEvent(rules,\n                                                                fonts,\n                                                                request) {\n      /** Hack begin */\n      // There's currently no event when a font has finished downloading so the\n      // following code is a dirty hack to 'guess' when a font is\n      // ready. It's assumed fonts are loaded in order, so add a known test\n      // font after the desired fonts and then test for the loading of that\n      // test font.\n\n      function int32(data, offset) {\n        return (data.charCodeAt(offset) << 24) |\n               (data.charCodeAt(offset + 1) << 16) |\n               (data.charCodeAt(offset + 2) << 8) |\n               (data.charCodeAt(offset + 3) & 0xff);\n      }\n\n      function spliceString(s, offset, remove, insert) {\n        var chunk1 = s.substr(0, offset);\n        var chunk2 = s.substr(offset + remove);\n        return chunk1 + insert + chunk2;\n      }\n\n      var i, ii;\n\n      var canvas = document.createElement('canvas');\n      canvas.width = 1;\n      canvas.height = 1;\n      var ctx = canvas.getContext('2d');\n\n      var called = 0;\n      function isFontReady(name, callback) {\n        called++;\n        // With setTimeout clamping this gives the font ~100ms to load.\n        if(called > 30) {\n          warn('Load test font never loaded.');\n          callback();\n          return;\n        }\n        ctx.font = '30px ' + name;\n        ctx.fillText('.', 0, 20);\n        var imageData = ctx.getImageData(0, 0, 1, 1);\n        if (imageData.data[3] > 0) {\n          callback();\n          return;\n        }\n        setTimeout(isFontReady.bind(null, name, callback));\n      }\n\n      var loadTestFontId = 'lt' + Date.now() + this.loadTestFontId++;\n      // Chromium seems to cache fonts based on a hash of the actual font data,\n      // so the font must be modified for each load test else it will appear to\n      // be loaded already.\n      // TODO: This could maybe be made faster by avoiding the btoa of the full\n      // font by splitting it in chunks before hand and padding the font id.\n      var data = this.loadTestFont;\n      var COMMENT_OFFSET = 976; // has to be on 4 byte boundary (for checksum)\n      data = spliceString(data, COMMENT_OFFSET, loadTestFontId.length,\n                          loadTestFontId);\n      // CFF checksum is important for IE, adjusting it\n      var CFF_CHECKSUM_OFFSET = 16;\n      var XXXX_VALUE = 0x58585858; // the \"comment\" filled with 'X'\n      var checksum = int32(data, CFF_CHECKSUM_OFFSET);\n      for (i = 0, ii = loadTestFontId.length - 3; i < ii; i += 4) {\n        checksum = (checksum - XXXX_VALUE + int32(loadTestFontId, i)) | 0;\n      }\n      if (i < loadTestFontId.length) { // align to 4 bytes boundary\n        checksum = (checksum - XXXX_VALUE +\n                    int32(loadTestFontId + 'XXX', i)) | 0;\n      }\n      data = spliceString(data, CFF_CHECKSUM_OFFSET, 4, string32(checksum));\n\n      var url = 'url(data:font/opentype;base64,' + btoa(data) + ');';\n      var rule = '@font-face { font-family:\"' + loadTestFontId + '\";src:' +\n                 url + '}';\n      FontLoader.insertRule(rule);\n\n      var names = [];\n      for (i = 0, ii = fonts.length; i < ii; i++) {\n        names.push(fonts[i].loadedName);\n      }\n      names.push(loadTestFontId);\n\n      var div = document.createElement('div');\n      div.setAttribute('style',\n                       'visibility: hidden;' +\n                       'width: 10px; height: 10px;' +\n                       'position: absolute; top: 0px; left: 0px;');\n      for (i = 0, ii = names.length; i < ii; ++i) {\n        var span = document.createElement('span');\n        span.textContent = 'Hi';\n        span.style.fontFamily = names[i];\n        div.appendChild(span);\n      }\n      document.body.appendChild(div);\n\n      isFontReady(loadTestFontId, function() {\n        document.body.removeChild(div);\n        request.complete();\n      });\n      /** Hack end */\n  }\n};\n\nvar FontFaceObject = (function FontFaceObjectClosure() {\n  function FontFaceObject(name, file, properties) {\n    this.compiledGlyphs = {};\n    if (arguments.length === 1) {\n      // importing translated data\n      var data = arguments[0];\n      for (var i in data) {\n        this[i] = data[i];\n      }\n      return;\n    }\n  }\n  FontFaceObject.prototype = {\n    createNativeFontFace: function FontFaceObject_createNativeFontFace() {\n      if (!this.data) {\n        return null;\n      }\n\n      if (PDFJS.disableFontFace) {\n        this.disableFontFace = true;\n        return null;\n      }\n\n      var nativeFontFace = new FontFace(this.loadedName, this.data, {});\n\n      FontLoader.addNativeFontFace(nativeFontFace);\n\n      if (PDFJS.pdfBug && 'FontInspector' in globalScope &&\n          globalScope['FontInspector'].enabled) {\n        globalScope['FontInspector'].fontAdded(this);\n      }\n      return nativeFontFace;\n    },\n\n    bindDOM: function FontFaceObject_bindDOM() {\n      if (!this.data) {\n        return null;\n      }\n\n      if (PDFJS.disableFontFace) {\n        this.disableFontFace = true;\n        return null;\n      }\n\n      var data = bytesToString(new Uint8Array(this.data));\n      var fontName = this.loadedName;\n\n      // Add the font-face rule to the document\n      var url = ('url(data:' + this.mimetype + ';base64,' +\n                 window.btoa(data) + ');');\n      var rule = '@font-face { font-family:\"' + fontName + '\";src:' + url + '}';\n      FontLoader.insertRule(rule);\n\n      if (PDFJS.pdfBug && 'FontInspector' in globalScope &&\n          globalScope['FontInspector'].enabled) {\n        globalScope['FontInspector'].fontAdded(this, url);\n      }\n\n      return rule;\n    },\n\n    getPathGenerator: function FontLoader_getPathGenerator(objs, character) {\n      if (!(character in this.compiledGlyphs)) {\n        var js = objs.get(this.loadedName + '_path_' + character);\n        /*jshint -W054 */\n        this.compiledGlyphs[character] = new Function('c', 'size', js);\n      }\n      return this.compiledGlyphs[character];\n    }\n  };\n  return FontFaceObject;\n})();\n\n\nvar ANNOT_MIN_SIZE = 10; // px\n\nvar AnnotationUtils = (function AnnotationUtilsClosure() {\n  // TODO(mack): This dupes some of the logic in CanvasGraphics.setFont()\n  function setTextStyles(element, item, fontObj) {\n\n    var style = element.style;\n    style.fontSize = item.fontSize + 'px';\n    style.direction = item.fontDirection < 0 ? 'rtl': 'ltr';\n\n    if (!fontObj) {\n      return;\n    }\n\n    style.fontWeight = fontObj.black ?\n      (fontObj.bold ? 'bolder' : 'bold') :\n      (fontObj.bold ? 'bold' : 'normal');\n    style.fontStyle = fontObj.italic ? 'italic' : 'normal';\n\n    var fontName = fontObj.loadedName;\n    var fontFamily = fontName ? '\"' + fontName + '\", ' : '';\n    // Use a reasonable default font if the font doesn't specify a fallback\n    var fallbackName = fontObj.fallbackName || 'Helvetica, sans-serif';\n    style.fontFamily = fontFamily + fallbackName;\n  }\n\n  function initContainer(item, drawBorder) {\n    var container = document.createElement('section');\n    var cstyle = container.style;\n    var width = item.rect[2] - item.rect[0];\n    var height = item.rect[3] - item.rect[1];\n\n    var bWidth = item.borderWidth || 0;\n    if (bWidth) {\n      width = width - 2 * bWidth;\n      height = height - 2 * bWidth;\n      cstyle.borderWidth = bWidth + 'px';\n      var color = item.color;\n      if (drawBorder && color) {\n        cstyle.borderStyle = 'solid';\n        cstyle.borderColor = Util.makeCssRgb(Math.round(color[0] * 255),\n                                             Math.round(color[1] * 255),\n                                             Math.round(color[2] * 255));\n      }\n    }\n    cstyle.width = width + 'px';\n    cstyle.height = height + 'px';\n    return container;\n  }\n\n  function getHtmlElementForTextWidgetAnnotation(item, commonObjs) {\n    var element = document.createElement('div');\n    var width = item.rect[2] - item.rect[0];\n    var height = item.rect[3] - item.rect[1];\n    element.style.width = width + 'px';\n    element.style.height = height + 'px';\n    element.style.display = 'table';\n\n    var content = document.createElement('div');\n    content.textContent = item.fieldValue;\n    var textAlignment = item.textAlignment;\n    content.style.textAlign = ['left', 'center', 'right'][textAlignment];\n    content.style.verticalAlign = 'middle';\n    content.style.display = 'table-cell';\n\n    var fontObj = item.fontRefName ?\n      commonObjs.getData(item.fontRefName) : null;\n    setTextStyles(content, item, fontObj);\n\n    element.appendChild(content);\n\n    return element;\n  }\n\n  function getHtmlElementForTextAnnotation(item) {\n    var rect = item.rect;\n\n    // sanity check because of OOo-generated PDFs\n    if ((rect[3] - rect[1]) < ANNOT_MIN_SIZE) {\n      rect[3] = rect[1] + ANNOT_MIN_SIZE;\n    }\n    if ((rect[2] - rect[0]) < ANNOT_MIN_SIZE) {\n      rect[2] = rect[0] + (rect[3] - rect[1]); // make it square\n    }\n\n    var container = initContainer(item, false);\n    container.className = 'annotText';\n\n    var image  = document.createElement('img');\n    image.style.height = container.style.height;\n    image.style.width = container.style.width;\n    var iconName = item.name;\n    image.src = PDFJS.imageResourcesPath + 'annotation-' +\n      iconName.toLowerCase() + '.svg';\n    image.alt = '[{{type}} Annotation]';\n    image.dataset.l10nId = 'text_annotation_type';\n    image.dataset.l10nArgs = JSON.stringify({type: iconName});\n\n    var contentWrapper = document.createElement('div');\n    contentWrapper.className = 'annotTextContentWrapper';\n    contentWrapper.style.left = Math.floor(rect[2] - rect[0] + 5) + 'px';\n    contentWrapper.style.top = '-10px';\n\n    var content = document.createElement('div');\n    content.className = 'annotTextContent';\n    content.setAttribute('hidden', true);\n\n    var i, ii;\n    if (item.hasBgColor) {\n      var color = item.color;\n\n      // Enlighten the color (70%)\n      var BACKGROUND_ENLIGHT = 0.7;\n      var r = BACKGROUND_ENLIGHT * (1.0 - color[0]) + color[0];\n      var g = BACKGROUND_ENLIGHT * (1.0 - color[1]) + color[1];\n      var b = BACKGROUND_ENLIGHT * (1.0 - color[2]) + color[2];\n      content.style.backgroundColor = Util.makeCssRgb((r * 255) | 0,\n                                                      (g * 255) | 0,\n                                                      (b * 255) | 0);\n    }\n\n    var title = document.createElement('h1');\n    var text = document.createElement('p');\n    title.textContent = item.title;\n\n    if (!item.content && !item.title) {\n      content.setAttribute('hidden', true);\n    } else {\n      var e = document.createElement('span');\n      var lines = item.content.split(/(?:\\r\\n?|\\n)/);\n      for (i = 0, ii = lines.length; i < ii; ++i) {\n        var line = lines[i];\n        e.appendChild(document.createTextNode(line));\n        if (i < (ii - 1)) {\n          e.appendChild(document.createElement('br'));\n        }\n      }\n      text.appendChild(e);\n\n      var pinned = false;\n\n      var showAnnotation = function showAnnotation(pin) {\n        if (pin) {\n          pinned = true;\n        }\n        if (content.hasAttribute('hidden')) {\n          container.style.zIndex += 1;\n          content.removeAttribute('hidden');\n        }\n      };\n\n      var hideAnnotation = function hideAnnotation(unpin) {\n        if (unpin) {\n          pinned = false;\n        }\n        if (!content.hasAttribute('hidden') && !pinned) {\n          container.style.zIndex -= 1;\n          content.setAttribute('hidden', true);\n        }\n      };\n\n      var toggleAnnotation = function toggleAnnotation() {\n        if (pinned) {\n          hideAnnotation(true);\n        } else {\n          showAnnotation(true);\n        }\n      };\n\n      image.addEventListener('click', function image_clickHandler() {\n        toggleAnnotation();\n      }, false);\n      image.addEventListener('mouseover', function image_mouseOverHandler() {\n        showAnnotation();\n      }, false);\n      image.addEventListener('mouseout', function image_mouseOutHandler() {\n        hideAnnotation();\n      }, false);\n\n      content.addEventListener('click', function content_clickHandler() {\n        hideAnnotation(true);\n      }, false);\n    }\n\n    content.appendChild(title);\n    content.appendChild(text);\n    contentWrapper.appendChild(content);\n    container.appendChild(image);\n    container.appendChild(contentWrapper);\n\n    return container;\n  }\n\n  function getHtmlElementForLinkAnnotation(item) {\n    var container = initContainer(item, true);\n    container.className = 'annotLink';\n\n    var link = document.createElement('a');\n    link.href = link.title = item.url || '';\n    if (item.url && PDFJS.openExternalLinksInNewWindow) {\n      link.target = '_blank';\n    }\n\n    container.appendChild(link);\n\n    return container;\n  }\n\n  function getHtmlElement(data, objs) {\n    switch (data.annotationType) {\n      case AnnotationType.WIDGET:\n        return getHtmlElementForTextWidgetAnnotation(data, objs);\n      case AnnotationType.TEXT:\n        return getHtmlElementForTextAnnotation(data);\n      case AnnotationType.LINK:\n        return getHtmlElementForLinkAnnotation(data);\n      default:\n        throw new Error('Unsupported annotationType: ' + data.annotationType);\n    }\n  }\n\n  return {\n    getHtmlElement: getHtmlElement\n  };\n})();\nPDFJS.AnnotationUtils = AnnotationUtils;\n\n\nvar SVG_DEFAULTS = {\n  fontStyle: 'normal',\n  fontWeight: 'normal',\n  fillColor: '#000000'\n};\n\nvar convertImgDataToPng = (function convertImgDataToPngClosure() {\n  var PNG_HEADER =\n    new Uint8Array([0x89, 0x50, 0x4e, 0x47, 0x0d, 0x0a, 0x1a, 0x0a]);\n\n  var CHUNK_WRAPPER_SIZE = 12;\n\n  var crcTable = new Int32Array(256);\n  for (var i = 0; i < 256; i++) {\n    var c = i;\n    for (var h = 0; h < 8; h++) {\n      if (c & 1) {\n        c = 0xedB88320 ^ ((c >> 1) & 0x7fffffff);\n      } else {\n        c = (c >> 1) & 0x7fffffff;\n      }\n    }\n    crcTable[i] = c;\n  }\n\n  function crc32(data, start, end) {\n    var crc = -1;\n    for (var i = start; i < end; i++) {\n      var a = (crc ^ data[i]) & 0xff;\n      var b = crcTable[a];\n      crc = (crc >>> 8) ^ b;\n    }\n    return crc ^ -1;\n  }\n\n  function writePngChunk(type, body, data, offset) {\n    var p = offset;\n    var len = body.length;\n\n    data[p] = len >> 24 & 0xff;\n    data[p + 1] = len >> 16 & 0xff;\n    data[p + 2] = len >> 8 & 0xff;\n    data[p + 3] = len & 0xff;\n    p += 4;\n\n    data[p] = type.charCodeAt(0) & 0xff;\n    data[p + 1] = type.charCodeAt(1) & 0xff;\n    data[p + 2] = type.charCodeAt(2) & 0xff;\n    data[p + 3] = type.charCodeAt(3) & 0xff;\n    p += 4;\n\n    data.set(body, p);\n    p += body.length;\n\n    var crc = crc32(data, offset + 4, p);\n\n    data[p] = crc >> 24 & 0xff;\n    data[p + 1] = crc >> 16 & 0xff;\n    data[p + 2] = crc >> 8 & 0xff;\n    data[p + 3] = crc & 0xff;\n  }\n\n  function adler32(data, start, end) {\n    var a = 1;\n    var b = 0;\n    for (var i = start; i < end; ++i) {\n      a = (a + (data[i] & 0xff)) % 65521;\n      b = (b + a) % 65521;\n    }\n    return (b << 16) | a;\n  }\n\n  function encode(imgData, kind) {\n    var width = imgData.width;\n    var height = imgData.height;\n    var bitDepth, colorType, lineSize;\n    var bytes = imgData.data;\n\n    switch (kind) {\n      case ImageKind.GRAYSCALE_1BPP:\n        colorType = 0;\n        bitDepth = 1;\n        lineSize = (width + 7) >> 3;\n        break;\n      case ImageKind.RGB_24BPP:\n        colorType = 2;\n        bitDepth = 8;\n        lineSize = width * 3;\n        break;\n      case ImageKind.RGBA_32BPP:\n        colorType = 6;\n        bitDepth = 8;\n        lineSize = width * 4;\n        break;\n      default:\n        throw new Error('invalid format');\n    }\n\n    // prefix every row with predictor 0\n    var literals = new Uint8Array((1 + lineSize) * height);\n    var offsetLiterals = 0, offsetBytes = 0;\n    var y, i;\n    for (y = 0; y < height; ++y) {\n      literals[offsetLiterals++] = 0; // no prediction\n      literals.set(bytes.subarray(offsetBytes, offsetBytes + lineSize),\n                   offsetLiterals);\n      offsetBytes += lineSize;\n      offsetLiterals += lineSize;\n    }\n\n    if (kind === ImageKind.GRAYSCALE_1BPP) {\n      // inverting for B/W\n      offsetLiterals = 0;\n      for (y = 0; y < height; y++) {\n        offsetLiterals++; // skipping predictor\n        for (i = 0; i < lineSize; i++) {\n          literals[offsetLiterals++] ^= 0xFF;\n        }\n      }\n    }\n\n    var ihdr = new Uint8Array([\n      width >> 24 & 0xff,\n      width >> 16 & 0xff,\n      width >> 8 & 0xff,\n      width & 0xff,\n      height >> 24 & 0xff,\n      height >> 16 & 0xff,\n      height >> 8 & 0xff,\n      height & 0xff,\n      bitDepth, // bit depth\n      colorType, // color type\n      0x00, // compression method\n      0x00, // filter method\n      0x00 // interlace method\n    ]);\n\n    var len = literals.length;\n    var maxBlockLength = 0xFFFF;\n\n    var deflateBlocks = Math.ceil(len / maxBlockLength);\n    var idat = new Uint8Array(2 + len + deflateBlocks * 5 + 4);\n    var pi = 0;\n    idat[pi++] = 0x78; // compression method and flags\n    idat[pi++] = 0x9c; // flags\n\n    var pos = 0;\n    while (len > maxBlockLength) {\n      // writing non-final DEFLATE blocks type 0 and length of 65535\n      idat[pi++] = 0x00;\n      idat[pi++] = 0xff;\n      idat[pi++] = 0xff;\n      idat[pi++] = 0x00;\n      idat[pi++] = 0x00;\n      idat.set(literals.subarray(pos, pos + maxBlockLength), pi);\n      pi += maxBlockLength;\n      pos += maxBlockLength;\n      len -= maxBlockLength;\n    }\n\n    // writing non-final DEFLATE blocks type 0\n    idat[pi++] = 0x01;\n    idat[pi++] = len & 0xff;\n    idat[pi++] = len >> 8 & 0xff;\n    idat[pi++] = (~len & 0xffff) & 0xff;\n    idat[pi++] = (~len & 0xffff) >> 8 & 0xff;\n    idat.set(literals.subarray(pos), pi);\n    pi += literals.length - pos;\n\n    var adler = adler32(literals, 0, literals.length); // checksum\n    idat[pi++] = adler >> 24 & 0xff;\n    idat[pi++] = adler >> 16 & 0xff;\n    idat[pi++] = adler >> 8 & 0xff;\n    idat[pi++] = adler & 0xff;\n\n    // PNG will consists: header, IHDR+data, IDAT+data, and IEND.\n    var pngLength = PNG_HEADER.length + (CHUNK_WRAPPER_SIZE * 3) +\n                    ihdr.length + idat.length;\n    var data = new Uint8Array(pngLength);\n    var offset = 0;\n    data.set(PNG_HEADER, offset);\n    offset += PNG_HEADER.length;\n    writePngChunk('IHDR', ihdr, data, offset);\n    offset += CHUNK_WRAPPER_SIZE + ihdr.length;\n    writePngChunk('IDATA', idat, data, offset);\n    offset += CHUNK_WRAPPER_SIZE + idat.length;\n    writePngChunk('IEND', new Uint8Array(0), data, offset);\n\n    return PDFJS.createObjectURL(data, 'image/png');\n  }\n\n  return function convertImgDataToPng(imgData) {\n    var kind = (imgData.kind === undefined ?\n                ImageKind.GRAYSCALE_1BPP : imgData.kind);\n    return encode(imgData, kind);\n  };\n})();\n\nvar SVGExtraState = (function SVGExtraStateClosure() {\n  function SVGExtraState() {\n    this.fontSizeScale = 1;\n    this.fontWeight = SVG_DEFAULTS.fontWeight;\n    this.fontSize = 0;\n\n    this.textMatrix = IDENTITY_MATRIX;\n    this.fontMatrix = FONT_IDENTITY_MATRIX;\n    this.leading = 0;\n\n    // Current point (in user coordinates)\n    this.x = 0;\n    this.y = 0;\n\n    // Start of text line (in text coordinates)\n    this.lineX = 0;\n    this.lineY = 0;\n\n    // Character and word spacing\n    this.charSpacing = 0;\n    this.wordSpacing = 0;\n    this.textHScale = 1;\n    this.textRise = 0;\n\n    // Default foreground and background colors\n    this.fillColor = SVG_DEFAULTS.fillColor;\n    this.strokeColor = '#000000';\n\n    this.fillAlpha = 1;\n    this.strokeAlpha = 1;\n    this.lineWidth = 1;\n    this.lineJoin = '';\n    this.lineCap = '';\n    this.miterLimit = 0;\n\n    this.dashArray = [];\n    this.dashPhase = 0;\n\n    this.dependencies = [];\n\n    // Clipping\n    this.clipId = '';\n    this.pendingClip = false;\n\n    this.maskId = '';\n  }\n\n  SVGExtraState.prototype = {\n    clone: function SVGExtraState_clone() {\n      return Object.create(this);\n    },\n    setCurrentPoint: function SVGExtraState_setCurrentPoint(x, y) {\n      this.x = x;\n      this.y = y;\n    }\n  };\n  return SVGExtraState;\n})();\n\nvar SVGGraphics = (function SVGGraphicsClosure() {\n  function createScratchSVG(width, height) {\n    var NS = 'http://www.w3.org/2000/svg';\n    var svg = document.createElementNS(NS, 'svg:svg');\n    svg.setAttributeNS(null, 'version', '1.1');\n    svg.setAttributeNS(null, 'width', width + 'px');\n    svg.setAttributeNS(null, 'height', height + 'px');\n    svg.setAttributeNS(null, 'viewBox', '0 0 ' + width + ' ' + height);\n    return svg;\n  }\n\n  function opListToTree(opList) {\n    var opTree = [];\n    var tmp = [];\n    var opListLen = opList.length;\n\n    for (var x = 0; x < opListLen; x++) {\n      if (opList[x].fn === 'save') {\n        opTree.push({'fnId': 92, 'fn': 'group', 'items': []});\n        tmp.push(opTree);\n        opTree = opTree[opTree.length - 1].items;\n        continue;\n      }\n\n      if(opList[x].fn === 'restore') {\n        opTree = tmp.pop();\n      } else {\n        opTree.push(opList[x]);\n      }\n    }\n    return opTree;\n  }\n\n  /**\n   * Formats float number.\n   * @param value {number} number to format.\n   * @returns {string}\n   */\n  function pf(value) {\n    if (value === (value | 0)) { // integer number\n      return value.toString();\n    }\n    var s = value.toFixed(10);\n    var i = s.length - 1;\n    if (s[i] !== '0') {\n      return s;\n    }\n    // removing trailing zeros\n    do {\n      i--;\n    } while (s[i] === '0');\n    return s.substr(0, s[i] === '.' ? i : i + 1);\n  }\n\n  /**\n   * Formats transform matrix. The standard rotation, scale and translate\n   * matrices are replaced by their shorter forms, and for identity matrix\n   * returns empty string to save the memory.\n   * @param m {Array} matrix to format.\n   * @returns {string}\n   */\n  function pm(m) {\n    if (m[4] === 0 && m[5] === 0) {\n      if (m[1] === 0 && m[2] === 0) {\n        if (m[0] === 1 && m[3] === 1) {\n          return '';\n        }\n        return 'scale(' + pf(m[0]) + ' ' + pf(m[3]) + ')';\n      }\n      if (m[0] === m[3] && m[1] === -m[2]) {\n        var a = Math.acos(m[0]) * 180 / Math.PI;\n        return 'rotate(' + pf(a) + ')';\n      }\n    } else {\n      if (m[0] === 1 && m[1] === 0 && m[2] === 0 && m[3] === 1) {\n        return 'translate(' + pf(m[4]) + ' ' + pf(m[5]) + ')';\n      }\n    }\n    return 'matrix(' + pf(m[0]) + ' ' + pf(m[1]) + ' ' + pf(m[2]) + ' ' +\n      pf(m[3]) + ' ' + pf(m[4]) + ' ' + pf(m[5]) + ')';\n  }\n\n  function SVGGraphics(commonObjs, objs) {\n    this.current = new SVGExtraState();\n    this.transformMatrix = IDENTITY_MATRIX; // Graphics state matrix\n    this.transformStack = [];\n    this.extraStack = [];\n    this.commonObjs = commonObjs;\n    this.objs = objs;\n    this.pendingEOFill = false;\n\n    this.embedFonts = false;\n    this.embeddedFonts = {};\n    this.cssStyle = null;\n  }\n\n  var NS = 'http://www.w3.org/2000/svg';\n  var XML_NS = 'http://www.w3.org/XML/1998/namespace';\n  var XLINK_NS = 'http://www.w3.org/1999/xlink';\n  var LINE_CAP_STYLES = ['butt', 'round', 'square'];\n  var LINE_JOIN_STYLES = ['miter', 'round', 'bevel'];\n  var clipCount = 0;\n  var maskCount = 0;\n\n  SVGGraphics.prototype = {\n    save: function SVGGraphics_save() {\n      this.transformStack.push(this.transformMatrix);\n      var old = this.current;\n      this.extraStack.push(old);\n      this.current = old.clone();\n    },\n\n    restore: function SVGGraphics_restore() {\n      this.transformMatrix = this.transformStack.pop();\n      this.current = this.extraStack.pop();\n\n      this.tgrp = document.createElementNS(NS, 'svg:g');\n      this.tgrp.setAttributeNS(null, 'transform', pm(this.transformMatrix));\n      this.pgrp.appendChild(this.tgrp);\n    },\n\n    group: function SVGGraphics_group(items) {\n      this.save();\n      this.executeOpTree(items);\n      this.restore();\n    },\n\n    loadDependencies: function SVGGraphics_loadDependencies(operatorList) {\n      var fnArray = operatorList.fnArray;\n      var fnArrayLen = fnArray.length;\n      var argsArray = operatorList.argsArray;\n\n      var self = this;\n      for (var i = 0; i < fnArrayLen; i++) {\n        if (OPS.dependency === fnArray[i]) {\n          var deps = argsArray[i];\n          for (var n = 0, nn = deps.length; n < nn; n++) {\n            var obj = deps[n];\n            var common = obj.substring(0, 2) === 'g_';\n            var promise;\n            if (common) {\n              promise = new Promise(function(resolve) {\n                self.commonObjs.get(obj, resolve);\n              });\n            } else {\n              promise = new Promise(function(resolve) {\n                self.objs.get(obj, resolve);\n              });\n            }\n            this.current.dependencies.push(promise);\n          }\n        }\n      }\n      return Promise.all(this.current.dependencies);\n    },\n\n    transform: function SVGGraphics_transform(a, b, c, d, e, f) {\n      var transformMatrix = [a, b, c, d, e, f];\n      this.transformMatrix = PDFJS.Util.transform(this.transformMatrix,\n                                                  transformMatrix);\n\n      this.tgrp = document.createElementNS(NS, 'svg:g');\n      this.tgrp.setAttributeNS(null, 'transform', pm(this.transformMatrix));\n    },\n\n    getSVG: function SVGGraphics_getSVG(operatorList, viewport) {\n      this.svg = createScratchSVG(viewport.width, viewport.height);\n      this.viewport = viewport;\n\n      return this.loadDependencies(operatorList).then(function () {\n        this.transformMatrix = IDENTITY_MATRIX;\n        this.pgrp = document.createElementNS(NS, 'svg:g'); // Parent group\n        this.pgrp.setAttributeNS(null, 'transform', pm(viewport.transform));\n        this.tgrp = document.createElementNS(NS, 'svg:g'); // Transform group\n        this.tgrp.setAttributeNS(null, 'transform', pm(this.transformMatrix));\n        this.defs = document.createElementNS(NS, 'svg:defs');\n        this.pgrp.appendChild(this.defs);\n        this.pgrp.appendChild(this.tgrp);\n        this.svg.appendChild(this.pgrp);\n        var opTree = this.convertOpList(operatorList);\n        this.executeOpTree(opTree);\n        return this.svg;\n      }.bind(this));\n    },\n\n    convertOpList: function SVGGraphics_convertOpList(operatorList) {\n      var argsArray = operatorList.argsArray;\n      var fnArray = operatorList.fnArray;\n      var fnArrayLen  = fnArray.length;\n      var REVOPS = [];\n      var opList = [];\n\n      for (var op in OPS) {\n        REVOPS[OPS[op]] = op;\n      }\n\n      for (var x = 0; x < fnArrayLen; x++) {\n        var fnId = fnArray[x];\n        opList.push({'fnId' : fnId, 'fn': REVOPS[fnId], 'args': argsArray[x]});\n      }\n      return opListToTree(opList);\n    },\n\n    executeOpTree: function SVGGraphics_executeOpTree(opTree) {\n      var opTreeLen = opTree.length;\n      for(var x = 0; x < opTreeLen; x++) {\n        var fn = opTree[x].fn;\n        var fnId = opTree[x].fnId;\n        var args = opTree[x].args;\n\n        switch (fnId | 0) {\n          case OPS.beginText:\n            this.beginText();\n            break;\n          case OPS.setLeading:\n            this.setLeading(args);\n            break;\n          case OPS.setLeadingMoveText:\n            this.setLeadingMoveText(args[0], args[1]);\n            break;\n          case OPS.setFont:\n            this.setFont(args);\n            break;\n          case OPS.showText:\n            this.showText(args[0]);\n            break;\n          case OPS.showSpacedText:\n            this.showText(args[0]);\n            break;\n          case OPS.endText:\n            this.endText();\n            break;\n          case OPS.moveText:\n            this.moveText(args[0], args[1]);\n            break;\n          case OPS.setCharSpacing:\n            this.setCharSpacing(args[0]);\n            break;\n          case OPS.setWordSpacing:\n            this.setWordSpacing(args[0]);\n            break;\n          case OPS.setHScale:\n            this.setHScale(args[0]);\n            break;\n          case OPS.setTextMatrix:\n            this.setTextMatrix(args[0], args[1], args[2],\n                               args[3], args[4], args[5]);\n            break;\n          case OPS.setLineWidth:\n            this.setLineWidth(args[0]);\n            break;\n          case OPS.setLineJoin:\n            this.setLineJoin(args[0]);\n            break;\n          case OPS.setLineCap:\n            this.setLineCap(args[0]);\n            break;\n          case OPS.setMiterLimit:\n            this.setMiterLimit(args[0]);\n            break;\n          case OPS.setFillRGBColor:\n            this.setFillRGBColor(args[0], args[1], args[2]);\n            break;\n          case OPS.setStrokeRGBColor:\n            this.setStrokeRGBColor(args[0], args[1], args[2]);\n            break;\n          case OPS.setDash:\n            this.setDash(args[0], args[1]);\n            break;\n          case OPS.setGState:\n            this.setGState(args[0]);\n            break;\n          case OPS.fill:\n            this.fill();\n            break;\n          case OPS.eoFill:\n            this.eoFill();\n            break;\n          case OPS.stroke:\n            this.stroke();\n            break;\n          case OPS.fillStroke:\n            this.fillStroke();\n            break;\n          case OPS.eoFillStroke:\n            this.eoFillStroke();\n            break;\n          case OPS.clip:\n            this.clip('nonzero');\n            break;\n          case OPS.eoClip:\n            this.clip('evenodd');\n            break;\n          case OPS.paintSolidColorImageMask:\n            this.paintSolidColorImageMask();\n            break;\n          case OPS.paintJpegXObject:\n            this.paintJpegXObject(args[0], args[1], args[2]);\n            break;\n          case OPS.paintImageXObject:\n            this.paintImageXObject(args[0]);\n            break;\n          case OPS.paintInlineImageXObject:\n            this.paintInlineImageXObject(args[0]);\n            break;\n          case OPS.paintImageMaskXObject:\n            this.paintImageMaskXObject(args[0]);\n            break;\n          case OPS.paintFormXObjectBegin:\n            this.paintFormXObjectBegin(args[0], args[1]);\n            break;\n          case OPS.paintFormXObjectEnd:\n            this.paintFormXObjectEnd();\n            break;\n          case OPS.closePath:\n            this.closePath();\n            break;\n          case OPS.closeStroke:\n            this.closeStroke();\n            break;\n          case OPS.closeFillStroke:\n            this.closeFillStroke();\n            break;\n          case OPS.nextLine:\n            this.nextLine();\n            break;\n          case OPS.transform:\n            this.transform(args[0], args[1], args[2], args[3],\n                           args[4], args[5]);\n            break;\n          case OPS.constructPath:\n            this.constructPath(args[0], args[1]);\n            break;\n          case OPS.endPath:\n            this.endPath();\n            break;\n          case 92:\n            this.group(opTree[x].items);\n            break;\n          default:\n            warn('Unimplemented method '+ fn);\n            break;\n        }\n      }\n    },\n\n    setWordSpacing: function SVGGraphics_setWordSpacing(wordSpacing) {\n      this.current.wordSpacing = wordSpacing;\n    },\n\n    setCharSpacing: function SVGGraphics_setCharSpacing(charSpacing) {\n      this.current.charSpacing = charSpacing;\n    },\n\n    nextLine: function SVGGraphics_nextLine() {\n      this.moveText(0, this.current.leading);\n    },\n\n    setTextMatrix: function SVGGraphics_setTextMatrix(a, b, c, d, e, f) {\n      var current = this.current;\n      this.current.textMatrix = this.current.lineMatrix = [a, b, c, d, e, f];\n\n      this.current.x = this.current.lineX = 0;\n      this.current.y = this.current.lineY = 0;\n\n      current.xcoords = [];\n      current.tspan = document.createElementNS(NS, 'svg:tspan');\n      current.tspan.setAttributeNS(null, 'font-family', current.fontFamily);\n      current.tspan.setAttributeNS(null, 'font-size',\n                                   pf(current.fontSize) + 'px');\n      current.tspan.setAttributeNS(null, 'y', pf(-current.y));\n\n      current.txtElement = document.createElementNS(NS, 'svg:text');\n      current.txtElement.appendChild(current.tspan);\n    },\n\n    beginText: function SVGGraphics_beginText() {\n      this.current.x = this.current.lineX = 0;\n      this.current.y = this.current.lineY = 0;\n      this.current.textMatrix = IDENTITY_MATRIX;\n      this.current.lineMatrix = IDENTITY_MATRIX;\n      this.current.tspan = document.createElementNS(NS, 'svg:tspan');\n      this.current.txtElement = document.createElementNS(NS, 'svg:text');\n      this.current.txtgrp = document.createElementNS(NS, 'svg:g');\n      this.current.xcoords = [];\n    },\n\n    moveText: function SVGGraphics_moveText(x, y) {\n      var current = this.current;\n      this.current.x = this.current.lineX += x;\n      this.current.y = this.current.lineY += y;\n\n      current.xcoords = [];\n      current.tspan = document.createElementNS(NS, 'svg:tspan');\n      current.tspan.setAttributeNS(null, 'font-family', current.fontFamily);\n      current.tspan.setAttributeNS(null, 'font-size',\n                                   pf(current.fontSize) + 'px');\n      current.tspan.setAttributeNS(null, 'y', pf(-current.y));\n    },\n\n    showText: function SVGGraphics_showText(glyphs) {\n      var current = this.current;\n      var font = current.font;\n      var fontSize = current.fontSize;\n\n      if (fontSize === 0) {\n        return;\n      }\n\n      var charSpacing = current.charSpacing;\n      var wordSpacing = current.wordSpacing;\n      var fontDirection = current.fontDirection;\n      var textHScale = current.textHScale * fontDirection;\n      var glyphsLength = glyphs.length;\n      var vertical = font.vertical;\n      var widthAdvanceScale = fontSize * current.fontMatrix[0];\n\n      var x = 0, i;\n      for (i = 0; i < glyphsLength; ++i) {\n        var glyph = glyphs[i];\n        if (glyph === null) {\n          // word break\n          x += fontDirection * wordSpacing;\n          continue;\n        } else if (isNum(glyph)) {\n          x += -glyph * fontSize * 0.001;\n          continue;\n        }\n        current.xcoords.push(current.x + x * textHScale);\n\n        var width = glyph.width;\n        var character = glyph.fontChar;\n        var charWidth = width * widthAdvanceScale + charSpacing * fontDirection;\n        x += charWidth;\n\n        current.tspan.textContent += character;\n      }\n      if (vertical) {\n        current.y -= x * textHScale;\n      } else {\n        current.x += x * textHScale;\n      }\n\n      current.tspan.setAttributeNS(null, 'x',\n                                   current.xcoords.map(pf).join(' '));\n      current.tspan.setAttributeNS(null, 'y', pf(-current.y));\n      current.tspan.setAttributeNS(null, 'font-family', current.fontFamily);\n      current.tspan.setAttributeNS(null, 'font-size',\n                                   pf(current.fontSize) + 'px');\n      if (current.fontStyle !== SVG_DEFAULTS.fontStyle) {\n        current.tspan.setAttributeNS(null, 'font-style', current.fontStyle);\n      }\n      if (current.fontWeight !== SVG_DEFAULTS.fontWeight) {\n        current.tspan.setAttributeNS(null, 'font-weight', current.fontWeight);\n      }\n      if (current.fillColor !== SVG_DEFAULTS.fillColor) {\n        current.tspan.setAttributeNS(null, 'fill', current.fillColor);\n      }\n\n      current.txtElement.setAttributeNS(null, 'transform',\n                                        pm(current.textMatrix) +\n                                        ' scale(1, -1)' );\n      current.txtElement.setAttributeNS(XML_NS, 'xml:space', 'preserve');\n      current.txtElement.appendChild(current.tspan);\n      current.txtgrp.appendChild(current.txtElement);\n\n      this.tgrp.appendChild(current.txtElement);\n\n    },\n\n    setLeadingMoveText: function SVGGraphics_setLeadingMoveText(x, y) {\n      this.setLeading(-y);\n      this.moveText(x, y);\n    },\n\n    addFontStyle: function SVGGraphics_addFontStyle(fontObj) {\n      if (!this.cssStyle) {\n        this.cssStyle = document.createElementNS(NS, 'svg:style');\n        this.cssStyle.setAttributeNS(null, 'type', 'text/css');\n        this.defs.appendChild(this.cssStyle);\n      }\n\n      var url = PDFJS.createObjectURL(fontObj.data, fontObj.mimetype);\n      this.cssStyle.textContent +=\n        '@font-face { font-family: \"' + fontObj.loadedName + '\";' +\n        ' src: url(' + url + '); }\\n';\n    },\n\n    setFont: function SVGGraphics_setFont(details) {\n      var current = this.current;\n      var fontObj = this.commonObjs.get(details[0]);\n      var size = details[1];\n      this.current.font = fontObj;\n\n      if (this.embedFonts && fontObj.data &&\n          !this.embeddedFonts[fontObj.loadedName]) {\n        this.addFontStyle(fontObj);\n        this.embeddedFonts[fontObj.loadedName] = fontObj;\n      }\n\n      current.fontMatrix = (fontObj.fontMatrix ?\n                            fontObj.fontMatrix : FONT_IDENTITY_MATRIX);\n\n      var bold = fontObj.black ? (fontObj.bold ? 'bolder' : 'bold') :\n                                 (fontObj.bold ? 'bold' : 'normal');\n      var italic = fontObj.italic ? 'italic' : 'normal';\n\n      if (size < 0) {\n        size = -size;\n        current.fontDirection = -1;\n      } else {\n        current.fontDirection = 1;\n      }\n      current.fontSize = size;\n      current.fontFamily = fontObj.loadedName;\n      current.fontWeight = bold;\n      current.fontStyle = italic;\n\n      current.tspan = document.createElementNS(NS, 'svg:tspan');\n      current.tspan.setAttributeNS(null, 'y', pf(-current.y));\n      current.xcoords = [];\n    },\n\n    endText: function SVGGraphics_endText() {\n      if (this.current.pendingClip) {\n        this.cgrp.appendChild(this.tgrp);\n        this.pgrp.appendChild(this.cgrp);\n      } else {\n        this.pgrp.appendChild(this.tgrp);\n      }\n      this.tgrp = document.createElementNS(NS, 'svg:g');\n      this.tgrp.setAttributeNS(null, 'transform', pm(this.transformMatrix));\n    },\n\n    // Path properties\n    setLineWidth: function SVGGraphics_setLineWidth(width) {\n      this.current.lineWidth = width;\n    },\n    setLineCap: function SVGGraphics_setLineCap(style) {\n      this.current.lineCap = LINE_CAP_STYLES[style];\n    },\n    setLineJoin: function SVGGraphics_setLineJoin(style) {\n      this.current.lineJoin = LINE_JOIN_STYLES[style];\n    },\n    setMiterLimit: function SVGGraphics_setMiterLimit(limit) {\n      this.current.miterLimit = limit;\n    },\n    setStrokeRGBColor: function SVGGraphics_setStrokeRGBColor(r, g, b) {\n      var color = Util.makeCssRgb(r, g, b);\n      this.current.strokeColor = color;\n    },\n    setFillRGBColor: function SVGGraphics_setFillRGBColor(r, g, b) {\n      var color = Util.makeCssRgb(r, g, b);\n      this.current.fillColor = color;\n      this.current.tspan = document.createElementNS(NS, 'svg:tspan');\n      this.current.xcoords = [];\n    },\n    setDash: function SVGGraphics_setDash(dashArray, dashPhase) {\n      this.current.dashArray = dashArray;\n      this.current.dashPhase = dashPhase;\n    },\n\n    constructPath: function SVGGraphics_constructPath(ops, args) {\n      var current = this.current;\n      var x = current.x, y = current.y;\n      current.path = document.createElementNS(NS, 'svg:path');\n      var d = [];\n      var opLength = ops.length;\n\n      for (var i = 0, j = 0; i < opLength; i++) {\n        switch (ops[i] | 0) {\n          case OPS.rectangle:\n            x = args[j++];\n            y = args[j++];\n            var width = args[j++];\n            var height = args[j++];\n            var xw = x + width;\n            var yh = y + height;\n            d.push('M', pf(x), pf(y), 'L', pf(xw) , pf(y), 'L', pf(xw), pf(yh),\n                   'L', pf(x), pf(yh), 'Z');\n            break;\n          case OPS.moveTo:\n            x = args[j++];\n            y = args[j++];\n            d.push('M', pf(x), pf(y));\n            break;\n          case OPS.lineTo:\n            x = args[j++];\n            y = args[j++];\n            d.push('L', pf(x) , pf(y));\n            break;\n          case OPS.curveTo:\n            x = args[j + 4];\n            y = args[j + 5];\n            d.push('C', pf(args[j]), pf(args[j + 1]), pf(args[j + 2]),\n                   pf(args[j + 3]), pf(x), pf(y));\n            j += 6;\n            break;\n          case OPS.curveTo2:\n            x = args[j + 2];\n            y = args[j + 3];\n            d.push('C', pf(x), pf(y), pf(args[j]), pf(args[j + 1]),\n                   pf(args[j + 2]), pf(args[j + 3]));\n            j += 4;\n            break;\n          case OPS.curveTo3:\n            x = args[j + 2];\n            y = args[j + 3];\n            d.push('C', pf(args[j]), pf(args[j + 1]), pf(x), pf(y),\n                   pf(x), pf(y));\n            j += 4;\n            break;\n          case OPS.closePath:\n            d.push('Z');\n            break;\n        }\n      }\n      current.path.setAttributeNS(null, 'd', d.join(' '));\n      current.path.setAttributeNS(null, 'stroke-miterlimit',\n                                  pf(current.miterLimit));\n      current.path.setAttributeNS(null, 'stroke-linecap', current.lineCap);\n      current.path.setAttributeNS(null, 'stroke-linejoin', current.lineJoin);\n      current.path.setAttributeNS(null, 'stroke-width',\n                                  pf(current.lineWidth) + 'px');\n      current.path.setAttributeNS(null, 'stroke-dasharray',\n                                  current.dashArray.map(pf).join(' '));\n      current.path.setAttributeNS(null, 'stroke-dashoffset',\n                                  pf(current.dashPhase) + 'px');\n      current.path.setAttributeNS(null, 'fill', 'none');\n\n      this.tgrp.appendChild(current.path);\n      if (current.pendingClip) {\n        this.cgrp.appendChild(this.tgrp);\n        this.pgrp.appendChild(this.cgrp);\n      } else {\n        this.pgrp.appendChild(this.tgrp);\n      }\n      // Saving a reference in current.element so that it can be addressed\n      // in 'fill' and 'stroke'\n      current.element = current.path;\n      current.setCurrentPoint(x, y);\n    },\n\n    endPath: function SVGGraphics_endPath() {\n      var current = this.current;\n      if (current.pendingClip) {\n        this.cgrp.appendChild(this.tgrp);\n        this.pgrp.appendChild(this.cgrp);\n      } else {\n        this.pgrp.appendChild(this.tgrp);\n      }\n      this.tgrp = document.createElementNS(NS, 'svg:g');\n      this.tgrp.setAttributeNS(null, 'transform', pm(this.transformMatrix));\n    },\n\n    clip: function SVGGraphics_clip(type) {\n      var current = this.current;\n      // Add current path to clipping path\n      current.clipId = 'clippath' + clipCount;\n      clipCount++;\n      this.clippath = document.createElementNS(NS, 'svg:clipPath');\n      this.clippath.setAttributeNS(null, 'id', current.clipId);\n      var clipElement = current.element.cloneNode();\n      if (type === 'evenodd') {\n        clipElement.setAttributeNS(null, 'clip-rule', 'evenodd');\n      } else {\n        clipElement.setAttributeNS(null, 'clip-rule', 'nonzero');\n      }\n      this.clippath.setAttributeNS(null, 'transform', pm(this.transformMatrix));\n      this.clippath.appendChild(clipElement);\n      this.defs.appendChild(this.clippath);\n\n      // Create a new group with that attribute\n      current.pendingClip = true;\n      this.cgrp = document.createElementNS(NS, 'svg:g');\n      this.cgrp.setAttributeNS(null, 'clip-path',\n                               'url(#' + current.clipId + ')');\n      this.pgrp.appendChild(this.cgrp);\n    },\n\n    closePath: function SVGGraphics_closePath() {\n      var current = this.current;\n      var d = current.path.getAttributeNS(null, 'd');\n      d += 'Z';\n      current.path.setAttributeNS(null, 'd', d);\n    },\n\n    setLeading: function SVGGraphics_setLeading(leading) {\n      this.current.leading = -leading;\n    },\n\n    setTextRise: function SVGGraphics_setTextRise(textRise) {\n      this.current.textRise = textRise;\n    },\n\n    setHScale: function SVGGraphics_setHScale(scale) {\n      this.current.textHScale = scale / 100;\n    },\n\n    setGState: function SVGGraphics_setGState(states) {\n      for (var i = 0, ii = states.length; i < ii; i++) {\n        var state = states[i];\n        var key = state[0];\n        var value = state[1];\n\n        switch (key) {\n          case 'LW':\n            this.setLineWidth(value);\n            break;\n          case 'LC':\n            this.setLineCap(value);\n            break;\n          case 'LJ':\n            this.setLineJoin(value);\n            break;\n          case 'ML':\n            this.setMiterLimit(value);\n            break;\n          case 'D':\n            this.setDash(value[0], value[1]);\n            break;\n          case 'RI':\n            break;\n          case 'FL':\n            break;\n          case 'Font':\n            this.setFont(value);\n            break;\n          case 'CA':\n            break;\n          case 'ca':\n            break;\n          case 'BM':\n            break;\n          case 'SMask':\n            break;\n        }\n      }\n    },\n\n    fill: function SVGGraphics_fill() {\n      var current = this.current;\n      current.element.setAttributeNS(null, 'fill', current.fillColor);\n    },\n\n    stroke: function SVGGraphics_stroke() {\n      var current = this.current;\n      current.element.setAttributeNS(null, 'stroke', current.strokeColor);\n      current.element.setAttributeNS(null, 'fill', 'none');\n    },\n\n    eoFill: function SVGGraphics_eoFill() {\n      var current = this.current;\n      current.element.setAttributeNS(null, 'fill', current.fillColor);\n      current.element.setAttributeNS(null, 'fill-rule', 'evenodd');\n    },\n\n    fillStroke: function SVGGraphics_fillStroke() {\n      // Order is important since stroke wants fill to be none.\n      // First stroke, then if fill needed, it will be overwritten.\n      this.stroke();\n      this.fill();\n    },\n\n    eoFillStroke: function SVGGraphics_eoFillStroke() {\n      this.current.element.setAttributeNS(null, 'fill-rule', 'evenodd');\n      this.fillStroke();\n    },\n\n    closeStroke: function SVGGraphics_closeStroke() {\n      this.closePath();\n      this.stroke();\n    },\n\n    closeFillStroke: function SVGGraphics_closeFillStroke() {\n      this.closePath();\n      this.fillStroke();\n    },\n\n    paintSolidColorImageMask:\n        function SVGGraphics_paintSolidColorImageMask() {\n      var current = this.current;\n      var rect = document.createElementNS(NS, 'svg:rect');\n      rect.setAttributeNS(null, 'x', '0');\n      rect.setAttributeNS(null, 'y', '0');\n      rect.setAttributeNS(null, 'width', '1px');\n      rect.setAttributeNS(null, 'height', '1px');\n      rect.setAttributeNS(null, 'fill', current.fillColor);\n      this.tgrp.appendChild(rect);\n    },\n\n    paintJpegXObject: function SVGGraphics_paintJpegXObject(objId, w, h) {\n      var current = this.current;\n      var imgObj = this.objs.get(objId);\n      var imgEl = document.createElementNS(NS, 'svg:image');\n      imgEl.setAttributeNS(XLINK_NS, 'xlink:href', imgObj.src);\n      imgEl.setAttributeNS(null, 'width', imgObj.width + 'px');\n      imgEl.setAttributeNS(null, 'height', imgObj.height + 'px');\n      imgEl.setAttributeNS(null, 'x', '0');\n      imgEl.setAttributeNS(null, 'y', pf(-h));\n      imgEl.setAttributeNS(null, 'transform',\n                           'scale(' + pf(1 / w) + ' ' + pf(-1 / h) + ')');\n\n      this.tgrp.appendChild(imgEl);\n      if (current.pendingClip) {\n        this.cgrp.appendChild(this.tgrp);\n        this.pgrp.appendChild(this.cgrp);\n      } else {\n        this.pgrp.appendChild(this.tgrp);\n      }\n    },\n\n    paintImageXObject: function SVGGraphics_paintImageXObject(objId) {\n      var imgData = this.objs.get(objId);\n      if (!imgData) {\n        warn('Dependent image isn\\'t ready yet');\n        return;\n      }\n      this.paintInlineImageXObject(imgData);\n    },\n\n    paintInlineImageXObject:\n        function SVGGraphics_paintInlineImageXObject(imgData, mask) {\n      var current = this.current;\n      var width = imgData.width;\n      var height = imgData.height;\n\n      var imgSrc = convertImgDataToPng(imgData);\n      var cliprect = document.createElementNS(NS, 'svg:rect');\n      cliprect.setAttributeNS(null, 'x', '0');\n      cliprect.setAttributeNS(null, 'y', '0');\n      cliprect.setAttributeNS(null, 'width', pf(width));\n      cliprect.setAttributeNS(null, 'height', pf(height));\n      current.element = cliprect;\n      this.clip('nonzero');\n      var imgEl = document.createElementNS(NS, 'svg:image');\n      imgEl.setAttributeNS(XLINK_NS, 'xlink:href', imgSrc);\n      imgEl.setAttributeNS(null, 'x', '0');\n      imgEl.setAttributeNS(null, 'y', pf(-height));\n      imgEl.setAttributeNS(null, 'width', pf(width) + 'px');\n      imgEl.setAttributeNS(null, 'height', pf(height) + 'px');\n      imgEl.setAttributeNS(null, 'transform',\n                           'scale(' + pf(1 / width) + ' ' +\n                           pf(-1 / height) + ')');\n      if (mask) {\n        mask.appendChild(imgEl);\n      } else {\n        this.tgrp.appendChild(imgEl);\n      }\n      if (current.pendingClip) {\n        this.cgrp.appendChild(this.tgrp);\n        this.pgrp.appendChild(this.cgrp);\n      } else {\n        this.pgrp.appendChild(this.tgrp);\n      }\n    },\n\n    paintImageMaskXObject:\n        function SVGGraphics_paintImageMaskXObject(imgData) {\n      var current = this.current;\n      var width = imgData.width;\n      var height = imgData.height;\n      var fillColor = current.fillColor;\n\n      current.maskId = 'mask' + maskCount++;\n      var mask = document.createElementNS(NS, 'svg:mask');\n      mask.setAttributeNS(null, 'id', current.maskId);\n\n      var rect = document.createElementNS(NS, 'svg:rect');\n      rect.setAttributeNS(null, 'x', '0');\n      rect.setAttributeNS(null, 'y', '0');\n      rect.setAttributeNS(null, 'width', pf(width));\n      rect.setAttributeNS(null, 'height', pf(height));\n      rect.setAttributeNS(null, 'fill', fillColor);\n      rect.setAttributeNS(null, 'mask', 'url(#' + current.maskId +')');\n      this.defs.appendChild(mask);\n      this.tgrp.appendChild(rect);\n\n      this.paintInlineImageXObject(imgData, mask);\n    },\n\n    paintFormXObjectBegin:\n        function SVGGraphics_paintFormXObjectBegin(matrix, bbox) {\n      this.save();\n\n      if (isArray(matrix) && matrix.length === 6) {\n        this.transform(matrix[0], matrix[1], matrix[2],\n                       matrix[3], matrix[4], matrix[5]);\n      }\n\n      if (isArray(bbox) && bbox.length === 4) {\n        var width = bbox[2] - bbox[0];\n        var height = bbox[3] - bbox[1];\n\n        var cliprect = document.createElementNS(NS, 'svg:rect');\n        cliprect.setAttributeNS(null, 'x', bbox[0]);\n        cliprect.setAttributeNS(null, 'y', bbox[1]);\n        cliprect.setAttributeNS(null, 'width', pf(width));\n        cliprect.setAttributeNS(null, 'height', pf(height));\n        this.current.element = cliprect;\n        this.clip('nonzero');\n        this.endPath();\n      }\n    },\n\n    paintFormXObjectEnd:\n        function SVGGraphics_paintFormXObjectEnd() {\n      this.restore();\n    }\n  };\n  return SVGGraphics;\n})();\n\nPDFJS.SVGGraphics = SVGGraphics;\n\n\n}).call((typeof window === 'undefined') ? this : window);\n\nif (!PDFJS.workerSrc && typeof document !== 'undefined') {\n  // workerSrc is not set -- using last script url to define default location\n  PDFJS.workerSrc = (function () {\n    'use strict';\n    var scriptTagContainer = document.body ||\n                             document.getElementsByTagName('head')[0];\n    var pdfjsSrc = scriptTagContainer.lastChild.src;\n    return pdfjsSrc && pdfjsSrc.replace(/\\.js$/i, '.worker.js');\n  })();\n}\n\n\n","/* -*- Mode: Java; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */\n/* vim: set shiftwidth=2 tabstop=2 autoindent cindent expandtab: */\n/* Copyright 2012 Mozilla Foundation\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/* globals VBArray, PDFJS */\n\n'use strict';\n\n// Initializing PDFJS global object here, it case if we need to change/disable\n// some PDF.js features, e.g. range requests\nif (typeof PDFJS === 'undefined') {\n  (typeof window !== 'undefined' ? window : this).PDFJS = {};\n}\n\n// Checking if the typed arrays are supported\n// Support: iOS<6.0 (subarray), IE<10, Android<4.0\n(function checkTypedArrayCompatibility() {\n  if (typeof Uint8Array !== 'undefined') {\n    // Support: iOS<6.0\n    if (typeof Uint8Array.prototype.subarray === 'undefined') {\n        Uint8Array.prototype.subarray = function subarray(start, end) {\n          return new Uint8Array(this.slice(start, end));\n        };\n        Float32Array.prototype.subarray = function subarray(start, end) {\n          return new Float32Array(this.slice(start, end));\n        };\n    }\n\n    // Support: Android<4.1\n    if (typeof Float64Array === 'undefined') {\n      window.Float64Array = Float32Array;\n    }\n    return;\n  }\n\n  function subarray(start, end) {\n    return new TypedArray(this.slice(start, end));\n  }\n\n  function setArrayOffset(array, offset) {\n    if (arguments.length < 2) {\n      offset = 0;\n    }\n    for (var i = 0, n = array.length; i < n; ++i, ++offset) {\n      this[offset] = array[i] & 0xFF;\n    }\n  }\n\n  function TypedArray(arg1) {\n    var result, i, n;\n    if (typeof arg1 === 'number') {\n      result = [];\n      for (i = 0; i < arg1; ++i) {\n        result[i] = 0;\n      }\n    } else if ('slice' in arg1) {\n      result = arg1.slice(0);\n    } else {\n      result = [];\n      for (i = 0, n = arg1.length; i < n; ++i) {\n        result[i] = arg1[i];\n      }\n    }\n\n    result.subarray = subarray;\n    result.buffer = result;\n    result.byteLength = result.length;\n    result.set = setArrayOffset;\n\n    if (typeof arg1 === 'object' && arg1.buffer) {\n      result.buffer = arg1.buffer;\n    }\n    return result;\n  }\n\n  window.Uint8Array = TypedArray;\n  window.Int8Array = TypedArray;\n\n  // we don't need support for set, byteLength for 32-bit array\n  // so we can use the TypedArray as well\n  window.Uint32Array = TypedArray;\n  window.Int32Array = TypedArray;\n  window.Uint16Array = TypedArray;\n  window.Float32Array = TypedArray;\n  window.Float64Array = TypedArray;\n})();\n\n// URL = URL || webkitURL\n// Support: Safari<7, Android 4.2+\n(function normalizeURLObject() {\n  if (!window.URL) {\n    window.URL = window.webkitURL;\n  }\n})();\n\n// Object.defineProperty()?\n// Support: Android<4.0, Safari<5.1\n(function checkObjectDefinePropertyCompatibility() {\n  if (typeof Object.defineProperty !== 'undefined') {\n    var definePropertyPossible = true;\n    try {\n      // some browsers (e.g. safari) cannot use defineProperty() on DOM objects\n      // and thus the native version is not sufficient\n      Object.defineProperty(new Image(), 'id', { value: 'test' });\n      // ... another test for android gb browser for non-DOM objects\n      var Test = function Test() {};\n      Test.prototype = { get id() { } };\n      Object.defineProperty(new Test(), 'id',\n        { value: '', configurable: true, enumerable: true, writable: false });\n    } catch (e) {\n      definePropertyPossible = false;\n    }\n    if (definePropertyPossible) {\n      return;\n    }\n  }\n\n  Object.defineProperty = function objectDefineProperty(obj, name, def) {\n    delete obj[name];\n    if ('get' in def) {\n      obj.__defineGetter__(name, def['get']);\n    }\n    if ('set' in def) {\n      obj.__defineSetter__(name, def['set']);\n    }\n    if ('value' in def) {\n      obj.__defineSetter__(name, function objectDefinePropertySetter(value) {\n        this.__defineGetter__(name, function objectDefinePropertyGetter() {\n          return value;\n        });\n        return value;\n      });\n      obj[name] = def.value;\n    }\n  };\n})();\n\n\n// No XMLHttpRequest#response?\n// Support: IE<11, Android <4.0\n(function checkXMLHttpRequestResponseCompatibility() {\n  var xhrPrototype = XMLHttpRequest.prototype;\n  var xhr = new XMLHttpRequest();\n  if (!('overrideMimeType' in xhr)) {\n    // IE10 might have response, but not overrideMimeType\n    // Support: IE10\n    Object.defineProperty(xhrPrototype, 'overrideMimeType', {\n      value: function xmlHttpRequestOverrideMimeType(mimeType) {}\n    });\n  }\n  if ('responseType' in xhr) {\n    return;\n  }\n\n  // The worker will be using XHR, so we can save time and disable worker.\n  PDFJS.disableWorker = true;\n\n  Object.defineProperty(xhrPrototype, 'responseType', {\n    get: function xmlHttpRequestGetResponseType() {\n      return this._responseType || 'text';\n    },\n    set: function xmlHttpRequestSetResponseType(value) {\n      if (value === 'text' || value === 'arraybuffer') {\n        this._responseType = value;\n        if (value === 'arraybuffer' &&\n            typeof this.overrideMimeType === 'function') {\n          this.overrideMimeType('text/plain; charset=x-user-defined');\n        }\n      }\n    }\n  });\n\n  // Support: IE9\n  if (typeof VBArray !== 'undefined') {\n    Object.defineProperty(xhrPrototype, 'response', {\n      get: function xmlHttpRequestResponseGet() {\n        if (this.responseType === 'arraybuffer') {\n          return new Uint8Array(new VBArray(this.responseBody).toArray());\n        } else {\n          return this.responseText;\n        }\n      }\n    });\n    return;\n  }\n\n  Object.defineProperty(xhrPrototype, 'response', {\n    get: function xmlHttpRequestResponseGet() {\n      if (this.responseType !== 'arraybuffer') {\n        return this.responseText;\n      }\n      var text = this.responseText;\n      var i, n = text.length;\n      var result = new Uint8Array(n);\n      for (i = 0; i < n; ++i) {\n        result[i] = text.charCodeAt(i) & 0xFF;\n      }\n      return result.buffer;\n    }\n  });\n})();\n\n// window.btoa (base64 encode function) ?\n// Support: IE<10\n(function checkWindowBtoaCompatibility() {\n  if ('btoa' in window) {\n    return;\n  }\n\n  var digits =\n    'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';\n\n  window.btoa = function windowBtoa(chars) {\n    var buffer = '';\n    var i, n;\n    for (i = 0, n = chars.length; i < n; i += 3) {\n      var b1 = chars.charCodeAt(i) & 0xFF;\n      var b2 = chars.charCodeAt(i + 1) & 0xFF;\n      var b3 = chars.charCodeAt(i + 2) & 0xFF;\n      var d1 = b1 >> 2, d2 = ((b1 & 3) << 4) | (b2 >> 4);\n      var d3 = i + 1 < n ? ((b2 & 0xF) << 2) | (b3 >> 6) : 64;\n      var d4 = i + 2 < n ? (b3 & 0x3F) : 64;\n      buffer += (digits.charAt(d1) + digits.charAt(d2) +\n                 digits.charAt(d3) + digits.charAt(d4));\n    }\n    return buffer;\n  };\n})();\n\n// window.atob (base64 encode function)?\n// Support: IE<10\n(function checkWindowAtobCompatibility() {\n  if ('atob' in window) {\n    return;\n  }\n\n  // https://github.com/davidchambers/Base64.js\n  var digits =\n    'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';\n  window.atob = function (input) {\n    input = input.replace(/=+$/, '');\n    if (input.length % 4 === 1) {\n      throw new Error('bad atob input');\n    }\n    for (\n      // initialize result and counters\n      var bc = 0, bs, buffer, idx = 0, output = '';\n      // get next character\n      buffer = input.charAt(idx++);\n      // character found in table?\n      // initialize bit storage and add its ascii value\n      ~buffer && (bs = bc % 4 ? bs * 64 + buffer : buffer,\n        // and if not first of each 4 characters,\n        // convert the first 8 bits to one ascii character\n        bc++ % 4) ? output += String.fromCharCode(255 & bs >> (-2 * bc & 6)) : 0\n    ) {\n      // try to find character in table (0-63, not found => -1)\n      buffer = digits.indexOf(buffer);\n    }\n    return output;\n  };\n})();\n\n// Function.prototype.bind?\n// Support: Android<4.0, iOS<6.0\n(function checkFunctionPrototypeBindCompatibility() {\n  if (typeof Function.prototype.bind !== 'undefined') {\n    return;\n  }\n\n  Function.prototype.bind = function functionPrototypeBind(obj) {\n    var fn = this, headArgs = Array.prototype.slice.call(arguments, 1);\n    var bound = function functionPrototypeBindBound() {\n      var args = headArgs.concat(Array.prototype.slice.call(arguments));\n      return fn.apply(obj, args);\n    };\n    return bound;\n  };\n})();\n\n// HTMLElement dataset property\n// Support: IE<11, Safari<5.1, Android<4.0\n(function checkDatasetProperty() {\n  var div = document.createElement('div');\n  if ('dataset' in div) {\n    return; // dataset property exists\n  }\n\n  Object.defineProperty(HTMLElement.prototype, 'dataset', {\n    get: function() {\n      if (this._dataset) {\n        return this._dataset;\n      }\n\n      var dataset = {};\n      for (var j = 0, jj = this.attributes.length; j < jj; j++) {\n        var attribute = this.attributes[j];\n        if (attribute.name.substring(0, 5) !== 'data-') {\n          continue;\n        }\n        var key = attribute.name.substring(5).replace(/\\-([a-z])/g,\n          function(all, ch) {\n            return ch.toUpperCase();\n          });\n        dataset[key] = attribute.value;\n      }\n\n      Object.defineProperty(this, '_dataset', {\n        value: dataset,\n        writable: false,\n        enumerable: false\n      });\n      return dataset;\n    },\n    enumerable: true\n  });\n})();\n\n// HTMLElement classList property\n// Support: IE<10, Android<4.0, iOS<5.0\n(function checkClassListProperty() {\n  var div = document.createElement('div');\n  if ('classList' in div) {\n    return; // classList property exists\n  }\n\n  function changeList(element, itemName, add, remove) {\n    var s = element.className || '';\n    var list = s.split(/\\s+/g);\n    if (list[0] === '') {\n      list.shift();\n    }\n    var index = list.indexOf(itemName);\n    if (index < 0 && add) {\n      list.push(itemName);\n    }\n    if (index >= 0 && remove) {\n      list.splice(index, 1);\n    }\n    element.className = list.join(' ');\n    return (index >= 0);\n  }\n\n  var classListPrototype = {\n    add: function(name) {\n      changeList(this.element, name, true, false);\n    },\n    contains: function(name) {\n      return changeList(this.element, name, false, false);\n    },\n    remove: function(name) {\n      changeList(this.element, name, false, true);\n    },\n    toggle: function(name) {\n      changeList(this.element, name, true, true);\n    }\n  };\n\n  Object.defineProperty(HTMLElement.prototype, 'classList', {\n    get: function() {\n      if (this._classList) {\n        return this._classList;\n      }\n\n      var classList = Object.create(classListPrototype, {\n        element: {\n          value: this,\n          writable: false,\n          enumerable: true\n        }\n      });\n      Object.defineProperty(this, '_classList', {\n        value: classList,\n        writable: false,\n        enumerable: false\n      });\n      return classList;\n    },\n    enumerable: true\n  });\n})();\n\n// Check console compatibility\n// In older IE versions the console object is not available\n// unless console is open.\n// Support: IE<10\n(function checkConsoleCompatibility() {\n  if (!('console' in window)) {\n    window.console = {\n      log: function() {},\n      error: function() {},\n      warn: function() {}\n    };\n  } else if (!('bind' in console.log)) {\n    // native functions in IE9 might not have bind\n    console.log = (function(fn) {\n      return function(msg) { return fn(msg); };\n    })(console.log);\n    console.error = (function(fn) {\n      return function(msg) { return fn(msg); };\n    })(console.error);\n    console.warn = (function(fn) {\n      return function(msg) { return fn(msg); };\n    })(console.warn);\n  }\n})();\n\n// Check onclick compatibility in Opera\n// Support: Opera<15\n(function checkOnClickCompatibility() {\n  // workaround for reported Opera bug DSK-354448:\n  // onclick fires on disabled buttons with opaque content\n  function ignoreIfTargetDisabled(event) {\n    if (isDisabled(event.target)) {\n      event.stopPropagation();\n    }\n  }\n  function isDisabled(node) {\n    return node.disabled || (node.parentNode && isDisabled(node.parentNode));\n  }\n  if (navigator.userAgent.indexOf('Opera') !== -1) {\n    // use browser detection since we cannot feature-check this bug\n    document.addEventListener('click', ignoreIfTargetDisabled, true);\n  }\n})();\n\n// Checks if possible to use URL.createObjectURL()\n// Support: IE\n(function checkOnBlobSupport() {\n  // sometimes IE loosing the data created with createObjectURL(), see #3977\n  if (navigator.userAgent.indexOf('Trident') >= 0) {\n    PDFJS.disableCreateObjectURL = true;\n  }\n})();\n\n// Checks if navigator.language is supported\n(function checkNavigatorLanguage() {\n  if ('language' in navigator) {\n    return;\n  }\n  PDFJS.locale = navigator.userLanguage || 'en-US';\n})();\n\n(function checkRangeRequests() {\n  // Safari has issues with cached range requests see:\n  // https://github.com/mozilla/pdf.js/issues/3260\n  // Last tested with version 6.0.4.\n  // Support: Safari 6.0+\n  var isSafari = Object.prototype.toString.call(\n                  window.HTMLElement).indexOf('Constructor') > 0;\n\n  // Older versions of Android (pre 3.0) has issues with range requests, see:\n  // https://github.com/mozilla/pdf.js/issues/3381.\n  // Make sure that we only match webkit-based Android browsers,\n  // since Firefox/Fennec works as expected.\n  // Support: Android<3.0\n  var regex = /Android\\s[0-2][^\\d]/;\n  var isOldAndroid = regex.test(navigator.userAgent);\n\n  // Range requests are broken in Chrome 39 and 40, https://crbug.com/442318\n  var isChromeWithRangeBug = /Chrome\\/(39|40)\\./.test(navigator.userAgent);\n\n  if (isSafari || isOldAndroid || isChromeWithRangeBug) {\n    PDFJS.disableRange = true;\n    PDFJS.disableStream = true;\n  }\n})();\n\n// Check if the browser supports manipulation of the history.\n// Support: IE<10, Android<4.2\n(function checkHistoryManipulation() {\n  // Android 2.x has so buggy pushState support that it was removed in\n  // Android 3.0 and restored as late as in Android 4.2.\n  // Support: Android 2.x\n  if (!history.pushState || navigator.userAgent.indexOf('Android 2.') >= 0) {\n    PDFJS.disableHistory = true;\n  }\n})();\n\n// Support: IE<11, Chrome<21, Android<4.4, Safari<6\n(function checkSetPresenceInImageData() {\n  // IE < 11 will use window.CanvasPixelArray which lacks set function.\n  if (window.CanvasPixelArray) {\n    if (typeof window.CanvasPixelArray.prototype.set !== 'function') {\n      window.CanvasPixelArray.prototype.set = function(arr) {\n        for (var i = 0, ii = this.length; i < ii; i++) {\n          this[i] = arr[i];\n        }\n      };\n    }\n  } else {\n    // Old Chrome and Android use an inaccessible CanvasPixelArray prototype.\n    // Because we cannot feature detect it, we rely on user agent parsing.\n    var polyfill = false, versionMatch;\n    if (navigator.userAgent.indexOf('Chrom') >= 0) {\n      versionMatch = navigator.userAgent.match(/Chrom(e|ium)\\/([0-9]+)\\./);\n      // Chrome < 21 lacks the set function.\n      polyfill = versionMatch && parseInt(versionMatch[2]) < 21;\n    } else if (navigator.userAgent.indexOf('Android') >= 0) {\n      // Android < 4.4 lacks the set function.\n      // Android >= 4.4 will contain Chrome in the user agent,\n      // thus pass the Chrome check above and not reach this block.\n      polyfill = /Android\\s[0-4][^\\d]/g.test(navigator.userAgent);\n    } else if (navigator.userAgent.indexOf('Safari') >= 0) {\n      versionMatch = navigator.userAgent.\n        match(/Version\\/([0-9]+)\\.([0-9]+)\\.([0-9]+) Safari\\//);\n      // Safari < 6 lacks the set function.\n      polyfill = versionMatch && parseInt(versionMatch[1]) < 6;\n    }\n\n    if (polyfill) {\n      var contextPrototype = window.CanvasRenderingContext2D.prototype;\n      contextPrototype._createImageData = contextPrototype.createImageData;\n      contextPrototype.createImageData = function(w, h) {\n        var imageData = this._createImageData(w, h);\n        imageData.data.set = function(arr) {\n          for (var i = 0, ii = this.length; i < ii; i++) {\n            this[i] = arr[i];\n          }\n        };\n        return imageData;\n      };\n    }\n  }\n})();\n\n// Support: IE<10, Android<4.0, iOS\n(function checkRequestAnimationFrame() {\n  function fakeRequestAnimationFrame(callback) {\n    window.setTimeout(callback, 20);\n  }\n\n  var isIOS = /(iPad|iPhone|iPod)/g.test(navigator.userAgent);\n  if (isIOS) {\n    // requestAnimationFrame on iOS is broken, replacing with fake one.\n    window.requestAnimationFrame = fakeRequestAnimationFrame;\n    return;\n  }\n  if ('requestAnimationFrame' in window) {\n    return;\n  }\n  window.requestAnimationFrame =\n    window.mozRequestAnimationFrame ||\n    window.webkitRequestAnimationFrame ||\n    fakeRequestAnimationFrame;\n})();\n\n(function checkCanvasSizeLimitation() {\n  var isIOS = /(iPad|iPhone|iPod)/g.test(navigator.userAgent);\n  var isAndroid = /Android/g.test(navigator.userAgent);\n  if (isIOS || isAndroid) {\n    // 5MP\n    PDFJS.maxCanvasPixels = 5242880;\n  }\n})();\n\n// Disable fullscreen support for certain problematic configurations.\n// Support: IE11+ (when embedded).\n(function checkFullscreenSupport() {\n  var isEmbeddedIE = (navigator.userAgent.indexOf('Trident') >= 0 &&\n                      window.parent !== window);\n  if (isEmbeddedIE) {\n    PDFJS.disableFullscreen = true;\n  }\n})();\n"]}